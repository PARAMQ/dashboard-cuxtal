/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.12.7
 * @license MIT
 * @copyright (c) 2017-2023, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import { noop, coalesce, pick, isEqual, clonePlainObject, stubObject, mergeDescriptors, assert, isNumber, isFunction, instanceOf, upperFirst, camelCase, constant, round, addPrefix, and, isString, makeWatchers, lowerFirst, isObjectLike, isEmpty, map as map$1, isArray, negate, omit, isPlainObject, identity, stubArray, or, forEach, sealFactory, range } from './utils';
import { BingMaps, Cluster, Source, Vector, ImageArcGISRest, ImageStatic, ImageWMS, OSM, Stamen, TileArcGISRest, TileWMS, VectorTile as VectorTile$1, WMTS } from 'ol/source';
import { tileImageSource, makeChangeOrRecreateWatchers, stubVNode, sourceContainer, olCmp, vectorSource, interaction, styleContainer, FRAME_TIME, simpleGeometry, feature, projTransforms, waitForMap, style, regShapeStyle, imageStyle, fillStyleContainer, strokeStyleContainer, textStyleContainer, imageStyleContainer, geometryContainer, vectorLayer, layersContainer, baseLayer, arcgisSource, imageSource, imageLayer, wmsSource, controlsContainer, interactionsContainer, overlaysContainer, featuresContainer, xyzSource, source, urlTileSource, tileLayer, featureHelper, tileSource } from './mixins';
import { getSourceId, findPointOnSurface, createPointGeom, GeometryType, roundLineCoords, initializeFeature, writeGeoJsonFeature, COORD_PRECISION, isPointCoords, roundPointCoords, transformDistance, isLineCoords, isMultiLineCoords, isMultiPointCoords, isMultiPolygonCoords, isPolygonCoords, EPSG_3857, normalizeColor, dumpStrokeStyle, dumpFillStyle, dumpTextStyle, dumpImageStyle, getLayerId, roundExtent, initializeView, getViewId, setViewId, isGeoJSONGeometry, getControlId, getInteractionId, getOverlayId, setMapId, setMapDataProjection, getMapId, getMapDataProjection, OverlayPositioning, initializeOverlay, setOverlayId, isGeoJSONFeature, getFeatureId, dumpStyle, createMvtFmt, extentFromProjection, getCorner, ExtentCorner } from './ol-ext';
import { Collection, Geolocation, View, Map as Map$1, Overlay as Overlay$1, Feature as Feature$1 } from 'ol';
import { noModifierKeys, shiftKeyOnly, primaryAction, altKeyOnly, always, never, singleClick } from 'ol/events/condition';
import { Draw, Modify, Select, Snap, Translate } from 'ol/interaction';
import { merge, of } from 'rxjs';
import { map, tap, mergeMap, mapTo, delay, first, distinctUntilChanged } from 'rxjs/operators';
import { fromOlEvent, fromVueEvent, fromOlChangeEvent, fromVueWatcher, bufferDebounceTime } from './rx-ext';
import { Circle, Point, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon } from 'ol/geom';
import { get } from 'ol/proj';
import GraticuleLayer$1 from 'ol/layer/Graticule';
import { Fill, Stroke, Circle as Circle$1, Icon, RegularShape, Style as Style$1, Text } from 'ol/style';
import IconAnchorUnits from 'ol/style/IconAnchorUnits';
import IconOrigin from 'ol/style/IconOrigin';
import { Group, Heatmap, Image as Image$1, Vector as Vector$1, VectorTile, MapboxVector, Tile, VectorImage } from 'ol/layer';
import MapBrowserEventType from 'ol/MapBrowserEventType';
import MapEventType from 'ol/MapEventType';
import RenderEventType from 'ol/render/EventType';
import RenderType from 'ol/layer/VectorTileRenderType';
import RotateInteraction$1 from 'ol-rotate-feature';
import VectorEventType from 'ol/source/VectorEventType';
import { createTileUrlFunctionFromTemplates } from 'ol-tilecache';
import TileEventType from 'ol/source/TileEventType';
import { createXYZ } from 'ol/tilegrid';
import { getHeight, getWidth } from 'ol/extent';
import { toSize } from 'ol/size';
import { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from 'ol/tilegrid/common';
import WMTSTileGrid from 'ol/tilegrid/WMTS';

var script$S = {
  name: 'VlSourceBingmaps',
  mixins: [tileImageSource],
  props: {
    // ol/source/BingMaps

    /**
     * Enables hidpi tiles.
     * @type {boolean}
     */
    hidpi: {
      type: Boolean,
      default: false
    },

    /**
     * Culture code.
     * @type {string}
     */
    culture: {
      type: String,
      default: 'en-us'
    },

    /**
     * Bing Maps API key.
     * @type {string}
     */
    apiKey: {
      type: String,
      required: true
    },

    /**
     * Type of imagery.
     * @type {string}
     */
    imagerySet: {
      type: String,
      required: true
    },

    /**
     * @type {number}
     */
    maxZoom: {
      type: Number,
      default: 21
    }
  },
  computed: {
    tileGridIdent: noop,
    inputTileGridFactory: noop,
    inputUrl: noop,
    inputUrls: noop,
    inputTileUrlFunction: noop,
    inputAttributions: noop
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['hidpi', 'culture', 'apiKey', 'imagerySet', 'maxZoom'])
  },
  methods: {
    /**
     * @return {module:ol/source/BingMaps}
     * @protected
     */
    createSource() {
      return new BingMaps({
        // ol/source/Source
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        opaque: this.opaque,
        transition: this.transition,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        // ol/source/TileImage
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        imageSmoothing: this.imageSmoothing,
        // ol/source/BingMaps
        hidpi: this.hidpi,
        culture: this.culture,
        key: this.apiKey,
        imagerySet: this.imagerySet,
        maxZoom: this.maxZoom
      });
    },

    getApiKey() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getApiKey(), this.apiKey);
    },

    getImagerySet() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImagerySet(), this.imagerySet);
    },

    stateChanged: noop,
    attributionsCollapsibleChanged: noop,
    projectionChanged: noop,
    tileGridIdentChanged: noop,
    inputTileGridFactoryChanged: noop,
    tileGridChanged: noop,
    tileKeyChanged: noop,
    tilePixelRatioChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop,
    inputUrlsChanged: noop,
    crossOriginChanged: noop,
    tileClassChanged: noop
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

/* script */
const __vue_script__$S = script$S;
/* template */

/* style */

const __vue_inject_styles__$S = undefined;
/* scoped */

const __vue_scope_id__$S = undefined;
/* module identifier */

const __vue_module_identifier__$S = undefined;
/* functional template */

const __vue_is_functional_template__$S = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$S = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$S, __vue_script__$S, __vue_scope_id__$S, __vue_is_functional_template__$S, __vue_module_identifier__$S, false, undefined, undefined, undefined);

/**
 * @param {Vue} Vue
 * @param {VueLayersOptions} [options]
 */

function plugin$A(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$A.installed) {
    return;
  }

  plugin$A.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$S, options);
  Vue.component(__vue_component__$S.name, __vue_component__$S);
}

var BingmapsSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$A,
  install: plugin$A,
  Source: __vue_component__$S
});

var script$R = {
  name: 'VlSourceInnerAdapter',
  mixins: [stubVNode, sourceContainer, olCmp],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  computed: {
    source() {
      if (!(this.rev && this.$source)) return;
      return {
        id: getSourceId(this.$source),
        type: this.$source.constructor.name
      };
    }

  },
  watch: {
    source: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:source', value && clonePlainObject(value));
      }

    }
  },

  created() {
    Object.defineProperties(this, {
      $innerSourceContainer: {
        enumerable: true,
        get: () => {
          var _this$$services;

          return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.innerSourceContainer;
        }
      }
    });
  },

  methods: {
    createOlObject() {
      const obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },

    getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), sourceContainer.methods.getServices.call(this));
    },

    getSourceTarget() {
      return {
        getSource: () => {
          var _this$$innerSourceCon;

          return (_this$$innerSourceCon = this.$innerSourceContainer) === null || _this$$innerSourceCon === void 0 ? void 0 : _this$$innerSourceCon.getInnerSource();
        },
        setSource: source => {
          var _this$$innerSourceCon2;

          return (_this$$innerSourceCon2 = this.$innerSourceContainer) === null || _this$$innerSourceCon2 === void 0 ? void 0 : _this$$innerSourceCon2.setInnerSource(source);
        }
      };
    }

  }
};

/* script */
const __vue_script__$R = script$R;
/* template */

/* style */

const __vue_inject_styles__$R = undefined;
/* scoped */

const __vue_scope_id__$R = undefined;
/* module identifier */

const __vue_module_identifier__$R = undefined;
/* functional template */

const __vue_is_functional_template__$R = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$R = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$R, __vue_script__$R, __vue_scope_id__$R, __vue_is_functional_template__$R, __vue_module_identifier__$R, false, undefined, undefined, undefined);

//
var script$Q = {
  name: 'VlSourceCluster',
  components: {
    InnerSource: __vue_component__$R
  },
  mixins: [vectorSource],
  props: {
    distance: {
      type: Number,
      default: 20
    },
    geometryFunction: {
      type: Function // default: defaultGeomFunc,

    },

    /**
     * @deprecated
     * @todo remove later
     */
    geomFunc: Function,

    /**
     * @deprecated Use geomFunc prop instead.
     * @todo remove in v0.13.x
     */
    geomFuncFactory: Function
  },

  data() {
    return {
      currentDistance: this.distance
    };
  },

  computed: {
    inputGeometryFunction() {
      let geomFunc = this.geometryFunction || this.geomFunc;

      if (!geomFunc && this.geomFuncFactory) {
        geomFunc = this.geomFuncFactory();
      }

      return geomFunc || defaultGeomFunc;
    },

    innerSource() {
      if (!(this.rev && this.$innerSource)) return;
      return {
        id: getSourceId(this.$innerSource),
        type: this.$innerSource.constructor.name
      };
    },

    inputUrl: noop,
    inputLoader: noop,
    inputLoadingStrategy: noop,
    formatIdent: noop,
    inputFormatFactory: noop
  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (this.currentDistance !== this.$source.getDistance()) {
        this.currentDistance = this.$source.getDistance();
      }
    },

    distance(value) {
      this.setDistance(value);
    },

    currentDistance(value) {
      if (value === this.distance) return;
      this.$emit('update:distance', value);
    },

    innerSource: {
      deep: true,

      handler(value, prev) {
        if (value === prev) return;
        this.$emit('update:innerSource', value && clonePlainObject(value));
      }

    },
    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['inputGeometryFunction'])
  },

  created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.geomFuncFactory) {
        this.$logger.warn("'geomFuncFactory' prop is deprecated. Use 'geometryFunction' prop instead.");
      }

      if (this.geomFunc) {
        this.$logger.warn("'geomFunc' prop is deprecated. Use 'geometryFunction' prop instead.");
      }
    }

    this._innerSource = undefined;
    this._innerSourceVm = undefined;
    defineServices$9.call(this);
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.geomFuncFactory) {
        this.$logger.warn("'geomFuncFactory' prop is deprecated. Use 'geometryFunction' prop instead.");
      }

      if (this.geomFunc) {
        this.$logger.warn("'geomFunc' prop is deprecated. Use 'geometryFunction' prop instead.");
      }
    }
  },

  methods: {
    createSource() {
      return new Cluster({
        // ol/source/Source
        attributions: this.currentAttributions,
        wrapX: this.wrapX,
        // ol/source/Cluster
        source: this.$innerSource,
        distance: this.currentDistance,
        geometryFunction: this.inputGeometryFunction
      });
    },

    getServices() {
      const vm = this;
      return mergeDescriptors(vectorSource.methods.getServices.call(this), {
        get innerSourceContainer() {
          return vm;
        }

      });
    },

    getDistance() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getDistance(), this.currentDistance);
    },

    setDistance(distance) {
      assert(isNumber(distance), 'Invalid distance');

      if (distance !== this.currentDistance) {
        this.currentDistance = distance;
      }

      if (this.$source && distance !== this.$source.getDistance()) {
        this.$source.setDistance(distance);
      }
    },

    getInnerSource() {
      return this._innerSource;
    },

    getInnerSourceVm() {
      return this._innerSourceVm;
    },

    setInnerSource(innerSource) {
      var _innerSource;

      innerSource = ((_innerSource = innerSource) === null || _innerSource === void 0 ? void 0 : _innerSource.$source) || innerSource;
      assert(!innerSource || innerSource instanceof Source);
      innerSource || (innerSource = undefined);

      if (innerSource !== this._innerSource) {
        var _innerSource2;

        this._innerSource = innerSource;
        this._innerSourceVm = ((_innerSource2 = innerSource) === null || _innerSource2 === void 0 ? void 0 : _innerSource2.vm) && innerSource.vm[0];
        this.scheduleRefresh();
      }

      if (this.$source && innerSource !== this.$source.getSource()) {
        this.$source.setSource(innerSource);
        this.scheduleRefresh();
      }
    },

    projectionChanged: noop,
    inputUrlChanged: noop,
    inputLoaderChanged: noop,
    inputLoadingStrategyChanged: noop,
    inputFormatFactoryChanged: noop,
    formatIdentChanged: noop,
    formatChanged: noop,
    overlapsChanged: noop,
    useSpatialIndexChanged: noop
  }
};

function defineServices$9() {
  Object.defineProperties(this, {
    $innerSource: {
      enumerable: true,
      get: this.getInnerSource
    },
    $innerSourceVm: {
      enumerable: true,
      get: this.getInnerSourceVm
    }
  });
}

function defaultGeomFunc(feature) {
  const geometry = feature.getGeometry();
  if (!geometry) return;
  const coordinate = findPointOnSurface(geometry);

  if (coordinate) {
    return createPointGeom(coordinate);
  }
}

/* script */
const __vue_script__$Q = script$Q;
/* template */

var __vue_render__$a = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_c('InnerSource', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-inner-source'
    }
  }, [_vm._t("default")], 2)], 1);
};

var __vue_staticRenderFns__$a = [];
/* style */

const __vue_inject_styles__$Q = undefined;
/* scoped */

const __vue_scope_id__$Q = undefined;
/* module identifier */

const __vue_module_identifier__$Q = undefined;
/* functional template */

const __vue_is_functional_template__$Q = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$Q = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$a,
  staticRenderFns: __vue_staticRenderFns__$a
}, __vue_inject_styles__$Q, __vue_script__$Q, __vue_scope_id__$Q, __vue_is_functional_template__$Q, __vue_module_identifier__$Q, false, undefined, undefined, undefined);

function plugin$z(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$z.installed) {
    return;
  }

  plugin$z.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$Q, options);
  Vue.component(__vue_component__$Q.name, __vue_component__$Q);
}

var ClusterSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$z,
  install: plugin$z,
  Source: __vue_component__$Q
});

const transformType = type => upperFirst(camelCase(type));

var script$P = {
  name: 'VlInteractionDraw',
  mixins: [interaction, styleContainer],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    /**
     * Target source or collection identifier from IdentityMap.
     * @type {String}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * The maximum distance in pixels between "down" and "up" for a "up" event to be considered a "click" event and
     * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the
     * draw interaction to behave correctly on mouse as well as on touch devices.
     * @type {number}
     */
    clickTolerance: {
      type: Number,
      default: 6
    },

    /**
     * Pixel distance for snapping to the drawing finish.
     * @type {number}
     */
    snapTolerance: {
      type: Number,
      default: 12
    },

    /**
     * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').
     * @type {string}
     */
    type: {
      type: String,
      required: true,
      validator: value => Object.values(GeometryType).includes(transformType(value))
    },

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * @type {boolean}
     */
    stopClick: {
      type: Boolean,
      default: false
    },

    /**
     * The number of points that can be drawn before a polygon ring or line string is finished.
     * @type {number|undefined}
     */
    maxPoints: Number,

    /**
     * The number of points that must be drawn before a polygon ring or line string can be finished.
     * Default is `3` for polygon rings and `2` for line strings.
     * @type {number|undefined}
     */
    minPoints: Number,

    /**
     * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.
     * @type {function|undefined}
     */
    finishCondition: Function,

    /**
     * Function that is called when a geometry's coordinates are updated.
     * @type {function|undefined}
     */
    geometryFunction: Function,

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string}
     */
    geometryName: {
      type: String,
      default: 'geometry'
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: noModifierKeys
    },

    /**
     * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in
     * freehand mode and takes precedence over any `freehandCondition` option.
     * @type {boolean}
     */
    freehand: {
      type: Boolean,
      default: false
    },

    /**
     * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and
     * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,
     * meaning that the Shift key activates freehand drawing.
     * @type {function|undefined}
     */
    freehandCondition: {
      type: Function,
      default: shiftKeyOnly
    },

    /**
     * Wrap the world horizontally on the sketch overlay.
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: false
    },

    /**
     * Delay in milliseconds after pointerdown before the current vertex can be dragged to its exact position.
     * @type {number}
     */
    dragVertexDelay: {
      type: Number,
      default: 500
    }
  },
  computed: {
    inputType() {
      return transformType(this.type);
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'clickTolerance', 'snapTolerance', 'inputType', 'stopClick', 'maxPoints', 'minPoints', 'finishCondition', 'geometryFunction', 'geometryName', 'condition', 'freehand', 'freehandCondition', 'wrapX', 'dragVertexDelay'])
  },
  methods: {
    /**
     * @return {Promise<Draw>}
     * @protected
     */
    async createInteraction() {
      let source = this._source = await this.getInstance(this.source);
      assert(!!source, `Source "${this.source}" not found in identity map.`);
      let features;

      if (!(source instanceof Vector)) {
        if (isFunction(source.getFeaturesCollection)) {
          features = source.getFeaturesCollection();
        } else if (isFunction(source.getFeatures)) {
          features = source.getFeatures();
        }

        instanceOf(features, Collection, `Source "${this.source}" doesn't provide features collection.`);
        source = null;
      }

      return new Draw({
        source,
        features,
        clickTolerance: this.clickTolerance,
        snapTolerance: this.snapTolerance,
        type: this.inputType,
        stopClick: this.stopClick,
        maxPoints: this.maxPoints,
        minPoints: this.minPoints,
        finishCondition: this.finishCondition,
        geometryFunction: this.geometryFunction,
        geometryName: this.geometryName,
        condition: this.condition,
        freehand: this.freehand,
        freehandCondition: this.freehandCondition,
        wrapX: this.wrapX,
        dragVertexDelay: this.dragVertexDelay,
        style: this.$style
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      subscribeToInteractionChanges$4.call(this);
    },

    /**
     * @return {StyleTarget}
     * @protected
     */
    getStyleTarget() {
      return {
        getStyle: () => this._style,
        setStyle: () => {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log('style changed, scheduling recreate...');
          }

          this.scheduleRecreate();
        }
      };
    },

    async getOverlay() {
      return (await this.resolveInteraction()).getOverlay();
    },

    async abortDrawing() {
      (await this.resolveInteraction()).abortDrawing();
    },

    async finishDrawing() {
      (await this.resolveInteraction()).finishDrawing();
    },

    async appendCoordinates(coordinates) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      coordinates = viewProj ? roundLineCoords(coordinates) : this.lineToViewProj(coordinates);
      (await this.resolveInteraction()).appendCoordinates(coordinates);
    },

    async removeLastPoint() {
      (await this.resolveInteraction()).removeLastPoint();
    },

    async getPointerCount() {
      return (await this.resolveInteraction()).getPointerCount();
    }

  }
};
/**
 * @return {void}
 * @private
 */

function subscribeToInteractionChanges$4() {
  const start = fromOlEvent(this.$interaction, 'drawstart').pipe(map(evt => ({ ...evt,
    feature: initializeFeature(evt.feature)
  })), tap(() => this.setInteracting(true)));

  const sourceUpdObs = () => {
    var _this$_source, _this$_source$vm;

    if (!((_this$_source = this._source) !== null && _this$_source !== void 0 && (_this$_source$vm = _this$_source.vm) !== null && _this$_source$vm !== void 0 && _this$_source$vm.length)) {
      return of(true).pipe(delay(3 * FRAME_TIME));
    } // update:features on the source (which is feature-container)
    // will be always after drawend with delay ~= computed property update time + FRAME_TIME
    // so we can safely just wait first event


    return fromVueEvent(this._source.vm[0], 'update:features').pipe(first());
  };

  const end = fromOlEvent(this.$interaction, 'drawend').pipe(mergeMap(evt => sourceUpdObs().pipe(mapTo(evt))), tap(() => this.setInteracting(false)));
  const events = merge(start, end).pipe(map(_ref => {
    let {
      type,
      feature
    } = _ref;
    const viewProj = this.resolvedViewProjection;
    const dataProj = this.resolvedDataProjection;
    return {
      type,
      feature,

      get json() {
        if (!this._json) {
          this._json = writeGeoJsonFeature(this.feature, viewProj, dataProj, COORD_PRECISION);
        }

        return this._json;
      }

    };
  }));
  this.subscribeTo(events, evt => this.$emit(evt.type, evt));
}

/* script */
const __vue_script__$P = script$P;
/* template */

/* style */

const __vue_inject_styles__$P = undefined;
/* scoped */

const __vue_scope_id__$P = undefined;
/* module identifier */

const __vue_module_identifier__$P = undefined;
/* functional template */

const __vue_is_functional_template__$P = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$P = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$P, __vue_script__$P, __vue_scope_id__$P, __vue_is_functional_template__$P, __vue_module_identifier__$P, false, undefined, undefined, undefined);

function plugin$y(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$y.installed) {
    return;
  }

  plugin$y.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$P, options);
  Vue.component(__vue_component__$P.name, __vue_component__$P);
}

var DrawInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$y,
  install: plugin$y,
  Interaction: __vue_component__$P
});

var script$O = {
  name: 'VlGeomCircle',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: { ...simpleGeometry.props.coordinates,
      validator: isPointCoords
    },

    /* eslint-enable vue/require-prop-types */

    /**
     * Circle radius always in meters.
     * @type {number}
     */
    radius: {
      type: Number,
      default: 0
    },

    /**
     * Projection in which radius provided.
     * Default: map data projection
     * @type {string}
     */
    radiusProjection: {
      type: String,
      validator: value => !!get(value)
    }
  },

  data() {
    return {
      currentRadiusViewProj: this.radius
    };
  },

  computed: {
    type: /*#__PURE__*/constant(GeometryType.CIRCLE),

    resolvedRadiusProjection() {
      return this.radiusProjection || this.resolvedDataProjection;
    },

    radiusDataProj() {
      return round(this.radius);
    },

    radiusViewProj() {
      return this.radiusToViewProj(this.radius, this.coordinatesDataProj);
    },

    currentRadiusDataProj() {
      return this.radiusToDataProj(this.currentRadiusViewProj);
    }

  },
  watch: {
    radiusViewProj(value) {
      this.setRadius(value, true);
    },

    currentRadiusDataProj(value) {
      if (value === this.radiusDataProj) return;
      this.$emit('update:radius', value);
    }

  },

  created() {
    this.currentRadiusViewProj = this.radiusViewProj;
  },

  methods: {
    /**
     * @return {Circle}
     * @protected
     */
    createGeometry() {
      return new Circle(this.currentCoordinatesViewProj, this.currentRadiusViewProj);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]}
     */
    getCoordinates() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.getCenter(viewProj);
    },

    /**
     * @param {number[]} coordinate
     * @param {boolean} [viewProj=false]
     */
    setCoordinates(coordinate) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.setCenter(coordinate, viewProj);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]}
     */
    getCenter() {
      var _this$$geometry;

      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const center = coalesce((_this$$geometry = this.$geometry) === null || _this$$geometry === void 0 ? void 0 : _this$$geometry.getCenter(), this.currentCoordinatesViewProj);
      return viewProj ? roundPointCoords(center) : this.pointToDataProj(center);
    },

    /**
     * @param {number[]} center
     * @param {boolean} [viewProj=false]
     */
    setCenter(center) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isPointCoords(center), 'Invalid center');
      center = viewProj ? roundPointCoords(center) : this.pointToViewProj(center);

      if (!isEqual(center, this.currentCoordinatesViewProj)) {
        this.currentCoordinatesViewProj = center;
      }

      if (this.$geometry && !isEqual(center, this.$geometry.getCenter())) {
        this.$geometry.setCenter(center);
      }
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number}
     */
    getRadius() {
      var _this$$geometry2;

      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const radius = coalesce((_this$$geometry2 = this.$geometry) === null || _this$$geometry2 === void 0 ? void 0 : _this$$geometry2.getRadius(), this.currentRadiusViewProj);
      return viewProj ? round(radius) : this.radiusToDataProj(radius);
    },

    /**
     * @param {number} radius
     * @param {boolean} [viewProj=false]
     */
    setRadius(radius) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isNumber(radius), 'Invalid radius');
      radius = viewProj ? round(radius) : this.radiusToDataProj(radius);

      if (radius !== this.currentRadiusViewProj) {
        this.currentRadiusViewProj = radius;
      }

      if (this.$geometry && radius !== this.$geometry.getRadius()) {
        this.$geometry.setRadius(radius);
      }
    },

    /**
     * @param {number[]} center
     * @param {number} radius
     * @param {boolean} [viewProj=false]
     * @return {Promise<void>}
     */
    setCenterAndRadius(center, radius) {
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      center = viewProj ? roundPointCoords(center) : this.pointToViewProj(center);
      radius = viewProj ? round(radius) : this.radiusToViewProj(radius);

      if (this.$geometry) {
        this.$geometry.setCenterAndRadius(center, radius);
      } else {
        this.setCenter(center, true);
        this.setRadius(radius, true);
      }
    },

    /**
     * @param {number} radius
     * @return {undefined|number}
     * @protected
     */
    radiusToViewProj(radius) {
      return transformDistance(radius, this.resolvedRadiusProjection, this.resolvedViewProjection);
    },

    /**
     * @param {number} radius
     * @return {undefined|number}
     * @protected
     */
    radiusToDataProj(radius) {
      return transformDistance(radius, this.resolvedViewProjection, this.resolvedRadiusProjection);
    }

  }
};

/* script */
const __vue_script__$O = script$O;
/* template */

/* style */

const __vue_inject_styles__$O = undefined;
/* scoped */

const __vue_scope_id__$O = undefined;
/* module identifier */

const __vue_module_identifier__$O = undefined;
/* functional template */

const __vue_is_functional_template__$O = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$O = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$O, __vue_script__$O, __vue_scope_id__$O, __vue_is_functional_template__$O, __vue_module_identifier__$O, false, undefined, undefined, undefined);

var script$N = {
  name: 'VlGeomPoint',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: { ...simpleGeometry.props.coordinates,
      validator: isPointCoords
    }
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.POINT)
  },
  methods: {
    /**
     * @return {Point}
     * @protected
     */
    createGeometry() {
      return new Point(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates(coordinates) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isPointCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }

  }
};

/* script */
const __vue_script__$N = script$N;
/* template */

/* style */

const __vue_inject_styles__$N = undefined;
/* scoped */

const __vue_scope_id__$N = undefined;
/* module identifier */

const __vue_module_identifier__$N = undefined;
/* functional template */

const __vue_is_functional_template__$N = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$N = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$N, __vue_script__$N, __vue_scope_id__$N, __vue_is_functional_template__$N, __vue_module_identifier__$N, false, undefined, undefined, undefined);

//
/**
 * A vector object for geographic features with a geometry and other attribute properties,
 * similar to the features in vector file formats like **GeoJSON**.
 */

var script$M = {
  name: 'VlFeature',
  components: {
    PointGeom: __vue_component__$N
  },
  mixins: [feature]
};

/* script */
const __vue_script__$M = script$M;
/* template */

var __vue_render__$9 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", function () {
    return [_c('PointGeom', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-geom',
        "coordinates": [0, 0]
      }
    })];
  }, {
    "id": _vm.currentId,
    "properties": _vm.currentProperties
  })], 2);
};

var __vue_staticRenderFns__$9 = [];
/* style */

const __vue_inject_styles__$M = undefined;
/* scoped */

const __vue_scope_id__$M = undefined;
/* module identifier */

const __vue_module_identifier__$M = undefined;
/* functional template */

const __vue_is_functional_template__$M = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$M = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$9,
  staticRenderFns: __vue_staticRenderFns__$9
}, __vue_inject_styles__$M, __vue_script__$M, __vue_scope_id__$M, __vue_is_functional_template__$M, __vue_module_identifier__$M, false, undefined, undefined, undefined);

var script$L = {
  name: 'VlGeomLineString',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: { ...simpleGeometry.props.coordinates,
      validator: isLineCoords
    }
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.LINE_STRING)
  },
  methods: {
    /**
     * @returns {LineString}
     * @protected
     */
    createGeometry() {
      return new LineString(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates(coordinates) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isLineCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }

  }
};

/* script */
const __vue_script__$L = script$L;
/* template */

/* style */

const __vue_inject_styles__$L = undefined;
/* scoped */

const __vue_scope_id__$L = undefined;
/* module identifier */

const __vue_module_identifier__$L = undefined;
/* functional template */

const __vue_is_functional_template__$L = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$L = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$L, __vue_script__$L, __vue_scope_id__$L, __vue_is_functional_template__$L, __vue_module_identifier__$L, false, undefined, undefined, undefined);

var script$K = {
  name: 'VlGeomMultiLineString',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: { ...simpleGeometry.props.coordinates,
      validator: isMultiLineCoords
    }
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.MULTI_LINE_STRING)
  },
  methods: {
    /**
     * @returns {MultiLineString}
     * @protected
     */
    createGeometry() {
      return new MultiLineString(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates(coordinates) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isMultiLineCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }

  }
};

/* script */
const __vue_script__$K = script$K;
/* template */

/* style */

const __vue_inject_styles__$K = undefined;
/* scoped */

const __vue_scope_id__$K = undefined;
/* module identifier */

const __vue_module_identifier__$K = undefined;
/* functional template */

const __vue_is_functional_template__$K = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$K = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$K, __vue_script__$K, __vue_scope_id__$K, __vue_is_functional_template__$K, __vue_module_identifier__$K, false, undefined, undefined, undefined);

var script$J = {
  name: 'VlGeomMultiPoint',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: { ...simpleGeometry.props.coordinates,
      validator: isMultiPointCoords
    }
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.MULTI_POINT)
  },
  methods: {
    /**
     * @returns {MultiPoint}
     * @protected
     */
    createGeometry() {
      return new MultiPoint(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates(coordinates) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isMultiPointCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }

  }
};

/* script */
const __vue_script__$J = script$J;
/* template */

/* style */

const __vue_inject_styles__$J = undefined;
/* scoped */

const __vue_scope_id__$J = undefined;
/* module identifier */

const __vue_module_identifier__$J = undefined;
/* functional template */

const __vue_is_functional_template__$J = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$J = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$J, __vue_script__$J, __vue_scope_id__$J, __vue_is_functional_template__$J, __vue_module_identifier__$J, false, undefined, undefined, undefined);

var script$I = {
  name: 'VlGeomMultiPolygon',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: { ...simpleGeometry.props.coordinates,
      validator: isMultiPolygonCoords
    }
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.MULTI_POLYGON)
  },
  methods: {
    /**
     * @returns {MultiPolygon}
     * @protected
     */
    createGeometry() {
      return new MultiPolygon(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates(coordinates) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isMultiPolygonCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }

  }
};

/* script */
const __vue_script__$I = script$I;
/* template */

/* style */

const __vue_inject_styles__$I = undefined;
/* scoped */

const __vue_scope_id__$I = undefined;
/* module identifier */

const __vue_module_identifier__$I = undefined;
/* functional template */

const __vue_is_functional_template__$I = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$I = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$I, __vue_script__$I, __vue_scope_id__$I, __vue_is_functional_template__$I, __vue_module_identifier__$I, false, undefined, undefined, undefined);

var script$H = {
  name: 'VlGeomPolygon',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: { ...simpleGeometry.props.coordinates,
      validator: isPolygonCoords
    }
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.POLYGON)
  },
  methods: {
    /**
     * @returns {Polygon}
     * @protected
     */
    createGeometry() {
      return new Polygon(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates(coordinates) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isPolygonCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }

  }
};

/* script */
const __vue_script__$H = script$H;
/* template */

/* style */

const __vue_inject_styles__$H = undefined;
/* scoped */

const __vue_scope_id__$H = undefined;
/* module identifier */

const __vue_module_identifier__$H = undefined;
/* functional template */

const __vue_is_functional_template__$H = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$H = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H, __vue_module_identifier__$H, false, undefined, undefined, undefined);

function plugin$x(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$x.installed) {
    return;
  }

  plugin$x.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$M, options);
  Object.assign(__vue_component__$O, options);
  Object.assign(__vue_component__$N, options);
  Object.assign(__vue_component__$L, options);
  Object.assign(__vue_component__$H, options);
  Object.assign(__vue_component__$J, options);
  Object.assign(__vue_component__$K, options);
  Object.assign(__vue_component__$I, options);
  Vue.component(__vue_component__$M.name, __vue_component__$M);
  Vue.component(__vue_component__$O.name, __vue_component__$O);
  Vue.component(__vue_component__$N.name, __vue_component__$N);
  Vue.component(__vue_component__$L.name, __vue_component__$L);
  Vue.component(__vue_component__$H.name, __vue_component__$H);
  Vue.component(__vue_component__$J.name, __vue_component__$J);
  Vue.component(__vue_component__$K.name, __vue_component__$K);
  Vue.component(__vue_component__$I.name, __vue_component__$I);
}

var Feature = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$x,
  install: plugin$x,
  Feature: __vue_component__$M,
  CircleGeom: __vue_component__$O,
  PointGeom: __vue_component__$N,
  LineStringGeom: __vue_component__$L,
  PolygonGeom: __vue_component__$H,
  MultiPointGeom: __vue_component__$J,
  MultiLineStringGeom: __vue_component__$K,
  MultiPolygonGeom: __vue_component__$I
});

//
const validateProjection = /*#__PURE__*/and(isString, value => get(value) != null);
var script$G = {
  name: 'VlGeoloc',
  mixins: [projTransforms, olCmp, waitForMap],
  stubVNode: {
    empty() {
      return this.vmId;
    }

  },
  props: {
    tracking: {
      type: Boolean,
      default: true
    },
    trackingOptions: Object,
    projection: {
      type: String,
      validator: validateProjection
    }
  },

  data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentTracking: this.tracking,
      currentTrackingOptions: this.trackingOptions && clonePlainObject(this.trackingOptions),
      currentProjection: this.projection
    };
  },

  computed: {
    resolvedDataProjection() {
      var _this$$options;

      return coalesce(this.currentProjection, (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, this.dataProjection, this.resolvedViewProjection);
    },

    accuracy() {
      return this.rev ? this.getAccuracy() : undefined;
    },

    accuracyGeometryDataProj() {
      return this.rev ? this.writeGeometryInDataProj(this.getAccuracyGeometry()) : undefined;
    },

    accuracyGeometryViewProj() {
      return this.rev ? this.writeGeometryInViewProj(this.getAccuracyGeometry()) : undefined;
    },

    altitude() {
      return this.rev ? this.getAltitude() : undefined;
    },

    altitudeAccuracy() {
      return this.rev ? this.getAltitudeAccuracy() : undefined;
    },

    heading() {
      return this.rev ? this.getHeading() : undefined;
    },

    speed() {
      return this.rev ? this.getSpeed() : undefined;
    },

    positionDataProj() {
      return this.rev ? this.getPosition() : undefined;
    },

    positionViewProj() {
      return this.rev ? this.pointToViewProj(this.getPosition()) : undefined;
    }

  },
  watch: {
    rev() {
      if (!this.$geolocation) return;

      if (this.currentTracking !== this.$geolocation.getTracking()) {
        this.currentTracking = this.$geolocation.getTracking();
      }

      if (!isEqual(this.currentTrackingOptions, this.$geolocation.getTrackingOptions())) {
        this.currentTrackingOptions = this.$geolocation.getTrackingOptions();
      }

      if (this.currentProjection !== this.$geolocation.getProjection().getCode()) {
        this.currentProjection = this.$geolocation.getProjection().getCode();
      }
    },

    tracking(value) {
      this.setTracking(value);
    },

    currentTracking(value) {
      if (value === this.tracking) return;
      this.$emit('update:tracking', value);
    },

    tracingOptions: {
      deep: true,

      handler(value) {
        this.setTrackingOptions(value);
      }

    },
    currentTrackingOptions: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.trackingOptions)) return;
        this.$emit('update:tracingOptions', value && clonePlainObject(value));
      }

    },

    projection(value) {
      this.setProjection(value);
    },

    currentProjection(value) {
      if (value === this.projection) return;
      this.$emit('update:projection', value);
    },

    accuracy(value, prev) {
      if (value === prev) return;
      this.$emit('update:accuracy', value);
    },

    accuracyGeometryDataProj(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:accuracyGeometry', value);
    },

    currentAltitude(value, prev) {
      if (value === prev) return;
      this.$emit('update:altitude', value);
    },

    altitudeAccuracy(value, prev) {
      if (value === prev) return;
      this.$emit('update:altitudeAccuracy', value);
    },

    heading(value, prev) {
      if (value === prev) return;
      this.$emit('update:heading', value);
    },

    speed(value, prev) {
      if (value === prev) return;
      this.$emit('update:speed', value);
    },

    positionDataProj(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:position', value);
    }

  },

  created() {
    defineServices$8.call(this);
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {module:ol/Geolocation~Geolocation}
     * @private
     */
    createOlObject() {
      const geoloc = new Geolocation({
        tracking: this.currentTracking,
        trackingOptions: this.currentTrackingOptions,
        projection: this.resolvedDataProjection
      });
      geoloc.set('id', this.currentId);
      return geoloc;
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount() {
      this.setTracking(this.tracking);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount() {
      this.setTracking(false);
      return olCmp.methods.unmount.call(this);
    },

    /**
     * @protected
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToGeolocation.call(this);
    },

    resolveGeolocation: olCmp.methods.resolveOlObject,

    /**
     * @return {number|string}
     */
    getIdInternal() {
      return this.$geolocation.get('id');
    },

    /**
     * @param {string|number} id
     * @return {void}
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      this.$geolocation.set('id', id);
    },

    /**
     * @return {number|undefined}
     */
    getAccuracy() {
      var _this$$geolocation;

      return (_this$$geolocation = this.$geolocation) === null || _this$$geolocation === void 0 ? void 0 : _this$$geolocation.getAccuracy();
    },

    /**
     * @return {module:/ol/geom/Geometry~Geometry|undefined}
     */
    getAccuracyGeometry() {
      var _this$$geolocation2;

      return (_this$$geolocation2 = this.$geolocation) === null || _this$$geolocation2 === void 0 ? void 0 : _this$$geolocation2.getAccuracyGeometry();
    },

    /**
     * @return {number|undefined}
     */
    getAltitude() {
      var _this$$geolocation3;

      return (_this$$geolocation3 = this.$geolocation) === null || _this$$geolocation3 === void 0 ? void 0 : _this$$geolocation3.getAltitude();
    },

    /**
     * @return {number|undefined}
     */
    getAltitudeAccuracy() {
      var _this$$geolocation4;

      return (_this$$geolocation4 = this.$geolocation) === null || _this$$geolocation4 === void 0 ? void 0 : _this$$geolocation4.getAltitudeAccuracy();
    },

    /**
     * @return {number|undefined}
     */
    getHeading() {
      var _this$$geolocation5;

      return (_this$$geolocation5 = this.$geolocation) === null || _this$$geolocation5 === void 0 ? void 0 : _this$$geolocation5.getHeading();
    },

    /**
     * @return {number[]|undefined}
     */
    getPosition() {
      var _this$$geolocation6;

      return (_this$$geolocation6 = this.$geolocation) === null || _this$$geolocation6 === void 0 ? void 0 : _this$$geolocation6.getPosition();
    },

    /**
     * @return {module:ol/proj~ProjectionLike|undefined}
     */
    getProjection() {
      var _this$$geolocation7;

      return coalesce((_this$$geolocation7 = this.$geolocation) === null || _this$$geolocation7 === void 0 ? void 0 : _this$$geolocation7.getProjection(), this.currentProjection);
    },

    /**
     * @param {module:ol/proj~ProjectionLike} projection
     */
    setProjection(projection) {
      assert(validateProjection(projection), 'Invalid projection');
      projection = get(projection);

      if (projection.getCode() !== this.currentProjection) {
        this.currentProjection = projection.getCode();
      }

      if (this.$geolocation && projection !== this.$geolocation.getProjection()) {
        this.$geolocation.setProjection(projection);
      }
    },

    /**
     * @return {number|undefined}
     */
    getSpeed() {
      var _this$$geolocation8;

      return (_this$$geolocation8 = this.$geolocation) === null || _this$$geolocation8 === void 0 ? void 0 : _this$$geolocation8.getSpeed();
    },

    /**
     * @return {boolean}
     */
    getTracking() {
      var _this$$geolocation9;

      return coalesce((_this$$geolocation9 = this.$geolocation) === null || _this$$geolocation9 === void 0 ? void 0 : _this$$geolocation9.getTracking(), this.currentTracking);
    },

    /**
     * @param {boolean} tracking
     */
    setTracking(tracking) {
      if (tracking !== this.currentTracking) {
        this.currentTracking = tracking;
      }

      if (this.$geolocation && tracking !== this.$geolocation.getTracking()) {
        this.$geolocation.setTracking(tracking);
      }
    },

    /**
     * @return {Object|undefined}
     */
    getTrackingOptions() {
      var _this$$geolocation10;

      return coalesce((_this$$geolocation10 = this.$geolocation) === null || _this$$geolocation10 === void 0 ? void 0 : _this$$geolocation10.getTrackingOptions(), this.currentTrackingOptions);
    },

    /**
     * @param {Promise<Object|undefined>} options
     */
    setTrackingOptions(options) {
      if (!isEqual(options, this.currentTrackingOptions)) {
        this.currentTrackingOptions = options;
      }

      if (this.$geolocation && !isEqual(options, this.$geolocation.getTrackingOptions())) {
        this.$geolocation.setTrackingOptions(options);
      }
    }

  }
};

function defineServices$8() {
  Object.defineProperties(this, {
    $geolocation: {
      enumerable: true,
      get: () => this.$olObject
    },
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.mapVm;
      }
    },
    $viewVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.viewVm;
      }
    }
  });
}
/**
 * @return {void}
 * @private
 */


function subscribeToGeolocation() {
  const setterKey = addPrefix('set');
  const setPropsChanges = merge(fromOlChangeEvent(this.$geolocation, 'projection', true, evt => ({ ...evt,
    value: get(evt.value).getCode()
  })), fromOlChangeEvent(this.$geolocation, ['tracking', 'trackingOptions'], true)).pipe(map(evt => ({ ...evt,
    setter: val => {
      this[setterKey(evt.prop)](val);
      this.scheduleRefresh();
    }
  })));
  this.subscribeTo(setPropsChanges, _ref => {
    let {
      setter,
      value
    } = _ref;
    return setter(value);
  });
  const otherChanged = fromOlChangeEvent(this.$geolocation, ['accuracy', 'accuracyGeometry', 'altitude', 'altitudeAccuracy', 'heading', 'speed', 'position'], true);
  this.subscribeTo(otherChanged, this.scheduleRefresh.bind(this));
}

/* script */
const __vue_script__$G = script$G;
/* template */

var __vue_render__$8 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", null, {
    "accuracy": _vm.accuracy,
    "accuracyGeometry": _vm.accuracyGeometryDataProj,
    "altitude": _vm.altitude,
    "altitudeAccuracy": _vm.altitudeAccuracy,
    "heading": _vm.heading,
    "position": _vm.positionDataProj,
    "speed": _vm.speed
  })], 2);
};

var __vue_staticRenderFns__$8 = [];
/* style */

const __vue_inject_styles__$G = undefined;
/* scoped */

const __vue_scope_id__$G = undefined;
/* module identifier */

const __vue_module_identifier__$G = undefined;
/* functional template */

const __vue_is_functional_template__$G = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$G = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$8,
  staticRenderFns: __vue_staticRenderFns__$8
}, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G, __vue_module_identifier__$G, false, undefined, undefined, undefined);

function plugin$w(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$w.installed) {
    return;
  }

  plugin$w.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$G, options);
  Vue.component(__vue_component__$G.name, __vue_component__$G);
}

var Geoloc = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$w,
  install: plugin$w,
  Geoloc: __vue_component__$G
});

var script$F = {
  name: 'VlStyleFill',
  mixins: [style],
  props: {
    color: {
      type: [String, Array],
      default: () => [255, 255, 255, 0.4]
    }
  },

  data() {
    return {
      currentColor: normalizeColor(this.color)
    };
  },

  computed: {
    inputColor() {
      return normalizeColor(this.color);
    }

  },
  watch: {
    rev() {
      if (!this.$style) return;
      this.setColor(this.getColor());
    },

    inputColor: {
      deep: true,

      handler(value) {
        this.setColor(value);
      }

    },
    currentColor: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.inputColor)) return;
        this.$emit('update:color', value === null || value === void 0 ? void 0 : value.slice());
      }

    }
  },

  created() {
    defineServices$7.call(this);
  },

  methods: {
    /**
     * @return {FillStyle}
     * @protected
     */
    createStyle() {
      return new Fill({
        color: this.currentColor
      });
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$fillStyleConta;

      (_this$$fillStyleConta = this.$fillStyleContainer) === null || _this$$fillStyleConta === void 0 ? void 0 : _this$$fillStyleConta.setFill(this);
      return style.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$fillStyleConta2;

      if (((_this$$fillStyleConta2 = this.$fillStyleContainer) === null || _this$$fillStyleConta2 === void 0 ? void 0 : _this$$fillStyleConta2.getFillVm()) === this) {
        this.$fillStyleContainer.setFill(null);
      }

      return style.methods.unmount.call(this);
    },

    /**
     * @return {Promise<void>}
     */
    async refresh() {
      var _this$$fillStyleConta3;

      await Promise.all([style.methods.refresh.call(this), (_this$$fillStyleConta3 = this.$fillStyleContainer) === null || _this$$fillStyleConta3 === void 0 ? void 0 : _this$$fillStyleConta3.refresh()]);
    },

    /**
     * @protected
     */
    syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setColor(this.getColor());
    },

    getColor() {
      var _this$$style;

      return normalizeColor(coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getColor(), this.currentColor));
    },

    setColor(color) {
      color = normalizeColor(color);

      if (!isEqual(color, this.currentColor)) {
        this.currentColor = color;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(color, this.$style.getColor())) {
        this.$style.setColor(color);
        this.scheduleRefresh();
      }
    }

  }
};

function defineServices$7() {
  Object.defineProperties(this, {
    $fillStyleContainer: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.fillStyleContainer;
      }
    }
  });
}

/* script */
const __vue_script__$F = script$F;
/* template */

/* style */

const __vue_inject_styles__$F = undefined;
/* scoped */

const __vue_scope_id__$F = undefined;
/* module identifier */

const __vue_module_identifier__$F = undefined;
/* functional template */

const __vue_is_functional_template__$F = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$F = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F, __vue_module_identifier__$F, false, undefined, undefined, undefined);

var script$E = {
  name: 'VlStyleStroke',
  mixins: [style],
  props: {
    color: {
      type: [Array, String],
      default: '#3399cc'
    },
    lineCap: {
      type: String,
      default: 'round' // round, butt, square

    },
    lineJoin: {
      type: String,
      default: 'round' // round, bevel, miter

    },
    lineDash: Array,
    lineDashOffset: {
      type: Number,
      default: 0
    },
    miterLimit: {
      type: Number,
      default: 10
    },
    width: {
      type: Number,
      default: 1.25
    }
  },

  data() {
    var _this$lineDash;

    return {
      currentColor: normalizeColor(this.color),
      currentLineCap: this.lineCap,
      currentLineJoin: this.lineJoin,
      currentLineDash: (_this$lineDash = this.lineDash) === null || _this$lineDash === void 0 ? void 0 : _this$lineDash.slice(),
      currentLineDashOffset: this.lineDashOffset,
      currentMiterLimit: this.miterLimit,
      currentWidth: this.width
    };
  },

  computed: {
    inputColor() {
      return normalizeColor(this.color);
    },

    inputLineDash() {
      var _this$lineDash2;

      return (_this$lineDash2 = this.lineDash) === null || _this$lineDash2 === void 0 ? void 0 : _this$lineDash2.slice();
    }

  },
  watch: {
    rev() {
      if (!this.$style) return;
      this.setColor(this.getColor());
      this.setLineCap(this.getLineCap());
      this.setLineJoin(this.getLineJoin());
      this.setLineDash(this.getLineDash());
      this.setLineDashOffset(this.getLineDashOffset());
      this.setMiterLimit(this.getMiterLimit());
      this.setWidth(this.getWidth());
    },

    ... /*#__PURE__*/makeWatchers(['inputColor', 'lineCap', 'lineJoin', 'inputLineDash', 'lineDashOffset', 'miterLimit', 'width'], inProp => {
      const prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      const setter = 'set' + upperFirst(prop);
      return {
        deep: ['inputColor', 'inputLineDash'].includes(inProp),

        handler(value) {
          this[setter](value);
        }

      };
    }),
    ... /*#__PURE__*/makeWatchers(['currentColor', 'currentLineCap', 'currentLineJoin', 'currentLineDash', 'currentLineDashOffset', 'currentMiterLimit', 'currentWidth'], curProp => {
      const prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
      const inProp = 'input' + upperFirst(prop);
      return {
        deep: ['currentColor', 'currentLineDash'].includes(curProp),

        handler(value) {
          if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
          this.$emit(`update:${prop}`, isObjectLike(value) ? clonePlainObject(value) : value);
        }

      };
    }),
    inputColor: {
      deep: true,

      handler(value) {
        this.setColor(value);
      }

    },
    currentColor: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.inputColor)) return;
        this.$emit('update:color', value === null || value === void 0 ? void 0 : value.slice());
      }

    },

    lineCap(value) {
      this.setLineCap(value);
    },

    currentLineCap(value) {
      if (value === this.lineCap) return;
      this.$emit('update:lineCap', value);
    },

    lineJoin(value) {
      this.setLineJoin(value);
    },

    currentLineJoin(value) {
      if (value === this.lineJoin) return;
      this.$emit('update:lineJoin', value);
    },

    inputLineDash: {
      deep: true,

      handler(value) {
        this.setLineDash(value);
      }

    },
    currentLineDash: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.currentLineDash)) return;
        this.$emit('update:lineDash', value === null || value === void 0 ? void 0 : value.slice());
      }

    },

    lineDashOffset(value) {
      this.setLineDashOffset(value);
    },

    currentLineDashOffset(value) {
      if (value === this.lineDashOffset) return;
      this.$emit('update:lineDashOffset', value);
    },

    miterLimit(value) {
      this.setMiterLimit(value);
    },

    currentMiterLimit(value) {
      if (value === this.miterLimit) return;
      this.$emit('update:miterLimit', value);
    },

    width(value) {
      this.setWidth(value);
    },

    currentWidth(value) {
      if (value === this.width) return;
      this.$emit('update:width', value);
    }

  },

  created() {
    defineServices$6.call(this);
  },

  methods: {
    /**
     * @return {StrokeStyle}
     * @protected
     */
    createStyle() {
      return new Stroke({
        color: this.currentColor,
        lineCap: this.currentLineCap,
        lineJoin: this.currentLineJoin,
        lineDash: this.currentLineDash,
        lineDashOffset: this.currentLineDashOffset,
        miterLimit: this.currentMiterLimit,
        width: this.currentWidth
      });
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$strokeStyleCon;

      (_this$$strokeStyleCon = this.$strokeStyleContainer) === null || _this$$strokeStyleCon === void 0 ? void 0 : _this$$strokeStyleCon.setStroke(this);
      return style.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$strokeStyleCon2;

      if (((_this$$strokeStyleCon2 = this.$strokeStyleContainer) === null || _this$$strokeStyleCon2 === void 0 ? void 0 : _this$$strokeStyleCon2.getStrokeVm()) === this) {
        this.$strokeStyleContainer.setStroke(null);
      }

      return style.methods.unmount.call(this);
    },

    /**
     * @return {Promise}
     */
    async refresh() {
      var _this$$strokeStyleCon3;

      await Promise.all([style.methods.refresh.call(this), (_this$$strokeStyleCon3 = this.$strokeStyleContainer) === null || _this$$strokeStyleCon3 === void 0 ? void 0 : _this$$strokeStyleCon3.refresh()]);
    },

    /**
     * @protected
     */
    syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setColor(this.getColor());
      this.setLineCap(this.getLineCap());
      this.setLineJoin(this.getLineJoin());
      this.setLineDash(this.getLineDash());
      this.setLineDashOffset(this.getLineDashOffset());
      this.setMiterLimit(this.getMiterLimit());
      this.setWidth(this.getWidth());
    },

    getColor() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getColor(), this.currentColor);
    },

    setColor(color) {
      color = normalizeColor(color);

      if (!isEqual(color, this.currentColor)) {
        this.currentColor = color;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(color, this.$style.getColor())) {
        this.$style.setColor(color);
        this.scheduleRefresh();
      }
    },

    getLineCap() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getLineCap(), this.currentLineCap);
    },

    setLineCap(lineCap) {
      if (lineCap !== this.currentLineCap) {
        this.currentLineCap = lineCap;
        this.scheduleRefresh();
      }

      if (this.$style && lineCap !== this.$style.getLineCap()) {
        this.$style.setLineCap(lineCap);
        this.scheduleRefresh();
      }
    },

    getLineJoin() {
      var _this$$style3;

      return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getLineJoin(), this.currentLineJoin);
    },

    setLineJoin(lineJoin) {
      if (lineJoin !== this.currentLineJoin) {
        this.currentLineJoin = lineJoin;
      }

      if (this.$style && lineJoin !== this.$style.getLineJoin()) {
        this.$style.setLineJoin(lineJoin);
        this.scheduleRefresh();
      }
    },

    getLineDash() {
      var _this$$style4;

      return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getLineDash(), this.currentLineDash);
    },

    setLineDash(lineDash) {
      var _lineDash;

      lineDash = (_lineDash = lineDash) === null || _lineDash === void 0 ? void 0 : _lineDash.slice();

      if (!isEqual(lineDash, this.currentLineDash)) {
        this.currentLineDash = lineDash;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(lineDash, this.$style.getLineDash())) {
        this.$style.setLineDash(lineDash);
        this.scheduleRefresh();
      }
    },

    getLineDashOffset() {
      var _this$$style5;

      return coalesce((_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getLineDashOffset(), this.currentLineDashOffset);
    },

    setLineDashOffset(lineDashOffset) {
      if (lineDashOffset !== this.currentLineDashOffset) {
        this.currentLineDashOffset = lineDashOffset;
        this.scheduleRefresh();
      }

      if (this.$style && lineDashOffset !== this.$style.getLineDashOffset()) {
        this.$style.setLineDashOffset(lineDashOffset);
        this.scheduleRefresh();
      }
    },

    getMiterLimit() {
      var _this$$style6;

      return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getMiterLimit(), this.currentMiterLimit);
    },

    setMiterLimit(miterLimit) {
      if (miterLimit !== this.currentMiterLimit) {
        this.currentMiterLimit = miterLimit;
        this.scheduleRefresh();
      }

      if (this.$style && miterLimit !== this.$style.getMiterLimit()) {
        this.$style.setMiterLimit(miterLimit);
        this.scheduleRefresh();
      }
    },

    getWidth() {
      var _this$$style7;

      return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getWidth(), this.currentWidth);
    },

    setWidth(width) {
      if (width !== this.currentWidth) {
        this.currentWidth = width;
        this.scheduleRefresh();
      }

      if (this.$style && width !== this.$style.getWidth()) {
        this.$style.setWidth(width);
        this.scheduleRefresh();
      }
    }

  }
};

function defineServices$6() {
  Object.defineProperties(this, {
    $strokeStyleContainer: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.strokeStyleContainer;
      }
    }
  });
}

/* script */
const __vue_script__$E = script$E;
/* template */

/* style */

const __vue_inject_styles__$E = undefined;
/* scoped */

const __vue_scope_id__$E = undefined;
/* module identifier */

const __vue_module_identifier__$E = undefined;
/* functional template */

const __vue_is_functional_template__$E = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$E = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E, __vue_module_identifier__$E, false, undefined, undefined, undefined);

//
var script$D = {
  name: 'VlStyleCircle',
  components: {
    FillStyle: __vue_component__$F,
    StrokeStyle: __vue_component__$E
  },
  mixins: [regShapeStyle],
  props: {
    /* eslint-disable vue/require-prop-types */
    radius: { ...regShapeStyle.props.radius,
      default: 5
    }
    /* eslint-enable vue/require-prop-types */

  },

  data() {
    return {
      currentRadius: this.radius
    };
  },

  watch: {
    rev() {
      if (!this.$style) return;
      this.setRadius(this.getRadius());
    },

    currentRadius(value) {
      if (value === this.radius) return;
      this.$emit('update:radius', value);
    }

  },
  methods: {
    /**
     * @return {CircleStyle}
     * @protected
     */
    createStyle() {
      return new Circle$1({
        // ol/style/Image
        displacement: this.inputDisplacement,
        // ol/style/RegularShape
        radius: this.currentRadius,
        fill: this.$fill,
        stroke: this.$stroke
      });
    },

    /**
     * @protected
     */
    syncNonObservable() {
      regShapeStyle.methods.syncNonObservable.call(this);
      this.setRadius(this.getRadius());
    },

    getRadius() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getRadius(), this.currentRadius);
    },

    setRadius(radius) {
      if (radius !== this.currentRadius) {
        this.currentRadius = radius;
        this.scheduleRefresh();
      }

      if (this.$style && radius !== this.$style.getRadius()) {
        this.$style.setRadius(radius);
        this.scheduleRefresh();
      }
    },

    /**
     * @param {number} value
     * @protected
     */
    radiusChanged(value) {
      this.setRadius(value);
    },

    pointsChanged: noop,
    radius1Changed: noop,
    radius2Changed: noop,
    angleChanged: noop
  }
};

/* script */
const __vue_script__$D = script$D;
/* template */

var __vue_render__$7 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", function () {
    return [_c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style'
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style'
      }
    })];
  })], 2);
};

var __vue_staticRenderFns__$7 = [];
/* style */

const __vue_inject_styles__$D = undefined;
/* scoped */

const __vue_scope_id__$D = undefined;
/* module identifier */

const __vue_module_identifier__$D = undefined;
/* functional template */

const __vue_is_functional_template__$D = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$D = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$7,
  staticRenderFns: __vue_staticRenderFns__$7
}, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D, __vue_module_identifier__$D, false, undefined, undefined, undefined);

var script$C = {
  name: 'VlStyleIcon',
  mixins: [imageStyle],
  props: {
    src: String,
    size: {
      type: Array,
      validator: val => val.length === 2
    },
    img: Image,
    imgSize: {
      type: Array,
      validator: val => val.length === 2
    },
    anchor: {
      type: Array,
      default: () => [0.5, 0.5],
      validator: val => val.length === 2
    },
    anchorOrigin: {
      type: String,
      default: IconOrigin.TOP_LEFT // bottom-left, bottom-right, top-left or top-right

    },
    anchorXUnits: {
      type: String,
      default: IconAnchorUnits.FRACTION // pixels, fraction

    },
    anchorYUnits: {
      type: String,
      default: IconAnchorUnits.FRACTION // pixels, fraction

    },
    color: [Array, String],
    crossOrigin: String,
    offset: {
      type: Array,
      default: () => [0, 0],
      validator: val => val.length === 2
    },
    offsetOrigin: {
      type: String,
      default: IconOrigin.TOP_LEFT // bottom-left, bottom-right, top-left or top-right

    }
  },

  data() {
    var _this$anchor;

    return {
      currentAnchor: (_this$anchor = this.anchor) === null || _this$anchor === void 0 ? void 0 : _this$anchor.slice()
    };
  },

  computed: {
    inputSize() {
      var _this$size;

      return (_this$size = this.size) === null || _this$size === void 0 ? void 0 : _this$size.slice();
    },

    inputImgSize() {
      var _this$imgSize;

      return (_this$imgSize = this.imgSize) === null || _this$imgSize === void 0 ? void 0 : _this$imgSize.slice();
    },

    inputAnchor() {
      var _this$anchor2;

      return (_this$anchor2 = this.anchor) === null || _this$anchor2 === void 0 ? void 0 : _this$anchor2.slice();
    },

    inputColor() {
      return this.color ? normalizeColor(this.color) : undefined;
    },

    inputOffset() {
      var _this$offset;

      return (_this$offset = this.offset) === null || _this$offset === void 0 ? void 0 : _this$offset.slice();
    }

  },
  watch: {
    rev() {
      if (!this.$style) return;
      this.setAnchor(this.getAnchor());
    },

    inputAnchor: {
      deep: true,

      handler(value) {
        this.setAnchor(value);
      }

    },
    currentAnchor: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.inputAnchor)) return;
        this.$emit('update:anchor', value === null || value === void 0 ? void 0 : value.slice());
      }

    },
    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['src', 'inputSize', 'img', 'inputImgSize', 'anchorOrigin', 'anchorXUnits', 'anchorYUnits', 'anchorYUnits', 'inputColor', 'crossOrigin', 'inputOffset', 'offsetOrigin'], ['inputSize', 'inputImgSize', 'inputColor', 'inputOffset'])
  },
  methods: {
    /**
     * @return {Icon}
     * @protected
     */
    createStyle() {
      assert(this.src && !this.img || !this.src && this.img, "vl-style-icon one of 'image' or 'src' prop must be provided.'");
      assert(!this.img || this.img && !isEmpty(this.imgSize), "vl-style-icon 'imgSize' must be set when image is provided.");
      return new Icon({
        // ol/style/Image
        opacity: this.currentOpacity,
        scale: this.currentScale,
        rotateWithView: this.currentRotateWithView,
        rotation: this.currentRotation,
        displacement: this.inputDisplacement,
        // ol/style/Icon
        anchor: this.currentAnchor,
        anchorOrigin: this.anchorOrigin,
        anchorXUnits: this.anchorXUnits,
        anchorYUnits: this.anchorYUnits,
        color: this.inputColor,
        crossOrigin: this.crossOrigin,
        offset: this.inputOffset,
        offsetOrigin: this.offsetOrigin,
        size: this.inputSize,
        src: this.src,
        img: this.img,
        imgSize: this.inputImgSize
      });
    },

    /**
     * @protected
     */
    syncNonObservable() {
      imageStyle.methods.syncNonObservable.call(this);
      this.setAnchor(this.getAnchor());
    },

    getAnchor() {
      var _this$$style, _this$$style$getAncho;

      const anchor = (_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : (_this$$style$getAncho = _this$$style.getAnchor()) === null || _this$$style$getAncho === void 0 ? void 0 : _this$$style$getAncho.slice();
      if (!anchor) return this.currentAnchor;
      return this.transformAnchor(anchor);
    },

    /**
     * @param {number[]} anchor
     * @returns {number[]}
     * @protected
     */
    transformAnchor(anchor) {
      const size = this.getSize();
      if (!size) return;

      if (this.anchorXUnits === IconAnchorUnits.FRACTION) {
        anchor[0] /= size[0];
      }

      if (this.anchorYUnits === IconAnchorUnits.FRACTION) {
        anchor[1] /= size[1];
      }

      if ([IconOrigin.TOP_RIGHT, IconOrigin.BOTTOM_RIGHT].includes(this.anchorOrigin)) {
        anchor[0] = 1 - anchor[0];
      }

      if ([IconOrigin.BOTTOM_LEFT, IconOrigin.BOTTOM_RIGHT].includes(this.anchorOrigin)) {
        anchor[1] = 1 - anchor[1];
      }

      anchor[0] = round(anchor[0], 3);
      anchor[1] = round(anchor[1], 3);
      return anchor;
    },

    setAnchor(anchor) {
      var _anchor;

      anchor = (_anchor = anchor) === null || _anchor === void 0 ? void 0 : _anchor.slice();

      if (!isEqual(anchor, this.currentAnchor)) {
        this.currentAnchor = anchor;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(anchor, this.transformAnchor(this.$style.getAnchor()))) {
        this.$style.setAnchor(anchor);
        this.scheduleRefresh();
      }
    },

    getColor() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getColor(), this.inputColor);
    },

    getImage(pixelRatio) {
      var _this$$style3;

      return (_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getImage(pixelRatio);
    },

    getPixelRatio(pixelRatio) {
      var _this$$style4;

      return (_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getPixelRatio(pixelRatio);
    },

    getOrigin() {
      var _this$$style5;

      return (_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getOrigin();
    },

    getSize() {
      var _this$$style6;

      return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getSize(), this.inputSize);
    },

    getSrc() {
      var _this$$style7;

      return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getSrc(), this.src);
    },

    async load() {
      (await this.resolveStyle()).load();
    }

  }
};

/* script */
const __vue_script__$C = script$C;
/* template */

/* style */

const __vue_inject_styles__$C = undefined;
/* scoped */

const __vue_scope_id__$C = undefined;
/* module identifier */

const __vue_module_identifier__$C = undefined;
/* functional template */

const __vue_is_functional_template__$C = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$C = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C, __vue_module_identifier__$C, false, undefined, undefined, undefined);

var script$B = {
  name: 'VlStyleRegShape',
  mixins: [regShapeStyle],
  methods: {
    /**
     * @return {RegularShapeStyle}
     * @protected
     */
    createStyle() {
      return new RegularShape({
        // ol/style/Image
        rotation: this.currentRotation,
        rotateWithView: this.currentRotateWithView,
        displacement: this.inputDisplacement,
        // ol/style/RegularShape
        points: this.points,
        radius: this.radius,
        radius1: this.radius1,
        radius2: this.radius2,
        angle: this.angle,
        fill: this.$fill,
        stroke: this.$stroke
      });
    }

  }
};

/* script */
const __vue_script__$B = script$B;
/* template */

/* style */

const __vue_inject_styles__$B = undefined;
/* scoped */

const __vue_scope_id__$B = undefined;
/* module identifier */

const __vue_module_identifier__$B = undefined;
/* functional template */

const __vue_is_functional_template__$B = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$B = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B, __vue_module_identifier__$B, false, undefined, undefined, undefined);

//
/**
 * Style box component.
 * Wrapper for Style class. Can be inserted into component with setStyle/getStyle methods (vl-layer-vector, vl-feature & etc.)
 * and acts as a box for inner style components (vl-style-fill, vl-style-stroke, icon ...)
 */

var script$A = {
  name: 'VlStyle',
  components: {
    CircleStyle: __vue_component__$D,
    FillStyle: __vue_component__$F,
    StrokeStyle: __vue_component__$E
  },
  mixins: [projTransforms, fillStyleContainer, strokeStyleContainer, textStyleContainer, imageStyleContainer, geometryContainer, style, waitForMap],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    /**
     * @type {number}
     */
    zIndex: {
      type: Number,
      default: 0
    },

    /**
     * @type {function}
     */
    renderer: Function,

    /**
     * @deprecated Use v-if directive.
     * @todo remove in v0.13.x
     */
    condition: [Boolean, Function]
  },

  data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentZIndex: this.zIndex,
      currentRenderer: this.renderer
    };
  },

  computed: {
    stroke() {
      if (!(this.rev && this.$stroke)) return;
      return dumpStrokeStyle(this.$stroke);
    },

    fill() {
      if (!(this.rev && this.$fill)) return;
      return dumpFillStyle(this.$fill);
    },

    text() {
      if (!(this.rev && this.$text)) return;
      return dumpTextStyle(this.$text);
    },

    image() {
      if (!(this.rev && this.$image)) return;
      return dumpImageStyle(this.$image);
    },

    geometryDataProj() {
      if (!(this.rev && this.$geometry)) return;
      return this.writeGeometryInDataProj(this.$geometry);
    },

    geometryViewProj() {
      if (!(this.rev && this.$geometry)) return;
      return this.writeGeometryInViewProj(this.$geometry);
    }

  },
  watch: {
    rev() {
      if (!this.$style) return;
      this.setZIndex(this.getZIndex());
      this.setRenderer(this.getRenderer());
    },

    ... /*#__PURE__*/makeWatchers(['zIndex', 'renderer'], inProp => {
      const prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      const setter = 'set' + upperFirst(prop);
      return function (value) {
        this[setter](value);
      };
    }),
    ... /*#__PURE__*/makeWatchers(['currentZIndex', 'currentRenderer'], curProp => {
      const prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
      const inProp = 'input' + upperFirst(prop);
      return function (value) {
        if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
        this.$emit(`update:${prop}`, isObjectLike(value) ? clonePlainObject(value) : value);
      };
    }),
    ... /*#__PURE__*/makeWatchers(['fill', 'stroke', 'text', 'image', 'geometryDataProj'], prop => {
      prop = prop.replace(/(DataProj|ViewProj)$/i, '');
      return {
        deep: true,

        handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit(`update:${prop}`, isObjectLike(value) ? clonePlainObject(value) : value);
        }

      };
    })
  },

  created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.condition) {
        this.$logger.warn("'condition' is deprecated. Use v-if directive instead.");
      }
    }

    defineServices$5.call(this);
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.condition) {
        this.$logger.warn("'condition' is deprecated. Use v-if directive instead.");
      }
    }
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([style.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {module:ol/style/Style~Style}
     * @protected
     */
    createStyle() {
      return new Style$1({
        zIndex: this.currentZIndex,
        renderer: this.currentRenderer,
        fill: this.$fill,
        stroke: this.$stroke,
        image: this.$image,
        text: this.$text,
        geometry: this.$geometry
      });
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$styleContainer;

      (_this$$styleContainer = this.$styleContainer) === null || _this$$styleContainer === void 0 ? void 0 : _this$$styleContainer.addStyle(this);
      return style.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$styleContainer2;

      (_this$$styleContainer2 = this.$styleContainer) === null || _this$$styleContainer2 === void 0 ? void 0 : _this$$styleContainer2.removeStyle(this);
      return style.methods.unmount.call(this);
    },

    /**
     * @return {Promise}
     */
    async refresh() {
      var _this$$styleContainer3;

      await Promise.all([style.methods.refresh.call(this), (_this$$styleContainer3 = this.$styleContainer) === null || _this$$styleContainer3 === void 0 ? void 0 : _this$$styleContainer3.refresh()]);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(style.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this), imageStyleContainer.methods.getServices.call(this), geometryContainer.methods.getServices.call(this));
    },

    /**
     * @protected
     */
    syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setZIndex(this.getZIndex());
      this.setRenderer(this.getRenderer());
    },

    getFillStyleTarget() {
      return this.$style;
    },

    getStrokeStyleTarget() {
      return this.$style;
    },

    getTextStyleTarget() {
      return this.$style;
    },

    getImageStyleTarget() {
      return this.$style;
    },

    getGeometryTarget() {
      return this.$style;
    },

    getZIndex() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getZIndex(), this.currentZIndex);
    },

    setZIndex(zIndex) {
      if (zIndex !== this.currentZIndex) {
        this.currentZIndex = zIndex;
        this.scheduleRefresh();
      }

      if (this.$style && zIndex !== this.$style.getZIndex()) {
        this.$style.setZIndex(zIndex);
        this.scheduleRefresh();
      }
    },

    getRenderer() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getRenderer(), this.currentRenderer);
    },

    setRenderer(renderer) {
      if (renderer !== this.currentRenderer) {
        this.currentRenderer = renderer;
        this.scheduleRefresh();
      }

      if (this.$style && renderer !== this.$style.getRenderer()) {
        this.$style.setRenderer(renderer);
        this.scheduleRefresh();
      }
    },

    // todo add support for geometry function
    getGeometryFunction() {
      var _this$$style3;

      return (_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getGeometryFunction();
    }

  }
};

function defineServices$5() {
  Object.defineProperties(this, {
    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.mapVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.viewVm;
      }
    }
  });
}

/* script */
const __vue_script__$A = script$A;
/* template */

var __vue_render__$6 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", function () {
    return [_c('CircleStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-circle-style'
      }
    }), _vm._v(" "), _c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style'
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style'
      }
    })];
  })], 2);
};

var __vue_staticRenderFns__$6 = [];
/* style */

const __vue_inject_styles__$A = undefined;
/* scoped */

const __vue_scope_id__$A = undefined;
/* module identifier */

const __vue_module_identifier__$A = undefined;
/* functional template */

const __vue_is_functional_template__$A = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$A = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$6,
  staticRenderFns: __vue_staticRenderFns__$6
}, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A, __vue_module_identifier__$A, false, undefined, undefined, undefined);

var script$z = {
  name: 'VlStyleBackgroundAdapter',
  mixins: [stubVNode, fillStyleContainer, strokeStyleContainer, olCmp],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  computed: {
    stroke() {
      if (!(this.rev && this.$strokeStyle)) return;
      return dumpStrokeStyle(this.$strokeStyle);
    },

    fill() {
      if (!(this.rev && this.$fill)) return;
      return dumpFillStyle(this.$fill);
    }

  },
  watch: { ... /*#__PURE__*/makeWatchers(['fill', 'stroke'], prop => function (value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit(`update:${prop}`, isObjectLike(value) ? clonePlainObject(value) : value);
    })
  },

  created() {
    Object.defineProperties(this, {
      $bgStyleContainer: {
        enumerable: true,
        get: () => {
          var _this$$services;

          return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.bgStyleContainer;
        }
      }
    });
  },

  methods: {
    createOlObject() {
      const obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },

    getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this));
    },

    getFillStyleTarget() {
      return {
        getFill: () => {
          var _this$$bgStyleContain;

          return (_this$$bgStyleContain = this.$bgStyleContainer) === null || _this$$bgStyleContain === void 0 ? void 0 : _this$$bgStyleContain.getBackgroundFill();
        },
        setFill: style => {
          var _this$$bgStyleContain2;

          return (_this$$bgStyleContain2 = this.$bgStyleContainer) === null || _this$$bgStyleContain2 === void 0 ? void 0 : _this$$bgStyleContain2.setBackgroundFill(style);
        }
      };
    },

    getStrokeStyleTarget() {
      return {
        getStroke: () => {
          var _this$$bgStyleContain3;

          return (_this$$bgStyleContain3 = this.$bgStyleContainer) === null || _this$$bgStyleContain3 === void 0 ? void 0 : _this$$bgStyleContain3.getBackgroundStroke();
        },
        setStroke: style => {
          var _this$$bgStyleContain4;

          return (_this$$bgStyleContain4 = this.$bgStyleContainer) === null || _this$$bgStyleContain4 === void 0 ? void 0 : _this$$bgStyleContain4.setBackgroundStroke(style);
        }
      };
    }

  }
};

/* script */
const __vue_script__$z = script$z;
/* template */

/* style */

const __vue_inject_styles__$z = undefined;
/* scoped */

const __vue_scope_id__$z = undefined;
/* module identifier */

const __vue_module_identifier__$z = undefined;
/* functional template */

const __vue_is_functional_template__$z = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$z = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$z, false, undefined, undefined, undefined);

//
var script$y = {
  name: 'VlStyleText',
  components: {
    BackgroundStyle: __vue_component__$z,
    FillStyle: __vue_component__$F,
    StrokeStyle: __vue_component__$E
  },
  mixins: [fillStyleContainer, strokeStyleContainer, style],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    font: {
      type: String,
      default: '10px sans-serif' // css font format https://developer.mozilla.org/en-US/docs/Web/CSS/font?v=control

    },
    maxAngle: Number,
    placement: String,
    offsetX: {
      type: Number,
      default: 0
    },
    offsetY: {
      type: Number,
      default: 0
    },
    overflow: Boolean,
    rotateWithView: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    },
    scale: {
      type: Number,
      default: 1
    },
    text: String,
    textAlign: String,
    // left, right, center, end, start
    textBaseline: String,
    // bottom, top, middle, alphabetic, hanging, ideographic
    padding: {
      type: Array,
      default: () => [0, 0, 0, 0],
      validate: val => val.length && val.length === 4
    }
  },

  data() {
    var _this$padding;

    return {
      currentFont: this.font,
      currentMaxAngle: this.maxAngle,
      currentPlacement: this.placement,
      currentOffsetX: this.offsetX,
      currentOffsetY: this.offsetY,
      currentOverflow: this.overflow,
      currentRotateWithView: this.rotateWithView,
      currentRotation: this.rotation,
      currentScale: this.scale,
      currentText: this.text,
      currentTextAlign: this.textAlign,
      currentTextBaseline: this.textBaseline,
      currentPadding: (_this$padding = this.padding) === null || _this$padding === void 0 ? void 0 : _this$padding.slice()
    };
  },

  computed: {
    inputPadding() {
      var _this$padding2;

      return (_this$padding2 = this.padding) === null || _this$padding2 === void 0 ? void 0 : _this$padding2.slice();
    },

    stroke() {
      if (!(this.rev && this.$stroke)) return;
      return dumpStrokeStyle(this.$stroke);
    },

    fill() {
      if (!(this.rev && this.$fill)) return;
      return dumpFillStyle(this.$fill);
    },

    backgroundFill() {
      if (!(this.rev && this.$bgFill)) return;
      return dumpFillStyle(this.$bgFill);
    },

    backgroundStroke() {
      if (!(this.rev && this.$bgStroke)) return;
      return dumpStrokeStyle(this.$bgStroke);
    }

  },
  watch: {
    rev() {
      if (!this.$style) return;
      this.setFont(this.getFont());
      this.setMaxAngle(this.getMaxAngle());
      this.setPlacement(this.getPlacement());
      this.setOffsetX(this.getOffsetX());
      this.setOffsetY(this.getOffsetY());
      this.setOverflow(this.getOverflow());
      this.setRotateWithView(this.getRotateWithView());
      this.setRotation(this.getRotation());
      this.setScale(this.getScale());
      this.setText(this.getText());
      this.setTextAlign(this.getTextAlign());
      this.setTextBaseline(this.getTextBaseline());
      this.setPadding(this.getPadding());
    },

    ... /*#__PURE__*/makeWatchers(['font', 'maxAngle', 'placement', 'offsetX', 'offsetY', 'overflow', 'rotateWithView', 'rotation', 'scale', 'text', 'textAlign', 'textBaseline', 'inputPadding'], inProp => {
      const prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      const setter = 'set' + upperFirst(prop);
      return {
        deep: ['inputPadding'].includes(inProp),

        handler(value) {
          this[setter](value);
        }

      };
    }),
    ... /*#__PURE__*/makeWatchers(['currentFont', 'currentMaxAngle', 'currentPlacement', 'currentOffsetX', 'currentOffsetY', 'currentOverflow', 'currentRotateWithView', 'currentRotation', 'currentScale', 'currentText', 'currentTextAlign', 'currentTextBaseline', 'currentPadding'], curProp => {
      const prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
      const inProp = 'input' + upperFirst(prop);
      return {
        deep: ['currentPadding'].includes(curProp),

        handler(value) {
          if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
          this.$emit(`update:${prop}`, isObjectLike(value) ? clonePlainObject(value) : value);
        }

      };
    }),
    ... /*#__PURE__*/makeWatchers(['fill', 'stroke', 'backgroundFill', 'backgroundStroke'], prop => ({
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit(`update:${prop}`, isObjectLike(value) ? clonePlainObject(value) : value);
      }

    }))
  },

  created() {
    this._bgFill = undefined;
    this._bgFillVm = undefined;
    this._bgStroke = undefined;
    this._bgStrokeVm = undefined;
    defineServices$4.call(this);
  },

  methods: {
    /**
     * @returns {Text}
     * @protected
     */
    createStyle() {
      return new Text({
        font: this.currentFont,
        maxAngle: this.currentMaxAngle,
        placement: this.currentPlacement,
        offsetX: this.currentOffsetX,
        offsetY: this.currentOffsetY,
        overflow: this.currentOverflow,
        rotateWithView: this.currentRotateWithView,
        rotation: this.currentRotation,
        scale: this.currentScale,
        text: this.currentText,
        textAlign: this.currentTextAlign,
        textBaseline: this.currentTextBaseline,
        padding: this.currentPadding,
        fill: this.$fill,
        stroke: this.$stroke,
        backgroundFill: this.$bgFill,
        backgroundStroke: this.$bgStroke
      });
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$textStyleConta;

      (_this$$textStyleConta = this.$textStyleContainer) === null || _this$$textStyleConta === void 0 ? void 0 : _this$$textStyleConta.setText(this);
      return style.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$textStyleConta2;

      if (((_this$$textStyleConta2 = this.$textStyleContainer) === null || _this$$textStyleConta2 === void 0 ? void 0 : _this$$textStyleConta2.getTextVm()) === this) {
        await this.$textStyleContainer.setText(null);
      }

      return style.methods.unmount.call(this);
    },

    /**
     * @return {Promise<void>}
     */
    async refresh() {
      var _this$$textStyleConta3;

      await Promise.all([style.methods.refresh.call(this), (_this$$textStyleConta3 = this.$textStyleContainer) === null || _this$$textStyleConta3 === void 0 ? void 0 : _this$$textStyleConta3.refresh()]);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(style.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this), {
        get bgStyleContainer() {
          return vm;
        }

      });
    },

    /**
     * @protected
     */
    syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setFont(this.getFont());
      this.setMaxAngle(this.getMaxAngle());
      this.setPlacement(this.getPlacement());
      this.setOffsetX(this.getOffsetX());
      this.setOffsetY(this.getOffsetY());
      this.setOverflow(this.getOverflow());
      this.setRotateWithView(this.getRotateWithView());
      this.setRotation(this.getRotation());
      this.setScale(this.getScale());
      this.setText(this.getText());
      this.setTextAlign(this.getTextAlign());
      this.setTextBaseline(this.getTextBaseline());
      this.setPadding(this.getPadding());
    },

    getFont() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getFont(), this.currentFont);
    },

    setFont(font) {
      if (font !== this.currentFont) {
        this.currentFont = font;
        this.scheduleRefresh();
      }

      if (this.$style && font !== this.$style.getFont()) {
        this.$style.setFont(font);
        this.scheduleRefresh();
      }
    },

    getMaxAngle() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getMaxAngle(), this.currentMaxAngle);
    },

    setMaxAngle(maxAngle) {
      if (maxAngle !== this.currentMaxAngle) {
        this.currentMaxAngle = maxAngle;
        this.scheduleRefresh();
      }

      if (this.$style && maxAngle !== this.$style.getMaxAngle()) {
        this.$style.setMaxAngle(maxAngle);
        this.scheduleRefresh();
      }
    },

    getOffsetX() {
      var _this$$style3;

      return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getOffsetX(), this.currentOffsetX);
    },

    setOffsetX(offsetX) {
      if (offsetX !== this.currentOffsetX) {
        this.currentOffsetX = offsetX;
        this.scheduleRefresh();
      }

      if (this.$style && offsetX !== this.$style.getOffsetX()) {
        this.$style.setOffsetX(offsetX);
        this.scheduleRefresh();
      }
    },

    getOffsetY() {
      var _this$$style4;

      return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getOffsetY(), this.currentOffsetY);
    },

    setOffsetY(offsetY) {
      if (offsetY !== this.currentOffsetY) {
        this.currentOffsetY = offsetY;
        this.scheduleRefresh();
      }

      if (this.$style && offsetY !== this.$style.getOffsetY()) {
        this.$style.setOffsetY(offsetY);
        this.scheduleRefresh();
      }
    },

    getOverflow() {
      var _this$$style5;

      return coalesce((_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getOverflow(), this.currentOverflow);
    },

    setOverflow(overflow) {
      if (overflow !== this.currentOverflow) {
        this.currentOverflow = overflow;
        this.scheduleRefresh();
      }

      if (this.$style && overflow !== this.$style.getOverflow()) {
        this.$style.setOverflow(overflow);
        this.scheduleRefresh();
      }
    },

    getPadding() {
      var _this$$style6;

      return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getPadding(), this.currentPadding);
    },

    setPadding(padding) {
      var _padding;

      padding = (_padding = padding) === null || _padding === void 0 ? void 0 : _padding.slice();

      if (!isEqual(padding, this.currentPadding)) {
        this.currentPadding = padding;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(padding, this.$style.getPadding())) {
        this.$style.setPadding(padding);
        this.scheduleRefresh();
      }
    },

    getPlacement() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getPlacement(), this.currentPlacement);
    },

    setPlacement(placement) {
      if (placement !== this.currentPlacement) {
        this.currentPlacement = placement;
        this.scheduleRefresh();
      }

      if (this.$style && placement !== this.$style.getPlacement()) {
        this.$style.setPlacement(placement);
        this.scheduleRefresh();
      }
    },

    getRotateWithView() {
      var _this$$style7;

      return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getRotateWithView(), this.currentRotateWithView);
    },

    setRotateWithView(rotateWithView) {
      if (rotateWithView !== this.currentRotateWithView) {
        this.currentRotateWithView = rotateWithView;
        this.scheduleRefresh();
      }

      if (this.$style && rotateWithView !== this.$style.getRotateWithView()) {
        this.$style.setRotateWithView(rotateWithView);
        this.scheduleRefresh();
      }
    },

    getRotation() {
      var _this$$style8;

      return coalesce((_this$$style8 = this.$style) === null || _this$$style8 === void 0 ? void 0 : _this$$style8.getRotation(), this.currentRotation);
    },

    setRotation(rotation) {
      if (rotation !== this.currentRotation) {
        this.currentRotation = rotation;
        this.scheduleRefresh();
      }

      if (this.$style && rotation !== this.$style.getRotation()) {
        this.$style.setRotation(rotation);
        this.scheduleRefresh();
      }
    },

    getScale() {
      var _this$$style9;

      return coalesce((_this$$style9 = this.$style) === null || _this$$style9 === void 0 ? void 0 : _this$$style9.getScale(), this.currentScale);
    },

    setScale(scale) {
      if (scale !== this.currentScale) {
        this.currentScale = scale;
        this.scheduleRefresh();
      }

      if (this.$style && scale !== this.$style.getScale()) {
        this.$style.setScale(scale);
        this.scheduleRefresh();
      }
    },

    getText() {
      var _this$$style10;

      return coalesce((_this$$style10 = this.$style) === null || _this$$style10 === void 0 ? void 0 : _this$$style10.getText(), this.currentText);
    },

    setText(text) {
      if (text !== this.currentText) {
        this.currentText = text;
        this.scheduleRefresh();
      }

      if (this.$style && text !== this.$style.getText()) {
        this.$style.setText(text);
        this.scheduleRefresh();
      }
    },

    getTextAlign() {
      var _this$$style11;

      return coalesce((_this$$style11 = this.$style) === null || _this$$style11 === void 0 ? void 0 : _this$$style11.getTextAlign(), this.currentTextAlign);
    },

    setTextAlign(textAlign) {
      if (textAlign !== this.currentTextAlign) {
        this.currentTextAlign = textAlign;
        this.scheduleRefresh();
      }

      if (this.$style && textAlign !== this.$style.getTextAlign()) {
        this.$style.setTextAlign(textAlign);
        this.scheduleRefresh();
      }
    },

    getTextBaseline() {
      var _this$$style12;

      return coalesce((_this$$style12 = this.$style) === null || _this$$style12 === void 0 ? void 0 : _this$$style12.getTextBaseline(), this.currentTextBaseline);
    },

    setTextBaseline(textBaseline) {
      if (textBaseline !== this.currentTextBaseline) {
        this.currentTextBaseline = textBaseline;
        this.scheduleRefresh();
      }

      if (this.$style && textBaseline !== this.$style.getTextBaseline()) {
        this.$style.setTextBaseline(textBaseline);
        this.scheduleRefresh();
      }
    },

    getFillStyleTarget() {
      return this.$style;
    },

    getStrokeStyleTarget() {
      return this.$style;
    },

    getBackgroundFill() {
      return this._bgFill;
    },

    setBackgroundFill(fill) {
      var _fill;

      fill = ((_fill = fill) === null || _fill === void 0 ? void 0 : _fill.$fill) || fill;
      fill || (fill = undefined);

      if (fill !== this._bgFill) {
        var _fill2;

        this._bgFill = fill;
        this._bgFillVm = ((_fill2 = fill) === null || _fill2 === void 0 ? void 0 : _fill2.vm) && fill.vm[0];
        this.scheduleRefresh();
      }

      if (this.$style && fill !== this.$style.getBackgroundFill()) {
        this.$style.setBackgroundFill(fill);
        this.scheduleRefresh();
      }
    },

    getBackgroundStroke() {
      return this._bgStroke;
    },

    setBackgroundStroke(stroke) {
      var _stroke;

      stroke = ((_stroke = stroke) === null || _stroke === void 0 ? void 0 : _stroke.$stroke) || stroke;
      stroke || (stroke = undefined);

      if (stroke !== this._bgStroke) {
        var _stroke2;

        this._bgStroke = stroke;
        this._bgStrokeVm = ((_stroke2 = stroke) === null || _stroke2 === void 0 ? void 0 : _stroke2.vm) && stroke.vm[0];
        this.scheduleRefresh();
      }

      if (this.$style && stroke !== this.$style.getBackgroundStroke()) {
        this.$style.setBackgroundStroke(stroke);
        this.scheduleRefresh();
      }
    }

  }
};

function defineServices$4() {
  Object.defineProperties(this, {
    $textStyleContainer: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.textStyleContainer;
      }
    },
    $bgFill: {
      enumerable: true,
      get: this.getBackgroundFill
    },
    $bgFillVm: {
      enumerable: true,
      get: () => this._bgFillVm
    },
    $bgStroke: {
      enumerable: true,
      get: this.getBackgroundStroke
    },
    $bgStrokeVm: {
      enumerable: true,
      get: () => this._bgStrokeVm
    }
  });
}

/* script */
const __vue_script__$y = script$y;
/* template */

var __vue_render__$5 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", function () {
    return [_c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style',
        "color": "#333"
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style',
        "color": "#eee"
      }
    })];
  }), _vm._v(" "), _c('BackgroundStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-background-style'
    }
  }, [_vm._t("background")], 2)], 2);
};

var __vue_staticRenderFns__$5 = [];
/* style */

const __vue_inject_styles__$y = undefined;
/* scoped */

const __vue_scope_id__$y = undefined;
/* module identifier */

const __vue_module_identifier__$y = undefined;
/* functional template */

const __vue_is_functional_template__$y = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$y = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$5,
  staticRenderFns: __vue_staticRenderFns__$5
}, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y, __vue_module_identifier__$y, false, undefined, undefined, undefined);

function plugin$v(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$v.installed) {
    return;
  }

  plugin$v.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$D, options);
  Object.assign(__vue_component__$F, options);
  Object.assign(__vue_component__$C, options);
  Object.assign(__vue_component__$B, options);
  Object.assign(__vue_component__$E, options);
  Object.assign(__vue_component__$A, options);
  Object.assign(__vue_component__$y, options);
  Vue.component(__vue_component__$D.name, __vue_component__$D);
  Vue.component(__vue_component__$F.name, __vue_component__$F);
  Vue.component(__vue_component__$C.name, __vue_component__$C);
  Vue.component(__vue_component__$B.name, __vue_component__$B);
  Vue.component(__vue_component__$E.name, __vue_component__$E);
  Vue.component(__vue_component__$A.name, __vue_component__$A);
  Vue.component(__vue_component__$y.name, __vue_component__$y); // todo remove in v0.13.x

  Vue.component('VlStyleBox', {
    name: 'VlStyleBox',
    extends: __vue_component__$A,

    created() {
      if (process.env.NODE_ENV !== 'production') {
        this.$logger.warn('VlStyleBox component is deprecated. Use VlStyle component instead.');
      }
    }

  });
}

var Style = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$v,
  install: plugin$v,
  CircleStyle: __vue_component__$D,
  FillStyle: __vue_component__$F,
  IconStyle: __vue_component__$C,
  RegShapeStyle: __vue_component__$B,
  StrokeStyle: __vue_component__$E,
  Style: __vue_component__$A,
  TextStyle: __vue_component__$y
});

var script$x = {
  name: 'VlLayerGraticuleLatStyleAdapter',
  mixins: [stubVNode, textStyleContainer, olCmp],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  computed: {
    text() {
      if (!(this.rev && this.$text)) return;
      return dumpTextStyle(this.$text);
    }

  },
  watch: {
    text: {
      deep: true,

      handler(value, prev) {
        if (!isEqual(value, prev)) return;
        this.$emit('update:text', value && clonePlainObject(value));
      }

    }
  },

  created() {
    Object.defineProperties(this, {
      $latStyleContainer: {
        enumerable: true,
        get: () => {
          var _this$$services;

          return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.latStyleContainer;
        }
      }
    });
  },

  methods: {
    createOlObject() {
      const obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },

    getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this));
    },

    getTextStyleTarget() {
      return {
        getText: () => {
          var _this$$latStyleContai;

          return (_this$$latStyleContai = this.$latStyleContainer) === null || _this$$latStyleContai === void 0 ? void 0 : _this$$latStyleContai.getLatLabelStyle();
        },
        setText: style => {
          var _this$$latStyleContai2;

          return (_this$$latStyleContai2 = this.$latStyleContainer) === null || _this$$latStyleContai2 === void 0 ? void 0 : _this$$latStyleContai2.setLatLabelStyle(style);
        }
      };
    }

  }
};

/* script */
const __vue_script__$x = script$x;
/* template */

/* style */

const __vue_inject_styles__$x = undefined;
/* scoped */

const __vue_scope_id__$x = undefined;
/* module identifier */

const __vue_module_identifier__$x = undefined;
/* functional template */

const __vue_is_functional_template__$x = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$x = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$x, false, undefined, undefined, undefined);

var script$w = {
  name: 'VlLayerGraticuleLonStyleAdapter',
  mixins: [stubVNode, textStyleContainer, olCmp],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  computed: {
    text() {
      if (!(this.rev && this.$text)) return;
      return dumpTextStyle(this.$text);
    }

  },
  watch: {
    text: {
      deep: true,

      handler(value, prev) {
        if (!isEqual(value, prev)) return;
        this.$emit('update:text', value && clonePlainObject(value));
      }

    }
  },

  created() {
    Object.defineProperties(this, {
      $lonStyleContainer: {
        enumerable: true,
        get: () => {
          var _this$$services;

          return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.lonStyleContainer;
        }
      }
    });
  },

  methods: {
    createOlObject() {
      const obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },

    getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this));
    },

    getTextStyleTarget() {
      return {
        getText: () => {
          var _this$$lonStyleContai;

          return (_this$$lonStyleContai = this.$lonStyleContainer) === null || _this$$lonStyleContai === void 0 ? void 0 : _this$$lonStyleContai.getLonLabelStyle();
        },
        setText: style => {
          var _this$$lonStyleContai2;

          return (_this$$lonStyleContai2 = this.$lonStyleContainer) === null || _this$$lonStyleContai2 === void 0 ? void 0 : _this$$lonStyleContai2.setLonLabelStyle(style);
        }
      };
    }

  }
};

/* script */
const __vue_script__$w = script$w;
/* template */

/* style */

const __vue_inject_styles__$w = undefined;
/* scoped */

const __vue_scope_id__$w = undefined;
/* module identifier */

const __vue_module_identifier__$w = undefined;
/* functional template */

const __vue_is_functional_template__$w = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$w = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$w, false, undefined, undefined, undefined);

var script$v = {
  name: 'VlLayerGraticuleStrokeStyleAdapter',
  mixins: [stubVNode, strokeStyleContainer, olCmp],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  computed: {
    stroke() {
      if (!(this.rev && this.$stroke)) return;
      return dumpStrokeStyle(this.$stroke);
    }

  },
  watch: {
    stroke: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:stroke', value && clonePlainObject(value));
      }

    }
  },

  created() {
    Object.defineProperties(this, {
      $strokeStyleContainer: {
        enumerable: true,
        get: () => {
          var _this$$services;

          return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.strokeStyleContainer;
        }
      }
    });
  },

  methods: {
    createOlObject() {
      const obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },

    getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this));
    },

    getStrokeStyleTarget() {
      return {
        setStroke: style => this.$strokeStyleContainer.setStrokeStyle(style),
        getStroke: () => this.$strokeStyleContainer.getStrokeStyle()
      };
    }

  }
};

/* script */
const __vue_script__$v = script$v;
/* template */

/* style */

const __vue_inject_styles__$v = undefined;
/* scoped */

const __vue_scope_id__$v = undefined;
/* module identifier */

const __vue_module_identifier__$v = undefined;
/* functional template */

const __vue_is_functional_template__$v = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$v = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$v, false, undefined, undefined, undefined);

//
var script$u = {
  name: 'VlLayerGraticule',
  components: {
    LonStyle: __vue_component__$w,
    LatStyle: __vue_component__$x,
    GStrokeStyle: __vue_component__$v,
    TextStyle: __vue_component__$y,
    FillStyle: __vue_component__$F,
    StrokeStyle: __vue_component__$E
  },
  mixins: [vectorLayer],
  props: {
    // ol/layer/Graticule
    maxLines: {
      type: Number,
      default: 100
    },
    targetSize: {
      type: Number,
      default: 100
    },
    showLabels: {
      type: Boolean,
      default: false
    },
    lonLabelFormatter: Function,
    latLabelFormatter: Function,
    lonLabelPosition: {
      type: Number,
      default: 0
    },
    latLabelPosition: {
      type: Number,
      default: 1
    },
    intervals: {
      type: Array,
      default: () => [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    inputIntervals() {
      var _this$intervals;

      return (_this$intervals = this.intervals) === null || _this$intervals === void 0 ? void 0 : _this$intervals.slice();
    },

    meridians() {
      if (!this.rev) return [];
      return map$1(this.getMeridians(), geom => this.writeGeometryInDataProj(geom));
    },

    parallels() {
      if (!this.rev) return [];
      return map$1(this.getParallels(), geom => this.writeGeometryInDataProj(geom));
    },

    lonLabelStyle() {
      if (!(this.rev && this.$lonLabelStyle)) return;
      return dumpTextStyle(this.$lonLabelStyle);
    },

    latLabelStyle() {
      if (!(this.rev && this.$latLabelStyle)) return;
      return dumpTextStyle(this.$latLabelStyle);
    },

    strokeStyle() {
      if (!(this.rev && this.$strokeStyle)) return;
      return dumpStrokeStyle(this.$strokeStyle);
    }

  },
  watch: {
    meridians: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:meridians', clonePlainObject(value));
      }

    },
    parallels: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:parallels', clonePlainObject(value));
      }

    },
    lonLabelStyle: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:lonLabelStyle', value && clonePlainObject(value));
      }

    },
    latLabelStyle: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:latLabelStyle', value && clonePlainObject(value));
      }

    },
    strokeStyle: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:strokeStyle', value && clonePlainObject(value));
      }

    },
    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['maxLines', 'targetSize', 'showLabels', 'lonLabelFormatter', 'latLabelFormatter', 'lonLabelPosition', 'latLabelPosition', 'inputIntervals', 'wrapX'], ['inputIntervals'])
  },

  created() {
    this._lonLabelStyle = undefined;
    this._lonLabelStyleVm = undefined;
    this._latLabelStyle = undefined;
    this._latLabelStyleVm = undefined;
    this._strokeStyle = undefined;
    this._strokeStyleVm = undefined;
    Object.defineProperties(this, {
      $lonLabelStyle: {
        enumerable: true,
        get: this.getLonLabelStyle
      },
      $lonLabelStyleVm: {
        enumerable: true,
        get: this.getLonLabelStyleVm
      },
      $latLabelStyle: {
        enumerable: true,
        get: this.getLatLabelStyle
      },
      $latLabelStyleVm: {
        enumerable: true,
        get: this.getLatLabelStyleVm
      },
      $strokeStyle: {
        enumerable: true,
        get: this.getStrokeStyle
      },
      $strokeStyleVm: {
        enumerable: true,
        get: this.getStrokeStyleVm
      }
    });
  },

  methods: {
    createLayer() {
      return new GraticuleLayer$1({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        // ol/layer/Vector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style,
        // ol/layer/Graticule
        maxLines: this.maxLines,
        strokeStyle: this.$strokeStyle,
        targetSize: this.targetSize,
        showLabels: this.showLabels,
        lonLabelFormatter: this.lonLabelFormatter,
        latLabelFormatter: this.latLabelFormatter,
        lonLabelPosition: this.lonLabelPosition,
        latLabelPosition: this.latLabelPosition,
        lonLabelStyle: this.$lonLabelStyle,
        latLabelStyle: this.$latLabelStyle,
        intervals: this.inputIntervals,
        wrapX: this.wrapX
      });
    },

    getServices() {
      const vm = this;
      return mergeDescriptors(vectorLayer.methods.getServices.call(this), {
        get lonStyleContainer() {
          return vm;
        },

        get latStyleContainer() {
          return vm;
        },

        get strokeStyleContainer() {
          return vm;
        }

      });
    },

    getMeridians() {
      var _this$$layer;

      return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getMeridians(), []);
    },

    getParallels() {
      var _this$$layer2;

      return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getParallels(), []);
    },

    getLonLabelStyle() {
      return this._lonLabelStyle;
    },

    getLonLabelStyleVm() {
      return this._lonLabelStyleVm;
    },

    setLonLabelStyle(style) {
      var _style, _style2, _style3;

      style = ((_style = style) === null || _style === void 0 ? void 0 : _style.$style) || style;
      style || (style = undefined);
      assert(!style || style instanceof Text, 'Invalid lon label style');
      if (style === this._lonLabelStyle) return;
      this._lonLabelStyle = style;
      this._lonLabelStyleVm = ((_style2 = style) === null || _style2 === void 0 ? void 0 : _style2.vm) && ((_style3 = style) === null || _style3 === void 0 ? void 0 : _style3.vm[0]);

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('lonLabelStyle changed, scheduling recreate...');
      }

      this.scheduleRecreate();
    },

    getLatLabelStyle() {
      return this._latLabelStyle;
    },

    getLatLabelStyleVm() {
      return this._latLabelStyleVm;
    },

    setLatLabelStyle(style) {
      var _style4, _style5, _style6;

      style = ((_style4 = style) === null || _style4 === void 0 ? void 0 : _style4.$style) || style;
      style || (style = undefined);
      assert(!style || style instanceof Text, 'Invalid lat label style');
      if (style === this._latLabelStyle) return;
      this._latLabelStyle = style;
      this._latLabelStyleVm = ((_style5 = style) === null || _style5 === void 0 ? void 0 : _style5.vm) && ((_style6 = style) === null || _style6 === void 0 ? void 0 : _style6.vm[0]);

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('latLabelStyle changed, scheduling recreate...');
      }

      this.scheduleRecreate();
    },

    getStrokeStyle() {
      return this._strokeStyle;
    },

    getStrokeStyleVm() {
      return this._strokeStyleVm;
    },

    setStrokeStyle(style) {
      var _style7, _style8, _style9;

      style = (_style7 = style) === null || _style7 === void 0 ? void 0 : _style7.$style;
      style || (style = undefined);
      assert(!style || style instanceof Stroke, 'Invalid stroke style');
      if (style === this._strokeStyle) return;
      this._strokeStyle = style;
      this._strokeStyleVm = ((_style8 = style) === null || _style8 === void 0 ? void 0 : _style8.vm) && ((_style9 = style) === null || _style9 === void 0 ? void 0 : _style9.vm[0]);

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('strokeStyle changed, scheduling recreate...');
      }

      this.scheduleRecreate();
    }

  }
};

/* script */
const __vue_script__$u = script$u;
/* template */

var __vue_render__$4 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_c('LonStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-lon-style'
    }
  }, [_vm._t("lon", function () {
    return [_c('TextStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-text-style',
        "font": "'12px Calibri,sans-serif'",
        "text-baseline": "bottom"
      }
    }, [_c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style',
        "color": "rgba(0,0,0,1)"
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style',
        "color": "rgba(255,255,255,1)",
        "width": 3
      }
    })], 1)];
  })], 2), _vm._v(" "), _c('LatStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-lat-style'
    }
  }, [_vm._t("lat", function () {
    return [_c('TextStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-text-style',
        "font": "'12px Calibri,sans-serif'",
        "text-align": "end"
      }
    }, [_c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style',
        "color": "rgba(0,0,0,1)"
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style',
        "color": "rgba(255,255,255,1)",
        "width": 3
      }
    })], 1)];
  })], 2), _vm._v(" "), _c('GStrokeStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-graticule-style'
    }
  }, [_vm._t("stroke", function () {
    return [_c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-graticule-stroke-style',
        "color": "rgba(0,0,0,0.2)"
      }
    })];
  })], 2)], 1);
};

var __vue_staticRenderFns__$4 = [];
/* style */

const __vue_inject_styles__$u = undefined;
/* scoped */

const __vue_scope_id__$u = undefined;
/* module identifier */

const __vue_module_identifier__$u = undefined;
/* functional template */

const __vue_is_functional_template__$u = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$u = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$4,
  staticRenderFns: __vue_staticRenderFns__$4
}, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$u, false, undefined, undefined, undefined);

function plugin$u(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$u.installed) {
    return;
  }

  plugin$u.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$u, options);
  Vue.component(__vue_component__$u.name, __vue_component__$u); // todo remove in v0.13.x

  Vue.component('VlGraticule', {
    name: 'VlGraticule',
    extends: __vue_component__$u,

    created() {
      if (process.env.NODE_ENV !== 'production') {
        this.$logger.warn('VlGraticule component is deprecated. Use VlLayerGraticule component instead.');
      }
    }

  });
}

var GraticuleLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$u,
  install: plugin$u,
  Layer: __vue_component__$u
});

var script$t = {
  name: 'VlLayerGroup',
  mixins: [layersContainer, baseLayer],
  computed: {
    layers() {
      if (!this.rev) return [];
      return map$1(this.getLayers(), layer => ({
        id: getLayerId(layer),
        type: layer.constructor.name
      }));
    }

  },
  watch: {
    layers: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:layers', value.slice());
      }

    }
  },
  methods: {
    createLayer() {
      return new Group({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Group
        layers: this.$layersCollection
      });
    },

    getServices() {
      return mergeDescriptors(baseLayer.methods.getServices.call(this), layersContainer.methods.getServices.call(this));
    },

    subscribeAll() {
      layersContainer.methods.subscribeAll.call(this);
      baseLayer.methods.subscribeAll.call(this);
    }

  }
};

/* script */
const __vue_script__$t = script$t;
/* template */

/* style */

const __vue_inject_styles__$t = undefined;
/* scoped */

const __vue_scope_id__$t = undefined;
/* module identifier */

const __vue_module_identifier__$t = undefined;
/* functional template */

const __vue_is_functional_template__$t = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$t = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$t, false, undefined, undefined, undefined);

function plugin$t(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$t.installed) {
    return;
  }

  plugin$t.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$t, options);
  Vue.component(__vue_component__$t.name, __vue_component__$t);
}

var GroupLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$t,
  install: plugin$t,
  Layer: __vue_component__$t
});

var script$s = {
  name: 'VlLayerHeatmap',
  mixins: [vectorLayer],
  props: {
    /**
     * @type {string[]}
     */
    gradient: {
      type: Array,
      default: () => ['#0000ff', '#00ffff', '#00ff00', '#ffff00', '#ff0000']
    },

    /**
     * @type {number}
     */
    radius: {
      type: Number,
      default: 8
    },

    /**
     * @type {number}
     */
    blur: {
      type: Number,
      default: 15
    },

    /**
     * @type {string}
     */
    weight: {
      type: [String, Function],
      default: 'weight'
    }
  },

  data() {
    return {
      currentGradient: this.gradient.slice(),
      currentRadius: this.radius,
      currentBlur: this.blur
    };
  },

  computed: {
    inputGradient() {
      return this.gradient.slice();
    }

  },
  watch: {
    rev() {
      if (!this.$layer) return;

      if (!isEqual(this.currentGradient, this.$layer.getGradient())) {
        this.currentGradient = this.$layer.getGradient();
      }

      if (this.currentRadius !== this.$layer.getRadius()) {
        this.currentRadius = this.$layer.getRadius();
      }

      if (this.currentBlur !== this.$layer.getBlur()) {
        this.currentBlur = this.$layer.getBlur();
      }
    },

    inputGradient(value) {
      this.setGradient(value);
    },

    currentGradient: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.inputGradient)) return;
        this.$emit('update:gradient', value.slice());
      }

    },

    radius(value) {
      this.setRadius(value);
    },

    currentRadius(value) {
      if (value === this.radius) return;
      this.$emit('update:radius', value);
    },

    blur(value) {
      this.setBlur(value);
    },

    currentBlur(value) {
      if (value === this.blur) return;
      this.$emit('update:blur', value);
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['weight'])
  },
  methods: {
    /**
     * @returns {HeatmapLayer}
     */
    createLayer() {
      return new Heatmap({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style,
        // ol/layer/Heatmap
        blur: this.currentBlur,
        gradient: this.currentGradient,
        radius: this.currentRadius,
        weight: this.weight
      });
    },

    subscribeAll() {
      vectorLayer.methods.subscribeAll.call(this);
      subscribeToLayerEvents.call(this);
    },

    getBlur() {
      var _this$$layer;

      return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getBlur(), this.currentBlur);
    },

    setBlur(blur) {
      blur = Number(blur);
      assert(isNumber(blur), 'Invalid blur');

      if (blur !== this.currentBlur) {
        this.currentBlur = blur;
      }

      if (this.$layer && blur !== this.$layer.getBlur()) {
        this.$layer.setBlur(blur);
      }
    },

    getGradient() {
      var _this$$layer2;

      return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getGradient(), this.currentGradient);
    },

    setGradient(gradient) {
      assert(isArray(gradient), 'Invalid gradient');
      gradient = gradient.slice();

      if (!isEqual(gradient, this.currentGradient)) {
        this.currentGradient = gradient;
      }

      if (this.$layer && !isEqual(gradient, this.$layer.getGradient())) {
        this.$layer.setGradient(gradient);
      }
    },

    getRadius() {
      var _this$$layer3;

      return coalesce((_this$$layer3 = this.$layer) === null || _this$$layer3 === void 0 ? void 0 : _this$$layer3.getRadius(), this.currentRadius);
    },

    setRadius(radius) {
      radius = Number(radius);
      assert(isNumber(radius), 'Invalid radius');

      if (radius !== this.currentRadius) {
        this.currentRadius = radius;
      }

      if (this.$layer && radius !== this.$layer.getRadius()) {
        this.$layer.setRadius(radius);
      }
    }

  }
};

function subscribeToLayerEvents() {
  const setterKey = addPrefix('set');
  const propChanges = fromOlChangeEvent(this.$layer, ['blur', 'gradient', 'radius'], true, evt => ({ ...evt,
    setter: this[setterKey(evt.prop)]
  }));
  this.subscribeTo(propChanges, _ref => {
    let {
      setter,
      value
    } = _ref;
    return setter(value);
  });
}

/* script */
const __vue_script__$s = script$s;
/* template */

/* style */

const __vue_inject_styles__$s = undefined;
/* scoped */

const __vue_scope_id__$s = undefined;
/* module identifier */

const __vue_module_identifier__$s = undefined;
/* functional template */

const __vue_is_functional_template__$s = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$s = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$s, false, undefined, undefined, undefined);

function plugin$s(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$s.installed) {
    return;
  }

  plugin$s.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$s, options);
  Vue.component(__vue_component__$s.name, __vue_component__$s);
}

var HeatmapLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$s,
  install: plugin$s,
  Layer: __vue_component__$s
});

const validateUrl$1 = /*#__PURE__*/and(isString, negate(isEmpty));
var script$r = {
  name: 'VlSourceImageArcgisRest',
  mixins: [arcgisSource, imageSource],
  props: {
    // ol/source/ImageArcGISRest
    crossOrigin: String,
    imageLoadFunction: Function,

    /**
     * @deprecated
     * @todo remove later
     */
    imageLoadFunc: Function,
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    ratio: {
      type: Number,
      default: 1.5
    },
    url: {
      type: String,
      required: true,
      validator: validateUrl$1
    }
  },

  data() {
    return {
      currentImageLoadFunction: this.imageLoadFunction,
      currentUrl: this.url
    };
  },

  computed: {
    inputImageLoadFunction() {
      return this.imageLoadFunction || this.imageLoadFunc;
    }

  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (this.currentImageLoadFunction !== this.$source.getImageLoadFunction()) {
        this.currentImageLoadFunction = this.$source.getImageLoadFunction();
      }

      if (this.currentUrl !== this.$source.getUrl()) {
        this.currentUrl = this.$source.getUrl();
      }
    },

    url(value) {
      this.setUrl(value);
    },

    currentUrl(value) {
      if (value === this.url) return;
      this.$emit('update:url', value);
    },

    inputImageLoadFunction(value) {
      this.setImageLoadFunction(value);
    },

    currentImageLoadFunction(value) {
      if (value === this.imageLoadFunction) return;
      this.$emit('update:imageLoadFunction', value);
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'imageSmoothing', 'ratio'])
  },

  created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.imageLoadFunc) {
        this.$logger.warn("'imageLoadFunc' prop is deprecated. Use 'imageLoadFunction' prop instead.");
      }
    }

    this.currentImageLoadFunction = this.inputImageLoadFunction;
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.imageLoadFunc) {
        this.$logger.warn("'imageLoadFunc' prop is deprecated. Use 'imageLoadFunction' prop instead.");
      }
    }
  },

  methods: {
    createSource() {
      return new ImageArcGISRest({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        // ol/source/Image
        resolutions: this.inputResolutions,
        // ol/source/ImageArcGISRest
        crossOrigin: this.crossOrigin,
        hidpi: this.hidpi,
        imageLoadFunction: this.currentImageLoadFunction,
        imageSmoothing: this.imageSmoothing,
        params: this.currentParams,
        ratio: this.ratio,
        url: this.currentUrl
      });
    },

    getUrl() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.currentUrl);
    },

    setUrl(url) {
      assert(validateUrl$1(url), 'Invalid url');

      if (url !== this.currentUrl) {
        this.currentUrl = url;
      }

      if (this.$source && url !== this.$source.getUrl()) {
        this.$source.setUrl(url);
      }
    },

    getImageLoadFunction() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageLoadFunction(), this.currentImageLoadFunction);
    },

    setImageLoadFunction(func) {
      assert(isFunction(func), 'Invalid image load function');

      if (func !== this.currentImageLoadFunction) {
        this.currentImageLoadFunction = func;
      }

      if (this.$source && func !== this.$source.getImageLoadFunction()) {
        this.$source.setImageLoadFunction(func);
      }
    },

    stateChanged: noop
  }
};

/* script */
const __vue_script__$r = script$r;
/* template */

/* style */

const __vue_inject_styles__$r = undefined;
/* scoped */

const __vue_scope_id__$r = undefined;
/* module identifier */

const __vue_module_identifier__$r = undefined;
/* functional template */

const __vue_is_functional_template__$r = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$r = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r, __vue_module_identifier__$r, false, undefined, undefined, undefined);

function plugin$r(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$r.installed) {
    return;
  }

  plugin$r.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$r, options);
  Vue.component(__vue_component__$r.name, __vue_component__$r);
}

var ImageArcgisRestSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$r,
  install: plugin$r,
  Source: __vue_component__$r
});

/**
 * Layer for server-rendered images that are available for arbitrary extents and resolutions.
 */

var script$q = {
  name: 'VlLayerImage',
  mixins: [imageLayer],
  methods: {
    /**
     * @return {Image}
     * @protected
     */
    createLayer() {
      return new Image$1({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source
      });
    }

  }
};

/* script */
const __vue_script__$q = script$q;
/* template */

/* style */

const __vue_inject_styles__$q = undefined;
/* scoped */

const __vue_scope_id__$q = undefined;
/* module identifier */

const __vue_module_identifier__$q = undefined;
/* functional template */

const __vue_is_functional_template__$q = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$q = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$q, false, undefined, undefined, undefined);

function plugin$q(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$q.installed) {
    return;
  }

  plugin$q.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$q, options);
  Vue.component(__vue_component__$q.name, __vue_component__$q);
}

var ImageLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$q,
  install: plugin$q,
  Layer: __vue_component__$q
});

/**
 * A layer source for displaying a single, static image.
 */

var script$p = {
  name: 'VlSourceImageStatic',
  mixins: [imageSource],
  props: {
    // ol/source/ImageStatic
    crossOrigin: String,

    /**
     * Image extent in the source projection.
     * @type {number[]}
     */
    imageExtent: {
      type: Array,
      // required: true,
      validator: value => value.length === 4
    },

    /**
     * @deprecated
     * @todo remove later
     */
    imgExtent: {
      type: Array,
      validator: value => value.length === 4
    },

    /**
     * @deprecated Use `imgExtent` instead.
     * @todo remove in v0.13.x
     */
    extent: {
      type: Array,
      validator: value => value.length === 4
    },

    /**
     * Optional function to load an image given a URL.
     * @type {function|undefined}
     */
    imageLoadFunction: Function,

    /**
     * @deprecated
     * @todo remove later
     */
    imgLoadFunc: Function,

    /**
     * @deprecated Use `imgLoadFunc` instead.
     * @todo remove in v0.13.x
     */
    loadFunc: Function,

    /**
     * Image size in pixels.
     * @type {number[]}
     */
    imageSize: {
      type: Array,
      validator: value => value.length === 2
    },

    /**
     * @deprecated
     * @todo remove later
     */
    imgSize: {
      type: Array,
      validator: value => value.length === 2
    },

    /**
     * @deprecated Use `imgSize` instead.
     * @todo remove in v0.13.x
     */
    size: {
      type: Array,
      validator: value => value.length === 2
    },

    /**
     * @type {boolean}
     */
    imageSmoothing: {
      type: Boolean,
      default: true
    },

    /**
     * Image URL.
     * @type {string}
     */
    url: {
      type: String,
      required: true,
      validator: /*#__PURE__*/negate(isEmpty)
    }
  },
  computed: {
    inputImageExtent() {
      var _coalesce;

      return (_coalesce = coalesce(this.imageExtent, this.imgExtent, this.extent)) === null || _coalesce === void 0 ? void 0 : _coalesce.slice();
    },

    inputImageLoadFunction() {
      return coalesce(this.imageLoadFunction, this.imgLoadFunc, this.loadFunc);
    },

    inputImageSize() {
      var _coalesce2;

      return (_coalesce2 = coalesce(this.imageSize, this.imgSize, this.size)) === null || _coalesce2 === void 0 ? void 0 : _coalesce2.slice();
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'inputImageExtent', 'inputImageLoadFunction', 'inputImageSize', 'imageSmoothing', 'url'], ['inputImageExtent', 'inputImageSize'])
  },

  created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.extent) {
        this.$logger.warn("'extent' is deprecated. Use `imageExtent` prop instead.");
      }

      if (this.imgExtent) {
        this.$logger.warn("'imgExtent' is deprecated. Use `imageExtent` prop instead.");
      }

      if (this.loadFunc) {
        this.$logger.warn("'loadFunc' is deprecated. Use `imageLoadFunction` prop instead.");
      }

      if (this.imgLoadFunc) {
        this.$logger.warn("'imgLoadFunc' is deprecated. Use `imageLoadFunction` prop instead.");
      }

      if (this.size) {
        this.$logger.warn("'size' is deprecated. Use `imageSize` prop instead.");
      }

      if (this.imgSize) {
        this.$logger.warn("'imgSize' is deprecated. Use `imageSize` prop instead.");
      }
    }
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.extent) {
        this.$logger.warn("'extent' is deprecated. Use `imageExtent` prop instead.");
      }

      if (this.imgExtent) {
        this.$logger.warn("'imgExtent' is deprecated. Use `imageExtent` prop instead.");
      }

      if (this.loadFunc) {
        this.$logger.warn("'loadFunc' is deprecated. Use `imageLoadFunction` prop instead.");
      }

      if (this.imgLoadFunc) {
        this.$logger.warn("'imgLoadFunc' is deprecated. Use `imageLoadFunction` prop instead.");
      }

      if (this.size) {
        this.$logger.warn("'size' is deprecated. Use `imageSize` prop instead.");
      }

      if (this.imgSize) {
        this.$logger.warn("'imgSize' is deprecated. Use `imageSize` prop instead.");
      }
    }
  },

  methods: {
    /**
     * @return {ImageStatic}
     * @protected
     */
    createSource() {
      return new ImageStatic({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        // ol/source/ImageStatic
        crossOrigin: this.crossOrigin,
        imageExtent: this.inputImageExtent,
        imageLoadFunction: this.inputImageLoadFunction,
        imageSize: this.inputImageSize,
        imageSmoothing: this.imageSmoothing,
        url: this.url
      });
    },

    getUrl() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.url);
    },

    getImageExtent() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageExtent(), this.inputImageExtent);
    },

    stateChanged: noop
  }
};

/* script */
const __vue_script__$p = script$p;
/* template */

/* style */

const __vue_inject_styles__$p = undefined;
/* scoped */

const __vue_scope_id__$p = undefined;
/* module identifier */

const __vue_module_identifier__$p = undefined;
/* functional template */

const __vue_is_functional_template__$p = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$p = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$p, false, undefined, undefined, undefined);

function plugin$p(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$p.installed) {
    return;
  }

  plugin$p.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$p, options);
  Vue.component(__vue_component__$p.name, __vue_component__$p);
}

var ImageStaticSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$p,
  install: plugin$p,
  Source: __vue_component__$p
});

const validateUrl = /*#__PURE__*/and(isString, negate(isEmpty));
var script$o = {
  name: 'VlSourceImageWms',
  mixins: [wmsSource, imageSource],
  props: {
    // ol/source/ImageArcGISRest
    crossOrigin: String,
    imageLoadFunction: Function,

    /**
     * @deprecated
     * @todo remove later
     */
    imageLoadFunc: Function,
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    ratio: {
      type: Number,
      default: 1.5
    },
    url: {
      type: String,
      required: true,
      validator: validateUrl
    }
  },

  data() {
    return {
      currentImageLoadFunction: this.imageLoadFunction,
      currentUrl: this.url
    };
  },

  computed: {
    inputImageLoadFunction() {
      return this.imageLoadFunction || this.imageLoadFunc;
    }

  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (this.currentUrl !== this.$source.getUrl()) {
        this.currentUrl = this.$source.getUrl();
      }

      if (this.currentImageLoadFunction !== this.$source.getImageLoadFunction()) {
        this.currentImageLoadFunction = this.$source.getImageLoadFunction();
      }
    },

    url(value) {
      this.setUrl(value);
    },

    currentUrl(value) {
      if (value === this.url) return;
      this.$emit('update:url', value);
    },

    inputImageLoadFunction(value) {
      this.setImageLoadFunction(value);
    },

    currentImageLoadFunc(value) {
      if (value === this.imageLoadFunction) return;
      this.$emit('update:imageLoadFunction', value);
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'imageSmoothing', 'ratio'])
  },

  created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.imageLoadFunc) {
        this.$logger.warn("'imageLoadFunc' prop is deprecated. Use 'imageLoadFunction' prop instead.");
      }
    }

    this.currentImageLoadFunction = this.inputImageLoadFunction;
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.imageLoadFunc) {
        this.$logger.warn("'imageLoadFunc' prop is deprecated. Use 'imageLoadFunction' prop instead.");
      }
    }
  },

  methods: {
    createSource() {
      return new ImageWMS({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        // ol/source/Image
        resolutions: this.inputResolutions,
        // ol/source/ImageWMS
        crossOrigin: this.crossOrigin,
        hidpi: this.hidpi,
        serverType: this.serverType,
        imageLoadFunction: this.currentImageLoadFunction,
        imageSmoothing: this.imageSmoothing,
        params: this.currentParams,
        ratio: this.ratio,
        url: this.currentUrl
      });
    },

    getUrl() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.currentUrl);
    },

    setUrl(url) {
      assert(validateUrl(url), 'Invalid url');

      if (url !== this.currentUrl) {
        this.currentUrl = url;
      }

      if (this.$source && url !== this.$source.getUrl()) {
        this.$source.setUrls(url);
      }
    },

    getImageLoadFunction() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageLoadFunction(), this.currentImageLoadFunction);
    },

    setImageLoadFunction(func) {
      assert(isFunction(func), 'Invalid image load function');

      if (func !== this.currentImageLoadFunction) {
        this.currentImageLoadFunction = func;
      }

      if (this.$source && func !== this.$source.getImageLoadFunction()) {
        this.$source.setImageLoadFunction(func);
      }
    },

    stateChanged: noop
  }
};

/* script */
const __vue_script__$o = script$o;
/* template */

/* style */

const __vue_inject_styles__$o = undefined;
/* scoped */

const __vue_scope_id__$o = undefined;
/* module identifier */

const __vue_module_identifier__$o = undefined;
/* functional template */

const __vue_is_functional_template__$o = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$o = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o, __vue_module_identifier__$o, false, undefined, undefined, undefined);

function plugin$o(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$o.installed) {
    return;
  }

  plugin$o.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$o, options);
  Vue.component(__vue_component__$o.name, __vue_component__$o);
}

var ImageWmsSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$o,
  install: plugin$o,
  Source: __vue_component__$o
});

/**
 * Layer for data that is rendered client-side.
 */

var script$n = {
  name: 'VlLayerVector',
  mixins: [vectorLayer],
  props: {
    /**
     * @deprecated Use `vl-layer-vector-image` to render vector layer as image
     * @todo remove in v0.13.x
     */
    renderMode: String
  },

  created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.renderMode) {
        this.$logger.warn("'renderMode' is deprecated. Use vl-layer-vector-image to render vector layer as image");
      }
    }
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.renderMode) {
        this.$logger.warn("'renderMode' is deprecated. Use vl-layer-vector-image to render vector layer as image");
      }
    }
  },

  methods: {
    /**
     * @return {module:ol/layer/Vector~VectorLayer}
     * @protected
     */
    createLayer() {
      return new Vector$1({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style
      });
    }

  }
};

/* script */
const __vue_script__$n = script$n;
/* template */

/* style */

const __vue_inject_styles__$n = undefined;
/* scoped */

const __vue_scope_id__$n = undefined;
/* module identifier */

const __vue_module_identifier__$n = undefined;
/* functional template */

const __vue_is_functional_template__$n = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$n = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$n, false, undefined, undefined, undefined);

function plugin$n(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$n.installed) {
    return;
  }

  plugin$n.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$n, options);
  Vue.component(__vue_component__$n.name, __vue_component__$n);
}

var VectorLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$n,
  install: plugin$n,
  Layer: __vue_component__$n
});

var script$m = {
  name: 'VlSourceVector',
  mixins: [vectorSource]
};

/* script */
const __vue_script__$m = script$m;
/* template */

/* style */

const __vue_inject_styles__$m = undefined;
/* scoped */

const __vue_scope_id__$m = undefined;
/* module identifier */

const __vue_module_identifier__$m = undefined;
/* functional template */

const __vue_is_functional_template__$m = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$m = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$m, false, undefined, undefined, undefined);

function plugin$m(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$m.installed) {
    return;
  }

  plugin$m.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$m, options);
  Vue.component(__vue_component__$m.name, __vue_component__$m);
}

var VectorSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$m,
  install: plugin$m,
  Source: __vue_component__$m
});

//
/**
 * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,
 * **resolution**, and **rotation** of the map.
 */

var script$l = {
  name: 'VlView',
  mixins: [projTransforms, olCmp, waitForMap],
  stubVNode: {
    empty() {
      return this.vmId;
    }

  },
  props: {
    /**
     * @type {number[]}
     */
    center: {
      type: Array,
      default: () => [0, 0],
      validator: value => value.length === 2 && value.every(isNumber)
    },

    /**
     * @type {boolean}
     */
    constrainOnlyCenter: Boolean,

    /**
     * @type {number[]|undefined}
     */
    extent: {
      type: Array,
      validator: value => value.length === 4 && value.every(isNumber)
    },

    /**
     * @type {boolean}
     */
    smoothExtentConstraint: {
      type: Boolean,
      default: true
    },

    /**
     * @type {number}
     */
    rotation: {
      type: Number,
      default: 0
    },

    /**
     * @type {boolean}
     */
    enableRotation: {
      type: Boolean,
      default: true
    },

    /**
     * @type {boolean|number}
     */
    constrainRotation: {
      type: [Boolean, Number],
      default: true
    },

    /**
     * @type {number|undefined}
     */
    resolution: Number,

    /**
     * @type {number[]|undefined}
     */
    resolutions: {
      type: Array,
      validator: value => value.every(isNumber)
    },

    /**
     * @type {number|undefined}
     */
    maxResolution: Number,

    /**
     * @type {number|undefined}
     */
    minResolution: Number,

    /**
     * @type {boolean}
     */
    constrainResolution: Boolean,

    /**
     * @type {boolean}
     */
    smoothResolutionConstraint: {
      type: Boolean,
      default: true
    },

    /**
     * @type {number}
     */
    zoom: {
      type: Number,
      default: 0
    },

    /**
     * @type {number}
     */
    zoomFactor: {
      type: Number,
      default: 2
    },

    /**
     * @type {number}
     */
    maxZoom: {
      type: Number,
      default: 28
    },

    /**
     * @type {number}
     */
    minZoom: {
      type: Number,
      default: 0
    },

    /**
     * @type {boolean}
     */
    multiWorld: Boolean,

    /**
     * @type {string}
     */
    projection: {
      type: String,
      default: EPSG_3857,
      validator: value => get(value) != null
    },
    showFullExtent: Boolean
  },

  data() {
    var _this$resolutions;

    return {
      dataProjection: this.projection,
      currentProjection: this.projection,
      currentCenterViewProj: roundPointCoords(this.center),
      currentZoom: this.zoom,
      currentRotation: this.rotation,
      currentResolution: this.resolution,
      currentMinZoom: this.minZoom,
      currentMaxZoom: this.maxZoom,
      currentResolutions: (_this$resolutions = this.resolutions) === null || _this$resolutions === void 0 ? void 0 : _this$resolutions.slice(),
      currentMaxResolution: this.maxResolution,
      currentMinResolution: this.minResolution
    };
  },

  computed: {
    centerDataProj() {
      return roundPointCoords(this.center);
    },

    centerViewProj() {
      return this.pointToViewProj(this.center);
    },

    currentCenterDataProj() {
      return this.pointToDataProj(this.currentCenterViewProj);
    },

    extentDataProj() {
      return roundExtent(this.extent);
    },

    extentViewProj() {
      return this.extentToViewProj(this.extent);
    },

    inputResolutions() {
      var _this$resolutions2;

      return (_this$resolutions2 = this.resolutions) === null || _this$resolutions2 === void 0 ? void 0 : _this$resolutions2.slice();
    },

    visibleExtentDataProj() {
      var _this$getExtent;

      if (!this.rev) return;
      return (_this$getExtent = this.getExtent()) === null || _this$getExtent === void 0 ? void 0 : _this$getExtent.slice();
    },

    visibleExtentViewProj() {
      var _this$getExtent2;

      if (!this.rev) return;
      return (_this$getExtent2 = this.getExtent(true)) === null || _this$getExtent2 === void 0 ? void 0 : _this$getExtent2.slice();
    },

    animating() {
      return !!(this.rev && this.getAnimating());
    },

    interacting() {
      return !!(this.rev && this.getInteracting());
    },

    resolvedViewProjection() {
      return this.currentProjection;
    }

  },
  watch: {
    rev() {
      if (!this.$view) return;

      if (this.currentProjection !== this.$view.getProjection().getCode()) {
        this.currentProjection = this.$view.getProjection().getCode();
      }

      if (!isEqual(this.currentCenterViewProj, roundPointCoords(this.$view.getCenter()))) {
        this.currentCenterViewProj = roundPointCoords(this.$view.getCenter());
      }

      if (this.currentZoom !== this.$view.getZoom()) {
        this.currentZoom = this.$view.getZoom();
      }

      if (this.currentRotation !== this.$view.getRotation()) {
        this.currentRotation = this.$view.getRotation();
      }

      if (this.currentResolution !== this.$view.getResolution()) {
        this.currentResolution = this.$view.getResolution();
      }

      if (this.currentMinZoom !== this.$view.getMinZoom()) {
        this.currentMinZoom = this.$view.getMinZoom();
      }

      if (this.currentMaxZoom !== this.$view.getMaxZoom()) {
        this.currentMaxZoom = this.$view.getMaxZoom();
      }

      if (!isEqual(this.currentResolutions, this.$view.getResolutions())) {
        this.currentResolutions = this.$view.getResolutions();
      }

      if (this.currentMaxResolution !== this.$view.getMaxResolution()) {
        this.currentMaxResolution = this.$view.getMaxResolution();
      }

      if (this.currentMinResolution !== this.$view.getMinResolution()) {
        this.currentMinResolution = this.$view.getMinResolution();
      }
    },

    centerViewProj: {
      deep: true,

      handler(value) {
        if (this.getAnimating()) return;
        this.setCenter(value, true);
      }

    },
    currentCenterDataProj: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.centerDataProj)) return;
        this.$emit('update:center', value.slice());
      }

    },

    rotation(value) {
      if (this.getAnimating()) return;
      this.setRotation(value);
    },

    currentRotation(value) {
      if (value === this.rotation) return;
      this.$emit('update:rotation', value);
    },

    resolution(value) {
      if (this.getAnimating()) return;
      this.setResolution(value);
    },

    currentResolution(value) {
      if (value === this.resolution) return;
      this.$emit('update:resolution', value);
    },

    constrainResolution(value) {
      this.setConstrainResolution(value);
    },

    zoom(value) {
      if (this.getAnimating()) return;
      this.setZoom(value);
    },

    currentZoom(value) {
      if (value === this.zoom) return;
      this.$emit('update:zoom', value);
    },

    minZoom(value) {
      this.setMinZoom(value);
    },

    currentMinZoom(value) {
      if (value === this.minZoom) return;
      this.$emit('update:minZoom', value);
    },

    maxZoom(value) {
      this.setMaxZoom(value);
    },

    currentMaxZoom(value) {
      if (value === this.maxZoom) return;
      this.$emit('update:maxZoom', value);
    },

    inputResolutions: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.currentResolutions)) return;

        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('resolutions changed, scheduling recreate... %O ===> %O', this.currentResolutions, value);
        }

        this.currentResolutions = value === null || value === void 0 ? void 0 : value.slice();
        return this.scheduleRecreate();
      }

    },
    currentResolutions: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.inputResolutions)) return;
        this.$emit('update:resolutions', value === null || value === void 0 ? void 0 : value.slice());
      }

    },

    maxResolution(value) {
      if (value === this.currentMaxResolution) return;

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('maxResolution changed, scheduling recreate... %O ===> %O', this.currentMaxResolution, value);
      }

      this.currentMaxResolution = value;
      return this.scheduleRecreate();
    },

    currentMaxResolution(value) {
      if (value === this.maxResolution) return;
      this.$emit('update:maxResolution', value);
    },

    minResolution(value) {
      if (value === this.currentMinResolution) return;

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('minResolution changed, scheduling recreate... %O ===> %O', this.currentMinResolution, value);
      }

      this.currentMinResolution = value;
      return this.scheduleRecreate();
    },

    currentMinResolution(value) {
      if (value === this.minResolution) return;
      this.$emit('update:minResolution', value);
    },

    projection(value) {
      var _this$inputResolution;

      if (value === this.currentProjection) return;

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('projection changed, scheduling recreate... %O ===> %O', this.currentProjection, value);
      }

      this.currentProjection = this.dataProjection = value; // reset current resolution fields to inputs
      // so zoom fields will take precedence

      this.currentResolution = this.resolution;
      this.currentResolutions = (_this$inputResolution = this.inputResolutions) === null || _this$inputResolution === void 0 ? void 0 : _this$inputResolution.slice();
      this.currentMaxResolution = this.maxResolution;
      this.currentMinResolution = this.minResolution;
      return this.scheduleRecreate();
    },

    currentProjection(value) {
      if (value === this.projection) return;
      this.$emit('update:projection', value);
    },

    animating(value, prev) {
      if (value === prev) return;
      this.$emit('update:animating', value);
    },

    interacting(value, prev) {
      if (value === prev) return;
      this.$emit('update:interacting', value);
    },

    visibleExtentDataProj: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:visibleExtent', value === null || value === void 0 ? void 0 : value.slice());
      }

    },
    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['constrainOnlyCenter', 'smoothExtentConstraint', 'enableRotation', 'constrainRotation', 'constrainResolution', 'smoothResolutionConstraint', 'zoomFactor', 'multiWorld', 'extentViewProj'], ['extentViewProj'])
  },

  created() {
    defineServices$3.call(this);
    this.currentCenterViewProj = this.centerViewProj.slice();
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {module:ol/View~View}
     * @protected
     */
    createOlObject() {
      const view = new View({
        center: this.currentCenterViewProj,
        constrainOnlyCenter: this.constrainOnlyCenter,
        extent: this.extentViewProj,
        smoothExtentConstraint: this.smoothExtentConstraint,
        rotation: this.currentRotation,
        enableRotation: this.enableRotation,
        constrainRotation: this.constrainRotation,
        resolution: this.currentResolution,
        resolutions: this.currentResolutions,
        maxResolution: this.currentMaxResolution,
        minResolution: this.currentMinResolution,
        constrainResolution: this.constrainResolution,
        smoothResolutionConstraint: this.smoothResolutionConstraint,
        zoom: this.currentZoom,
        zoomFactor: this.zoomFactor,
        maxZoom: this.currentMaxZoom,
        minZoom: this.currentMinZoom,
        multiWorld: this.multiWorld,
        projection: this.currentProjection,
        showFullExtent: this.showFullExtent
      });
      initializeView(view, this.currentId);
      return view;
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$viewContainer;

      (_this$$viewContainer = this.$viewContainer) === null || _this$$viewContainer === void 0 ? void 0 : _this$$viewContainer.setView(this);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    async unmount() {
      var _this$$viewContainer2;

      if (((_this$$viewContainer2 = this.$viewContainer) === null || _this$$viewContainer2 === void 0 ? void 0 : _this$$viewContainer2.getViewVm()) === this) {
        this.$viewContainer.setView(null);
      }

      return olCmp.methods.unmount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToEvents$1.call(this);
    },

    /**
     * @return {*}
     * @protected
     */
    getIdInternal() {
      return getViewId(this.$view);
    },

    /**
     * @param {*} id
     * @protected
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setViewId(this.$view, id);
    },

    /**
     * @return {Promise<module:ol/View~View>}
     */
    resolveView: olCmp.methods.resolveOlObject,

    /**
     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}
     * @param {...(module:ol/View~AnimationOptions|function(boolean))} args
     * @return {Promise<boolean>} Resolves when animation completes
     */
    async animate() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      let cb = noop;

      if (isFunction(args[args.length - 1])) {
        cb = args[args.length - 1];
        args = args.slice(0, args.length - 1);
      }

      args.forEach(opts => {
        if (!isArray(opts.center)) return;

        if (!opts.viewProj) {
          opts.center = this.pointToViewProj(opts.center);
        }
      });
      const view = await this.resolveView();
      return new Promise(resolve => {
        view.animate(...args, complete => {
          cb(complete);
          resolve(complete);
        });
      });
    },

    /**
     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}
     * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent} geometryOrExtent
     * @param {module:ol/View~FitOptions} [options]
     * @return {Promise<boolean>} Resolves when view changes
     */
    async fit(geometryOrExtent) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // transform from GeoJSON, vl-feature to ol.Feature
      if (isGeoJSONGeometry(geometryOrExtent)) {
        if (options.viewProj) {
          geometryOrExtent = this.readGeometryInViewProj(geometryOrExtent);
        } else {
          geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent);
        }
      } else if (isFunction(geometryOrExtent.resolveOlObject)) {
        geometryOrExtent = await geometryOrExtent.resolveOlObject();
      }

      const cb = options.callback || noop;
      const view = await this.resolveView();
      return new Promise(resolve => {
        view.fit(geometryOrExtent, { ...options,
          callback: complete => {
            cb(complete);
            resolve(complete);
          }
        });
      });
    },

    /**
     * @return {Promise<void>}
     */
    async cancelAnimations() {
      (await this.resolveView()).cancelAnimations();
    },

    /**
     * @return {boolean}
     */
    getAnimating() {
      var _this$$view;

      return coalesce((_this$$view = this.$view) === null || _this$$view === void 0 ? void 0 : _this$$view.getAnimating(), false);
    },

    /**
     * @return {Promise<void>}
     */
    async beginInteraction() {
      (await this.resolveView()).beginInteraction();
    },

    /**
     * @param {number} [duration]
     * @param {number} [resolutionDirection]
     * @param {number[]} [anchor]
     * @param {boolean} [viewProj=false]
     * @return {Promise<void>}
     */
    async endInteraction(duration, resolutionDirection, anchor) {
      let viewProj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!viewProj) {
        anchor = this.pointToViewProj(anchor);
      }

      (await this.resolveView()).endInteraction(duration, resolutionDirection, anchor);
    },

    /**
     * @return {boolean}
     */
    getInteracting() {
      var _this$$view2;

      return coalesce((_this$$view2 = this.$view) === null || _this$$view2 === void 0 ? void 0 : _this$$view2.getInteracting(), false);
    },

    /**
     * @param {number[]|undefined} [size]
     * @param {boolean} [viewProj=false]
     * @return {Promise<number[]>}
     */
    async calculateExtent(size) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const extent = (await this.resolveView()).calculateExtent(size);

      if (viewProj) {
        return roundExtent(extent);
      }

      return this.extentToDataProj(extent);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]|undefined}
     */
    getExtent() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.$view) return;
      const extent = this.$view.calculateExtent();
      if (viewProj) return roundExtent(extent);
      return this.extentToDataProj(extent);
    },

    /**
     * @param {number[]} coordinate
     * @param {number[]} size
     * @param {number[]} position
     * @param {boolean} [viewProj=false]
     * @return {Promise<void>}
     */
    async centerOn(coordinate, size, position) {
      let viewProj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!viewProj) {
        coordinate = this.pointToViewProj(coordinate);
      }

      (await this.resolveView()).centerOn(coordinate, size, position);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]}
     */
    getCenter() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this.$view) {
        return viewProj ? this.currentCenterViewProj : this.currentCenterDataProj;
      }

      const center = this.$view.getCenter();
      if (viewProj) return center;
      return this.pointToDataProj(center);
    },

    /**
     * @param {number[]} center
     * @param {boolean} [viewProj=false]
     */
    setCenter(center) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isArray(center) && center.length === 2, 'Invalid center');

      if (viewProj) {
        center = roundPointCoords(center);
      } else {
        center = this.pointToViewProj(center);
      }

      if (this.$view && !isEqual(center, roundPointCoords(this.$view.getCenter()))) {
        this.$view.setCenter(center);
      } else if (!isEqual(center, this.currentCenterViewProj)) {
        this.currentCenterViewProj = center;
      }
    },

    /**
     * @return {number}
     */
    getResolution() {
      var _this$$view3;

      return coalesce((_this$$view3 = this.$view) === null || _this$$view3 === void 0 ? void 0 : _this$$view3.getResolution(), this.currentResolution);
    },

    /**
     * @param {number} resolution
     */
    setResolution(resolution) {
      resolution = Number(resolution);
      assert(isNumber(resolution), 'Invalid resolution');

      if (this.$view && resolution !== this.$view.getResolution()) {
        this.$view.setResolution(resolution);
      } else if (resolution !== this.currentResolution) {
        this.currentResolution = resolution;
      }
    },

    /**
     * @param {number[]} extent
     * @param {number[]} size
     * @param {boolean} [viewProj=false]
     * @return {Promise<number>}
     */
    async getResolutionForExtent(extent, size) {
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (!viewProj) {
        extent = this.extentToViewProj(extent);
      }

      return (await this.resolveView()).getResolutionForExtent(extent, size);
    },

    /**
     * @param {number} zoom
     * @return {Promise<number>}
     */
    async getResolutionForZoom(zoom) {
      return (await this.resolveView()).getResolutionForZoom(zoom);
    },

    /**
     * @return {number[]|undefined}
     */
    getResolutions() {
      var _this$$view4;

      return coalesce((_this$$view4 = this.$view) === null || _this$$view4 === void 0 ? void 0 : _this$$view4.getResolutions(), this.currentResolutions);
    },

    /**
     * @return {number|undefined}
     */
    getMaxResolution() {
      var _this$$view5;

      return coalesce((_this$$view5 = this.$view) === null || _this$$view5 === void 0 ? void 0 : _this$$view5.getMaxResolution(), this.currentMaxResolution);
    },

    /**
     * @return {number|undefined}
     */
    getMinResolution() {
      var _this$$view6;

      return coalesce((_this$$view6 = this.$view) === null || _this$$view6 === void 0 ? void 0 : _this$$view6.getMinResolution(), this.currentMinResolution);
    },

    /**
     * @return {number|undefined}
     */
    getZoom() {
      var _this$$view7;

      return coalesce((_this$$view7 = this.$view) === null || _this$$view7 === void 0 ? void 0 : _this$$view7.getZoom(), this.currentZoom);
    },

    /**
     * @param {number} zoom
     */
    setZoom(zoom) {
      zoom = Number(zoom);
      assert(isNumber(zoom), 'Invalid zoom');

      if (this.$view && zoom !== this.$view.getZoom()) {
        this.$view.setZoom(zoom);
      } else if (zoom !== this.currentZoom) {
        this.currentZoom = zoom;
      }
    },

    /**
     * @param {number} resolution
     * @return {Promise<number|undefined>}
     */
    async getZoomForResolution(resolution) {
      return (await this.resolveView()).getZoomForResolution(resolution);
    },

    /**
     * @return {number|undefined}
     */
    getMaxZoom() {
      var _this$$view8;

      return coalesce((_this$$view8 = this.$view) === null || _this$$view8 === void 0 ? void 0 : _this$$view8.getMaxZoom(), this.currentMaxZoom);
    },

    /**
     * @param {number} zoom
     */
    setMaxZoom(zoom) {
      zoom = Number(zoom);
      assert(isNumber(zoom), 'Invalid maxZoom');

      if (this.$view && zoom !== this.$view.getMaxZoom()) {
        this.$view.setMaxZoom(zoom);
      } else if (zoom !== this.currentMaxZoom) {
        this.currentMaxZoom = zoom;
      }
    },

    /**
     * @return {number|undefined}
     */
    getMinZoom() {
      var _this$$view9;

      return coalesce((_this$$view9 = this.$view) === null || _this$$view9 === void 0 ? void 0 : _this$$view9.getMinZoom(), this.currentMinZoom);
    },

    /**
     * @param {number} zoom
     */
    setMinZoom(zoom) {
      zoom = Number(zoom);
      assert(isNumber(zoom), 'Invalid minZoom');

      if (this.$view && zoom !== this.$view.getMinZoom()) {
        this.$view.setMinZoom(zoom);
      } else if (zoom !== this.currentMinZoom) {
        this.currentMinZoom = zoom;
      }
    },

    /**
     * @return {module:ol/proj/ProjectionLike}
     */
    getProjection() {
      var _this$$view10;

      return coalesce((_this$$view10 = this.$view) === null || _this$$view10 === void 0 ? void 0 : _this$$view10.getProjection(), get(this.currentProjection));
    },

    /**
     * @return {number|undefined}
     */
    getRotation() {
      var _this$$view11;

      return coalesce((_this$$view11 = this.$view) === null || _this$$view11 === void 0 ? void 0 : _this$$view11.getRotation(), this.currentRotation);
    },

    /**
     * @param {number} rotation
     */
    setRotation(rotation) {
      rotation = Number(rotation);
      assert(isNumber(rotation), 'Invalid rotation');

      if (this.$view && rotation !== this.$view.getRotation()) {
        this.$view.setRotation(rotation);
      } else if (rotation !== this.currentRotation) {
        this.currentRotation = rotation;
      }
    }

  }
};

function defineServices$3() {
  Object.defineProperties(this, {
    /**
     * @type {module:ol/View~View|undefined}
     */
    $view: {
      enumerable: true,
      get: () => this.$olObject
    },

    /**
     * @type {Object|undefined}
     */
    $viewContainer: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.viewContainer;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.mapVm;
      }
    }
  });
}
/**
 * Subscribe to OpenLayers significant events
 * @return {void}
 * @private
 */


async function subscribeToEvents$1() {
  const setterKey = addPrefix('set'); // const resolutionChanges = obsFromOlChangeEvent(this.$view, 'resolution', true)
  // const zoomChanges = resolutionChanges.pipe(
  //   mapObs(() => ({
  //     prop: 'zoom',
  //     value: this.getZoom(),
  //   })),
  //   distinctUntilKeyChanged('value'),
  // )

  const propChanges = merge(fromOlChangeEvent(this.$view, ['id' // 'rotation',
  // 'center',
  ], true) // resolutionChanges,
  // zoomChanges,
  ).pipe(map(evt => ({ ...evt,
    setter: val => {
      const args = [val];

      if (evt.prop === 'center') {
        args.push(true);
      }

      this[setterKey(evt.prop)](...args);
    }
  })));
  this.subscribeTo(propChanges, _ref => {
    let {
      setter,
      value
    } = _ref;
    return setter(value);
  });
}

/* script */
const __vue_script__$l = script$l;
/* template */

var __vue_render__$3 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", null, {
    "center": _vm.currentCenterDataProj,
    "zoom": _vm.currentZoom,
    "resolution": _vm.currentResolution,
    "rotation": _vm.currentRotation,
    "extent": _vm.visibleExtentDataProj
  })], 2);
};

var __vue_staticRenderFns__$3 = [];
/* style */

const __vue_inject_styles__$l = undefined;
/* scoped */

const __vue_scope_id__$l = undefined;
/* module identifier */

const __vue_module_identifier__$l = undefined;
/* functional template */

const __vue_is_functional_template__$l = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$l = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$3,
  staticRenderFns: __vue_staticRenderFns__$3
}, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$l, false, undefined, undefined, undefined);

//
/**
 * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport
 * rendering and low level interaction events.
 *
 * todo make render function that injects VlView if it is not provided by the user,
 *      then it can be provided to lower components
 */

var script$k = {
  name: 'VlMap',
  components: {
    ViewCmp: __vue_component__$l,
    VectorLayerCmp: __vue_component__$n,
    VectorSourceCmp: __vue_component__$m
  },
  mixins: [projTransforms, layersContainer, controlsContainer, interactionsContainer, overlaysContainer, featuresContainer, olCmp],
  props: {
    /**
     * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object
     * value is used to configure controls.
     * @type {Object|boolean}
     * @todo remove when vl-control-* components will be ready
     */
    defaultControls: {
      type: [Object, Boolean],
      default: true
    },

    /**
     * Options for default interactions added to the map by default. Object
     * value is used to configure default interactions.
     * @type {Object|boolean}
     */
    defaultInteractions: {
      type: [Object, Boolean],
      default: true
    },

    /**
     * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard
     * interactions will always trigger. If this option is not specified, the element the library listens to keyboard
     * events on is the component root element.
     * @type {string|Element|Document|undefined}
     */
    keyboardEventTarget: [String, Element, Document],

    /**
     * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.
     * Increasing this value can make it easier to click on the map.
     * @type {number}
     */
    moveTolerance: {
      type: Number,
      default: 1
    },

    /**
     * The ratio between physical pixels and device-independent pixels (dips) on the device.
     * @type {number}
     */
    pixelRatio: {
      type: Number,
      default: () => window.devicePixelRatio || 1
    },

    /**
     * Maximum number tiles to load simultaneously.
     * @type {number}
     */
    maxTilesLoading: {
      type: Number,
      default: 16
    },

    /**
     * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.
     * @type {number|string}
     */
    tabindex: [String, Number],

    /**
     * Projection for input/output coordinates in plain data.
     * @type {string|undefined}
     */
    dataProjection: {
      type: String,
      validator: value => get(value) != null
    },

    /**
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: true
    },

    /**
     * @type {boolean}
     */
    updateWhileAnimating: {
      type: Boolean,
      default: false
    },

    /**
     * @type {boolean}
     */
    updateWhileInteracting: {
      type: Boolean,
      default: false
    }
  },

  data() {
    return {
      viewProjection: EPSG_3857,
      withCustomView: false,
      size: undefined,
      currentDataProjection: this.dataProjection
    };
  },

  computed: {
    resolvedDataProjection() {
      var _this$$options;

      return coalesce(this.currentDataProjection, this.dataProjection, (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, this.viewProjection);
    },

    view() {
      if (!(this.rev && this.$view)) return;
      return {
        id: getViewId(this.$view),
        type: this.$view.constructor.name
      };
    },

    /**
     * @returns {string[]}
     */
    layers() {
      if (!this.rev) return [];
      return map$1(this.getLayers(), layer => ({
        id: getLayerId(layer),
        type: layer.constructor.name
      }));
    },

    /**
     * @returns {string[]}
     */
    controls() {
      if (!this.rev) return [];
      return map$1(this.getControls(), control => ({
        id: getControlId(control),
        type: control.constructor.name
      }));
    },

    /**
     * @returns {string[]}
     */
    interactions() {
      if (!this.rev) return [];
      return map$1(this.getInteractions(), interaction => ({
        id: getInteractionId(interaction),
        type: interaction.constructor.name
      }));
    },

    /**
     * @returns {string[]}
     */
    overlays() {
      if (!this.rev) return [];
      return map$1(this.getOverlays(), overlay => ({
        id: getOverlayId(overlay),
        type: overlay.constructor.name
      }));
    },

    /**
     * @type {Object[]}
     */
    featuresDataProj() {
      if (!this.rev) return [];
      return map$1(this.getFeatures(), feature => this.writeFeatureInDataProj(feature));
    },

    /**
     * @type {Object[]}
     */
    featuresViewProj() {
      if (!this.rev) return [];
      return map$1(this.getFeatures(), feature => this.writeFeatureInViewProj(feature));
    }

  },
  watch: {
    rev() {
      if (!this.$map) return;

      if (!isEqual(this.size, this.$map.getSize())) {
        this.size = this.$map.getSize();
      }
    },

    size: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:size', value === null || value === void 0 ? void 0 : value.slice());
      }

    },
    defaultControls: {
      deep: true,

      handler(value) {
        this.initDefaultControls(value);
      }

    },
    defaultInteractions: {
      deep: true,

      handler(value) {
        this.initDefaultInteractions(value);
      }

    },

    dataProjection(value) {
      this.setDataProjection(value);
    },

    view: {
      deep: true,

      handler(value, prev) {
        if (value === prev) return;
        this.$emit('update:view', value);
      }

    },
    layers: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:layers', value.slice());
      }

    },
    controls: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:controls', value.slice());
      }

    },
    interactions: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:interactions', value.slice());
      }

    },
    overlays: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:overlays', value.slice());
      }

    },
    featuresDataProj: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:features', clonePlainObject(value));
      }

    },
    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['keyboardEventTarget', 'moveTolerance', 'pixelRatio', 'maxTilesLoading'])
  },

  created() {
    /**
     * @type {module:ol/View~View}
     * @private
     */
    this._view = new View({
      center: [0, 0],
      zoom: 2
    });
    /**
     * @type {Object|undefined}
     */

    this._viewVm = undefined;
    defineServices$2.call(this); // todo wrap controls into components and provide vl-control-default

    this.initDefaultControls(this.defaultControls); // todo initialize without interactions and provide vl-interaction-default component

    this.initDefaultInteractions(this.defaultInteractions);
  },

  methods: {
    /**
     * @return {module:ol/Map~Map}
     * @protected
     */
    async createOlObject() {
      const map = new Map$1({
        pixelRatio: this.pixelRatio,
        moveTolerance: this.moveTolerance,
        keyboardEventTarget: this.keyboardEventTarget,
        maxTilesLoading: this.maxTilesLoading,
        controls: this.$controlsCollection,
        interactions: this.$interactionsCollection,
        layers: this.$layersCollection,
        overlays: this.$overlaysCollection,
        view: this.$view
      });
      setMapId(map, this.currentId);
      setMapDataProjection(map, this.resolvedDataProjection);
      this.size && map.setSize(this.size);
      return map;
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      this.setTarget(this.$el);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      this.setTarget(null);
      return olCmp.methods.unmount.call(this);
    },

    /**
     * @protected
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      layersContainer.methods.subscribeAll.call(this);
      controlsContainer.methods.subscribeAll.call(this);
      interactionsContainer.methods.subscribeAll.call(this);
      overlaysContainer.methods.subscribeAll.call(this);
      featuresContainer.methods.subscribeAll.call(this);
      subscribeToEvents.call(this); // view projection can be changed in runtime only through vl-view vm

      this.subscribeTo(fromVueWatcher(this, () => {
        var _this$$viewVm;

        return (_this$$viewVm = this.$viewVm) === null || _this$$viewVm === void 0 ? void 0 : _this$$viewVm.resolvedViewProjection;
      }), _ref => {
        let {
          value
        } = _ref;
        this.viewProjection = value || EPSG_3857;
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(olCmp.methods.getServices.call(this), layersContainer.methods.getServices.call(this), controlsContainer.methods.getServices.call(this), interactionsContainer.methods.getServices.call(this), overlaysContainer.methods.getServices.call(this), featuresContainer.methods.getServices.call(this), {
        get mapVm() {
          return vm;
        },

        get viewVm() {
          return vm.$viewVm;
        },

        get viewContainer() {
          return vm;
        }

      });
    },

    /**
     * @return {string|number}
     * @protected
     */
    getIdInternal() {
      return getMapId(this.$map);
    },

    /**
     * @param {string|number} id
     * @protected
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setMapId(this.$map, id);
    },

    /**
     * @return {Promise<module:ol/Map~Map>}
     */
    resolveMap: olCmp.methods.resolveOlObject,

    /**
     * @param {number[]} pixel
     * @param {function} callback
     * @param {Object} [opts]
     * @return {Promise}
     */
    async forEachFeatureAtPixel(pixel, callback) {
      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return (await this.resolveMap()).forEachFeatureAtPixel(pixel, callback, opts);
    },

    /**
     * @param {number[]} pixel
     * @param {function} callback
     * @param {Object} [opts]
     * @return {Promise}
     */
    async forEachLayerAtPixel(pixel, callback) {
      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return (await this.resolveMap()).forEachLayerAtPixel(pixel, callback, opts);
    },

    /**
     * @param {number[]} pixel
     * @param {boolean} [viewProj=false]
     * @return {Promise<number[]>} Coordinates in the map view projection.
     */
    async getCoordinateFromPixel(pixel) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const coordinate = (await this.resolveMap()).getCoordinateFromPixel(pixel);

      if (viewProj) {
        return roundPointCoords(coordinate);
      }

      return this.pointToDataProj(coordinate);
    },

    /**
     * @param {Event} event
     * @param {boolean} [viewProj=false]
     * @return {Promise<number[]>}
     */
    async getEventCoordinate(event) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const coordinate = (await this.resolveMap()).getEventCoordinate(event);

      if (viewProj) {
        return roundPointCoords(coordinate);
      }

      return this.pointToDataProj(coordinate);
    },

    /**
     * @param {Event} event
     * @return {Promise<number[]>}
     */
    async getEventPixel(event) {
      return (await this.resolveMap()).getEventPixel(event);
    },

    /**
     * @param {number[]} pixel
     * @param {Object} [opts]
     * @return {Promise}
     */
    async getFeaturesAtPixel(pixel) {
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return (await this.resolveMap()).getFeaturesAtPixel(pixel, opts);
    },

    /**
     * @param {number[]} pixel
     * @param {Object} [options]
     * @return {Promise<boolean>}
     */
    async hasFeatureAtPixel(pixel) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return (await this.resolveMap()).hasFeatureAtPixel(pixel, options);
    },

    /**
     * @param {number[]} coordinate Coordinates in map view projection
     * @param {boolean} [viewProj=false]
     * @return {Promise<number[]>}
     */
    async getPixelFromCoordinate(coordinate) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!viewProj) {
        coordinate = this.pointToViewProj(coordinate);
      }

      return (await this.resolveMap()).getPixelFromCoordinate(coordinate);
    },

    /**
     * @return {number[]|undefined}
     */
    getSize() {
      var _this$$map;

      return coalesce((_this$$map = this.$map) === null || _this$$map === void 0 ? void 0 : _this$$map.getSize(), this.size);
    },

    /**
     * @param {number[]} size
     */
    setSize(size) {
      assert(isArray(size) && size.length === 2, 'Invalid size');
      size = size.slice();

      if (!isEqual(size, this.size)) {
        this.size = size;
      }

      if (this.$map && !isEqual(size, this.$map.getSize())) {
        this.$map.setSize(size);
      }
    },

    /**
     * Updates map size.
     * @return {Promise<void>}
     */
    async updateSize() {
      (await this.resolveMap()).updateSize();
    },

    /**
     * @return {Promise<void>}
     */
    async render() {
      const map = await this.resolveMap();
      return new Promise(resolve => {
        map.once('postrender', () => resolve());
        map.render();
      });
    },

    /**
     * @return {HTMLElement|undefined}
     */
    getTarget() {
      var _this$$map2;

      return coalesce((_this$$map2 = this.$map) === null || _this$$map2 === void 0 ? void 0 : _this$$map2.getTarget(), this.$el);
    },

    /**
     * @param {HTMLElement} target
     */
    setTarget(target) {
      if (this.$map && target !== this.$map.getTarget()) {
        this.$map.setTarget(target);
        this.$emit('update:target', target);
      }
    },

    /**
     * @return {HTMLElement|undefined}
     */
    getViewport() {
      var _this$$map3;

      return (_this$$map3 = this.$map) === null || _this$$map3 === void 0 ? void 0 : _this$$map3.getViewport();
    },

    /**
     * @return {module:ol/View~View|undefined}
     */
    getView() {
      var _this$$map4;

      return coalesce((_this$$map4 = this.$map) === null || _this$$map4 === void 0 ? void 0 : _this$$map4.getView(), this._view);
    },

    /**
     * @return {Object}
     */
    getViewVm() {
      return this._viewVm;
    },

    /**
     * @param {module:ol/View~View|Vue|undefined} view
     */
    setView(view) {
      var _view;

      view = ((_view = view) === null || _view === void 0 ? void 0 : _view.$view) || view;
      assert(!view || view instanceof View, 'Invalid view');

      if (view !== this._view) {
        var _view2, _view3;

        this._view = view;
        this._viewVm = ((_view2 = view) === null || _view2 === void 0 ? void 0 : _view2.vm) && ((_view3 = view) === null || _view3 === void 0 ? void 0 : _view3.vm[0]);
      }

      if (this.$map && view !== this.$map.getView()) {
        this.$map.setView(view);
      }

      this.scheduleRefresh();
    },

    /**
     * @return {module:ol/proj~ProjectionLike|undefined}
     */
    getDataProjection() {
      return coalesce(this.$map && getMapDataProjection(this.$map), this.resolvedDataProjection);
    },

    /**
     * @param {module:ol/proj~ProjectionLike} projection
     */
    setDataProjection(projection) {
      projection = get(projection);
      assert(projection != null, 'Invalid projection');

      if (projection.getCode() !== this.currentDataProjection) {
        this.currentDataProjection = projection.getCode();
      }

      if (this.$map && projection.getCode() !== getMapDataProjection(this.$map)) {
        setMapDataProjection(this.$map, projection.getCode());
      }
    },

    /**
     * Triggers focus on map container.
     */
    focus() {
      this.$el.focus();
    },

    /**
     * Updates map size and re-renders map.
     * @return {Promise}
     */
    async refresh() {
      await this.updateSize();
      await this.render();
      return olCmp.methods.refresh.call(this);
    },

    isInteracting() {
      if (!this.$map) return false;
      return this.getInteractions().some(interaction => !!interaction.get('interacting'));
    },

    /**
     * @param {Object} sourceVm
     * @protected
     */
    featuresOverlaySourceCreated(sourceVm) {
      sourceVm.addFeatures(this.getFeatures());
      const adds = fromVueEvent(this, 'addfeature').pipe(map(_ref2 => {
        let {
          feature
        } = _ref2;
        return feature;
      }), bufferDebounceTime(FRAME_TIME));
      this.subscribeTo(adds, features => sourceVm.addFeatures(features));
      const removes = fromVueEvent(this, 'removefeature').pipe(map(_ref3 => {
        let {
          feature
        } = _ref3;
        return feature;
      }), bufferDebounceTime(FRAME_TIME));
      this.subscribeTo(removes, features => sourceVm.removeFeatures(features));
    },

    /**
     * @protected {string} value
     * @protected
     */
    resolvedDataProjectionChanged(value) {
      if (value === this.dataProjection) return;
      this.$emit('update:dataProjection', value);
    }

  }
};

function defineServices$2() {
  Object.defineProperties(this, {
    /**
     * OpenLayers map instance.
     * @type {module:ol/Map~Map|undefined}
     */
    $map: {
      enumerable: true,
      get: () => this.$olObject
    },

    /**
     * @type {module:ol/View~View|undefined}
     */
    $view: {
      enumerable: true,
      get: this.getView
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: this.getViewVm
    },
    $featuresOverlayVm: {
      enumerable: true,
      get: () => {
        var _this$$refs;

        return (_this$$refs = this.$refs) === null || _this$$refs === void 0 ? void 0 : _this$$refs.featuresOverlay;
      }
    },
    $featuresOverlaySourceVm: {
      enumerable: true,
      get: () => {
        var _this$$refs2;

        return (_this$$refs2 = this.$refs) === null || _this$$refs2 === void 0 ? void 0 : _this$$refs2.featuresOverlaySource;
      }
    }
  });
}
/**
 * Subscribe to OL map events.
 *
 * @return {void}
 * @private
 */


async function subscribeToEvents() {
  const setterKey = addPrefix('set');
  const viewChanges = fromOlChangeEvent(this.$map, 'view', true).pipe(tap(_ref4 => {
    let {
      value: view
    } = _ref4;

    if (this._viewSubs) {
      this.unsubscribe(this._viewSubs);
    }

    if (view) {
      this._viewSubs = this.subscribeTo(fromOlChangeEvent(view, 'id', true), this.scheduleRefresh.bind(this));
    }

    this.viewProjection = (view === null || view === void 0 ? void 0 : view.getProjection().getCode()) || EPSG_3857;
    this.withCustomView = view && (!view.vm || view.vm.some(vm => vm !== this.$refs.view));
  }));
  const propChanges = merge(viewChanges, fromOlChangeEvent(this.$map, ['dataProjection', 'size', 'target' // 'layerGroup', FIXME not ready
  ], true)).pipe(map(evt => ({ ...evt,
    setter: this[setterKey(evt.prop)]
  })));
  this.subscribeTo(propChanges, _ref5 => {
    let {
      setter,
      value
    } = _ref5;
    return setter(value);
  }); // pointer

  const pointerEvents = merge(fromOlEvent(this.$map, [MapBrowserEventType.CLICK, MapBrowserEventType.DBLCLICK, MapBrowserEventType.SINGLECLICK]), fromOlEvent(this.$map, [MapBrowserEventType.POINTERDRAG, MapBrowserEventType.POINTERMOVE], null, [distinctUntilChanged((a, b) => isEqual({
    t: a.type,
    c: a.coordinate
  }, {
    t: b.type,
    c: b.coordinate
  }))])).pipe(map(evt => omit({ ...evt,
    pixel: evt.pixel,
    coordinate: this.pointToDataProj(evt.coordinate)
  }, ['pixel_', 'coordinate_']))); // other

  const otherEvents = fromOlEvent(this.$map, [MapEventType.MOVESTART, MapEventType.MOVEEND, MapEventType.POSTRENDER, RenderEventType.PRECOMPOSE, RenderEventType.POSTCOMPOSE, RenderEventType.RENDERCOMPLETE]);
  this.subscribeTo(merge(pointerEvents, otherEvents), evt => this.$emit(evt.type, evt));
}

/* script */
const __vue_script__$k = script$k;
/* template */

var __vue_render__$2 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.vmClass,
    attrs: {
      "id": _vm.vmId,
      "tabindex": _vm.tabindex
    }
  }, [_vm._t("default"), _vm._v(" "), !_vm.withCustomView ? _c('ViewCmp', {
    ref: "view",
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-view'
    }
  }) : _vm._e(), _vm._v(" "), _c('VectorLayerCmp', {
    ref: "featuresOverlay",
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-layer',
      "overlay": true,
      "update-while-animating": _vm.updateWhileAnimating,
      "update-while-interacting": _vm.updateWhileInteracting
    },
    on: {
      "prerender": function ($event) {
        return _vm.$emit('dl:prerender', $event);
      },
      "postrender": function ($event) {
        return _vm.$emit('dl:postrender', $event);
      }
    }
  }, [_c('VectorSourceCmp', {
    ref: "featuresOverlaySource",
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-source',
      "wrap-x": _vm.wrapX,
      "projection": _vm.currentDataProjection
    },
    on: {
      "created": _vm.featuresOverlaySourceCreated
    }
  }, [_vm._t("overlay")], 2)], 1)], 2);
};

var __vue_staticRenderFns__$2 = [];
/* style */

const __vue_inject_styles__$k = undefined;
/* scoped */

const __vue_scope_id__$k = undefined;
/* module identifier */

const __vue_module_identifier__$k = undefined;
/* functional template */

const __vue_is_functional_template__$k = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$k = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$2,
  staticRenderFns: __vue_staticRenderFns__$2
}, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$k, false, undefined, undefined, undefined);

function plugin$l(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$l.installed) {
    return;
  }

  plugin$l.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$k, options);
  Object.assign(__vue_component__$l, options);
  Vue.component(__vue_component__$k.name, __vue_component__$k);
  Vue.component(__vue_component__$l.name, __vue_component__$l);
}

var Map = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$l,
  install: plugin$l,
  Map: __vue_component__$k,
  View: __vue_component__$l
});

const MAPBOX_URL_TEMPLATE = 'https://{a-c}.tiles.mapbox.com/v4/{mapId}/{z}/{x}/{y}{tileNameSuffix}.{tileFormat}?access_token={accessToken}';
const MAPBOX_ATTRIBUTIONS = '&copy; <a href="https://www.mapbox.com/" target="_blank">MapBox</a>.';
var script$j = {
  name: 'VlSourceMapbox',
  mixins: [xyzSource],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Source
    attributions: { ...source.props.attributions,
      default: MAPBOX_ATTRIBUTIONS
    },
    // ol/source/UrlTile
    url: { ...urlTileSource.props.url,
      default: MAPBOX_URL_TEMPLATE
    },

    /* eslint-enable vue/require-prop-types */
    // custom
    accessToken: {
      type: String,
      required: true
    },
    mapId: {
      type: String,
      required: true
    },
    tileFormat: {
      type: String,
      default: 'png'
    }
  },
  computed: {
    /**
     * @type {string}
     */
    tileNameSuffix() {
      return tileNameSuffix(this.tilePixelRatio);
    },

    /**
     * @type {string[]}
     */
    urlTokens() {
      return ['mapId', 'accessToken', 'tileNameSuffix', 'tileFormat'];
    }

  }
};
/**
 * @param {number} [ratio]
 * @returns {number}
 * @private
 */

function tileRatio(ratio) {
  ratio = coalesce(ratio, 1);
  return ratio > 1 ? 2 : 1;
}
/**
 * @param {number} [ratio]
 * @returns {string}
 * @private
 */


function tileNameSuffix(ratio) {
  ratio = tileRatio(ratio);
  return ratio > 1 ? ['@', ratio, 'x'].join('') : '';
}

/* script */
const __vue_script__$j = script$j;
/* template */

/* style */

const __vue_inject_styles__$j = undefined;
/* scoped */

const __vue_scope_id__$j = undefined;
/* module identifier */

const __vue_module_identifier__$j = undefined;
/* functional template */

const __vue_is_functional_template__$j = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$j = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j, __vue_module_identifier__$j, false, undefined, undefined, undefined);

function plugin$k(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$k.installed) {
    return;
  }

  plugin$k.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$j, options);
  Vue.component(__vue_component__$j.name, __vue_component__$j);
}

var MapboxSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$k,
  install: plugin$k,
  Source: __vue_component__$j
});

var script$i = {
  name: 'VlLayerVectorTile',
  mixins: [tileLayer, vectorLayer],
  props: {
    renderMode: {
      type: String,
      default: RenderType.HYBRID,
      validator: val => Object.values(RenderType).includes(val)
    }
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['renderMode'])
  },
  methods: {
    /**
     * @return {VectorTileLayer}
     * @protected
     */
    createLayer() {
      return new VectorTile({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style,
        // ol/layer/VectorTile
        // tile layer props
        preload: this.currentPreload,
        useInterimTilesOnError: this.currentUseInterimTilesOnError,
        // vector tile props
        renderMode: this.renderMode
      });
    }

  }
};

/* script */
const __vue_script__$i = script$i;
/* template */

/* style */

const __vue_inject_styles__$i = undefined;
/* scoped */

const __vue_scope_id__$i = undefined;
/* module identifier */

const __vue_module_identifier__$i = undefined;
/* functional template */

const __vue_is_functional_template__$i = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$i = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$i, false, undefined, undefined, undefined);

function plugin$j(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$j.installed) {
    return;
  }

  plugin$j.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$i, options);
  Vue.component(__vue_component__$i.name, __vue_component__$i);
}

var VectorTileLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$j,
  install: plugin$j,
  Layer: __vue_component__$i
});

var script$h = {
  name: 'VlLayerMapboxVector',
  extends: __vue_component__$i,
  props: {
    styleUrl: {
      type: String,
      required: true
    },
    accessToken: {
      type: String,
      required: true
    },
    sourceId: String,
    layerIds: {
      type: Array,
      validate: val => isArray(val) && val.every(isString)
    },
    // eslint-disable-next-line vue/require-prop-types
    declutter: { ...vectorLayer.props.declutter,
      default: true
    }
  },
  watch: { ...makeChangeOrRecreateWatchers(['styleUrl', 'accessToken', 'sourceId', 'layerIds'], ['layerIds'])
  },
  methods: {
    /**
     * @returns {HeatmapLayer}
     */
    createLayer() {
      return new MapboxVector({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        // ol/layer/Tile
        preload: this.currentPreload,
        useInterimTilesOnError: this.currentUseInterimTilesOnError,
        // ol/layer/MapboxVector
        styleUrl: this.styleUrl,
        accessToken: this.accessToken,
        source: this.sourceId,
        layers: this.layerIds
      });
    }

  }
};

/* script */
const __vue_script__$h = script$h;
/* template */

/* style */

const __vue_inject_styles__$h = undefined;
/* scoped */

const __vue_scope_id__$h = undefined;
/* module identifier */

const __vue_module_identifier__$h = undefined;
/* functional template */

const __vue_is_functional_template__$h = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$h = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h, __vue_module_identifier__$h, false, undefined, undefined, undefined);

function plugin$i(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$i.installed) {
    return;
  }

  plugin$i.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$h, options);
  Vue.component(__vue_component__$h.name, __vue_component__$h);
}

var MapboxVectorLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$i,
  install: plugin$i,
  Layer: __vue_component__$h
});

var script$g = {
  name: 'VlInteractionModify',
  mixins: [interaction, styleContainer],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    /**
     * Source or collection identifier from IdentityMap.
     * @type {String}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event will be
     * considered to add or move a vertex to the sketch. Default is `ol.events.condition.primaryAction`.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: primaryAction
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default, `ol.events.condition.singleClick` with `ol.events.condition.altKeyOnly` results in a vertex deletion.
     * @type {function|undefined}
     */
    deleteCondition: {
      type: Function,
      default: altKeyOnly
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether a new vertex can be added
     * to the sketch features. Default is `ol.events.condition.always`.
     * @type {function|undefined}
     */
    insertVertexCondition: {
      type: Function,
      default: always
    },

    /**
     * Pixel tolerance for considering the pointer close enough to a segment or vertex for editing.
     * @type {number}
     */
    pixelTolerance: {
      type: Number,
      default: 10
    },

    /**
     * Wrap the world horizontally on the sketch overlay.
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: false
    }
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'condition', 'deleteCondition', 'insertVertexCondition', 'pixelTolerance', 'wrapX'])
  },
  methods: {
    /**
     * @return {Promise<Modify>}
     * @protected
     */
    async createInteraction() {
      let source = this._source = await this.getInstance(this.source);
      assert(!!source, `Source "${this.source}" not found in identity map.`);
      let features;

      if (source instanceof Vector) {
        features = source.getFeaturesCollection();

        if (features) {
          instanceOf(features, Collection, `Source "${this.source}" doesn't provide features collection.`);
          source = null;
        }
      } else {
        if (isFunction(source.getFeaturesCollection)) {
          features = source.getFeaturesCollection();
        } else if (isFunction(source.getFeatures)) {
          features = source.getFeatures();
        }

        instanceOf(features, Collection, `Source "${this.source}" doesn't provide features collection.`);
        source = null;
      }

      return new Modify({
        source,
        features,
        condition: this.condition,
        deleteCondition: this.deleteCondition,
        insertVertexCondition: this.insertVertexCondition,
        pixelTolerance: this.pixelTolerance,
        wrapX: this.wrapX,
        style: this.$style
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      subscribeToInteractionChanges$3.call(this);
    },

    /**
     * @return {StyleTarget}
     * @protected
     */
    getStyleTarget() {
      return {
        getStyle: () => this._style,
        setStyle: () => {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log('style changed, scheduling recreate...');
          }

          this.scheduleRecreate();
        }
      };
    },

    async getOverlay() {
      return (await this.resolveInteraction()).getOverlay();
    },

    async getPointerCount() {
      return (await this.resolveInteraction()).getPointerCount();
    },

    async removePoint() {
      return (await this.resolveInteraction()).removePoint();
    }

  }
};
/**
 * @private
 */

function subscribeToInteractionChanges$3() {
  let modifying;
  const start = fromOlEvent(this.$interaction, 'modifystart').pipe(tap(evt => {
    this.setInteracting(true);
    modifying = [];
    evt.features.forEach(feature => {
      modifying[feature.getId()] = feature.getRevision();
    });
  }));
  const end = fromOlEvent(this.$interaction, 'modifyend').pipe(map(evt => ({ ...evt,
    modified: evt.features.getArray().reduce((modified, feature, idx) => {
      if (modifying[feature.getId()] !== feature.getRevision()) {
        modified[idx] = feature.getId();
      }

      return modified;
    }, {})
  })), tap(() => this.setInteracting(false)));
  const events = merge(start, end).pipe(map(_ref => {
    let {
      type,
      features,
      modified
    } = _ref;
    const viewProj = this.resolvedViewProjection;
    const dataProj = this.resolvedDataProjection;
    return {
      type,
      features: features instanceof Collection ? features.getArray() : features,
      modified: modified || {},

      get json() {
        if (!this._json) {
          this._json = map$1(this.features, feature => writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION));
        }

        return this._json;
      }

    };
  }));
  this.subscribeTo(events, evt => this.$emit(evt.type, evt));
}

/* script */
const __vue_script__$g = script$g;
/* template */

/* style */

const __vue_inject_styles__$g = undefined;
/* scoped */

const __vue_scope_id__$g = undefined;
/* module identifier */

const __vue_module_identifier__$g = undefined;
/* functional template */

const __vue_is_functional_template__$g = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$g = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g, __vue_module_identifier__$g, false, undefined, undefined, undefined);

function plugin$h(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$h.installed) {
    return;
  }

  plugin$h.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$g, options);
  Vue.component(__vue_component__$g.name, __vue_component__$g);
}

var ModifyInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$h,
  install: plugin$h,
  Interaction: __vue_component__$g
});

const OSM_ATTRIBUTIONS = '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
const OSM_URL_TEMPLATE = 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
const OSM_MAX_ZOOM = 19;
var script$f = {
  name: 'VlSourceOsm',
  mixins: [xyzSource],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Source
    attributions: { ...source.props.attributions,
      default: OSM_ATTRIBUTIONS
    },
    // ol/source/UrlTile
    url: { ...urlTileSource.props.url,
      default: OSM_URL_TEMPLATE
    },
    // ol/source/XYZ
    maxZoom: { ...xyzSource.props.maxZoom,
      default: OSM_MAX_ZOOM
    }
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    tileGridIdent: noop,
    inputTileGridFactory: noop,
    inputTileUrlFunction: noop
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['inputUrl', 'maxZoom'])
  },
  methods: {
    createSource() {
      // always EPSG:3857, size: 256x256, format png
      return new OSM({
        // ol/source/Source
        attributions: this.currentAttributions,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        opaque: this.opaque,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        url: this.currentUrls[0],
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        imageSmoothing: this.imageSmoothing,
        // ol/source/XYZ
        maxZoom: this.maxZoom
      });
    },

    inputUrlChanged(value) {
      this.setUrl(value);
    },

    // skip all other handlers
    tileClassChanged: noop,
    inputTileUrlFunctionChanged: noop,
    inputTileGridFactoryChanged: noop,
    tileGridChanged: noop,
    tilePixelRatioChanged: noop,
    transitionChanged: noop,
    zDirectionChanged: noop,
    attributionsCollapsibleChanged: noop,
    projectionChanged: noop
  }
};

/* script */
const __vue_script__$f = script$f;
/* template */

/* style */

const __vue_inject_styles__$f = undefined;
/* scoped */

const __vue_scope_id__$f = undefined;
/* module identifier */

const __vue_module_identifier__$f = undefined;
/* functional template */

const __vue_is_functional_template__$f = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$f = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, false, undefined, undefined, undefined);

function plugin$g(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$g.installed) {
    return;
  }

  plugin$g.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$f, options);
  Vue.component(__vue_component__$f.name, __vue_component__$f);
}

var OsmSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$g,
  install: plugin$g,
  Source: __vue_component__$f
});

//
var script$e = {
  name: 'VlOverlay',
  mixins: [projTransforms, olCmp, waitForMap],
  props: {
    offset: {
      type: Array,
      default: () => [0, 0],
      validator: value => value.length === 2
    },
    position: {
      type: Array,
      validator: value => value.length === 2 // required: true,

    },
    positioning: {
      type: String,
      default: OverlayPositioning.TOP_LEFT,
      validator: value => Object.values(OverlayPositioning).includes(value)
    },
    stopEvent: {
      type: Boolean,
      default: true
    },
    insertFirst: {
      type: Boolean,
      default: true
    },
    autoPan: [Boolean, Object],
    autoPanMargin: Number,
    autoPanAnimation: Object,
    autoPanOptions: Object,
    className: String
  },

  data() {
    return {
      visible: false,
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentOffset: this.offset.slice(),
      currentPositionViewProj: roundPointCoords(this.position),
      currentPositioning: this.positioning
    };
  },

  computed: {
    positionDataProj() {
      return roundPointCoords(this.position);
    },

    positionViewProj() {
      return this.pointToViewProj(this.position);
    },

    currentPositionDataProj() {
      return this.pointToDataProj(this.currentPositionViewProj);
    },

    inputOffset() {
      return this.offset.slice();
    },

    inputAutoPan() {
      return isPlainObject(this.autoPan) ? clonePlainObject(this.autoPan) : this.autoPan;
    },

    inputAutoPanAnimation() {
      return isPlainObject(this.autoPanAnimation) ? clonePlainObject(this.autoPanAnimation) : this.autoPanAnimation;
    },

    inputAutoPanOptions() {
      return isPlainObject(this.autoPanOptions) ? clonePlainObject(this.autoPanOptions) : this.autoPanOptions;
    },

    classes() {
      return [this.vmClass, this.visible ? 'visible' : undefined].filter(identity);
    }

  },
  watch: {
    rev() {
      if (!this.$overlay) return;

      if (!isEqual(this.currentOffset, this.$overlay.getOffset())) {
        this.currentOffset = this.$overlay.getOffset();
      }

      if (!isEqual(this.currentPositionViewProj, this.$overlay.getPosition())) {
        this.currentPositionViewProj = this.$overlay.getPosition();
      }

      if (this.currentPositioning !== this.$overlay.getPositioning()) {
        this.currentPositioning = this.$overlay.getPositioning();
      }
    },

    inputOffset: {
      deep: true,

      handler(value) {
        this.setOffset(value);
      }

    },
    currentOffset: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.inputOffset)) return;
        this.$emit('update:offset', value.slice());
      }

    },
    positionViewProj: {
      deep: true,

      handler(value) {
        this.setPosition(value, true);
      }

    },
    currentPositionDataProj: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.positionDataProj)) return;
        this.$emit('update:position', value === null || value === void 0 ? void 0 : value.slice());
      }

    },

    positioning(value) {
      this.setPositioning(value);
    },

    currentPositioning(value) {
      if (value === this.positioning) return;
      this.$emit('update:positioning', value);
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['stopEvent', 'insertFirst', 'autoPanMargin', 'className', 'inputAutoPan', 'inputAutoPanAnimation', 'inputAutoPanOptions'], ['inputAutoPan', 'inputAutoPanAnimation', 'inputAutoPanOptions'])
  },
  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      defineServices$1.call(this);
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {module:ol/Overlay~Overlay}
     * @protected
     */
    createOlObject() {
      const overlay = new Overlay$1({
        id: this.currentId,
        element: this.$el,
        offset: this.currentOffset,
        position: this.currentPositionViewProj,
        positioning: this.currentPositioning,
        stopEvent: this.stopEvent,
        insertFirst: this.insertFirst,
        autoPan: this.inputAutoPan,
        autoPanMargin: this.autoPanMargin,
        autoPanAnimation: this.inputAutoPanAnimation,
        autoPanOptions: this.inputAutoPanOptions,
        className: this.className
      });
      initializeOverlay(overlay, this.currentId);
      return overlay;
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$overlaysContai;

      this.visible = true;
      (_this$$overlaysContai = this.$overlaysContainer) === null || _this$$overlaysContai === void 0 ? void 0 : _this$$overlaysContai.addOverlay(this.$overlay);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$overlaysContai2;

      (_this$$overlaysContai2 = this.$overlaysContainer) === null || _this$$overlaysContai2 === void 0 ? void 0 : _this$$overlaysContai2.removeOverlay(this.$overlay);
      this.visible = false;
      return olCmp.methods.unmount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToOverlayChanges.call(this);
    },

    /**
     * @return {*}
     * @protected
     */
    getIdInternal() {
      return getOverlayId(this.$overlay);
    },

    /**
     * @param {*} id
     * @protected
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setOverlayId(this.$overlay, id);
    },

    /**
     * @return {Promise<module:ol/Overlay~Overlay>}
     */
    resolveOverlay: olCmp.methods.resolveOlObject,

    getOffset() {
      var _this$$overlay;

      return coalesce((_this$$overlay = this.$overlay) === null || _this$$overlay === void 0 ? void 0 : _this$$overlay.getOffset(), this.currentOffset);
    },

    setOffset(offset) {
      assert(isArray(offset) && offset.length === 2, 'Invalid offset');
      offset = offset.slice();

      if (!isEqual(offset, this.currentOffset)) {
        this.currentOffset = offset;
      }

      if (this.$overlay && !isEqual(offset, this.$overlay.getOffset())) {
        this.$overlay.setOffset(offset);
      }
    },

    getPosition() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this.$overlay) {
        return viewProj ? this.currentPositionViewProj : this.currentPositionDataProj;
      }

      const position = this.$overlay.getPosition();
      if (viewProj) return roundPointCoords(position);
      return this.pointToDataProj(position);
    },

    setPosition(position) {
      var _position;

      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(position == null || isArray(position) && position.length === 2, 'Invalid position');
      position = (_position = position) === null || _position === void 0 ? void 0 : _position.slice();

      if (!viewProj) {
        position = this.pointToViewProj(position);
      }

      if (!isEqual(position, this.currentPositionViewProj)) {
        this.currentPositionViewProj = position;
      }

      if (this.$overlay && !isEqual(position, this.$overlay.getPosition())) {
        this.$overlay.setPosition(position);
      }
    },

    getPositioning() {
      var _this$$overlay2;

      return ((_this$$overlay2 = this.$overlay) === null || _this$$overlay2 === void 0 ? void 0 : _this$$overlay2.getPositioning()) || this.currentPositioning;
    },

    setPositioning(positioning) {
      if (positioning !== this.currentPositioning) {
        this.currentPositioning = positioning;
      }

      if (this.$overlay && positioning !== this.$overlay.getPositioning()) {
        this.$overlay.setPositioning(positioning);
      }
    },

    async panIntoView() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (await this.resolveOverlay()).panIntoView(options);
    }

  }
};

function defineServices$1() {
  Object.defineProperties(this, {
    $overlay: {
      enumerable: true,
      get: () => this.$olObject
    },
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.mapVm;
      }
    },
    $viewVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.viewVm;
      }
    },
    $overlaysContainer: {
      enumerable: true,
      get: () => {
        var _this$$services3;

        return (_this$$services3 = this.$services) === null || _this$$services3 === void 0 ? void 0 : _this$$services3.overlaysContainer;
      }
    }
  });
}
/**
 * @return {void}
 * @private
 */


function subscribeToOverlayChanges() {
  const setterKey = addPrefix('set');
  const propChanges = fromOlChangeEvent(this.$overlay, ['offset', 'position', 'positioning'], true, evt => ({ ...evt,
    setter: val => {
      const args = [val];

      if (evt.prop === 'position') {
        args.push(true);
      }

      this[setterKey(evt.prop)](...args);
    }
  }));
  this.subscribeTo(propChanges, _ref => {
    let {
      setter,
      value
    } = _ref;
    return setter(value);
  });
}

/* script */
const __vue_script__$e = script$e;
/* template */

var __vue_render__$1 = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.classes,
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", null, {
    "id": _vm.currentId,
    "position": _vm.currentPositionDataProj,
    "offset": _vm.currentOffset,
    "positioning": _vm.currentPositioning
  })], 2);
};

var __vue_staticRenderFns__$1 = [];
/* style */

const __vue_inject_styles__$e = undefined;
/* scoped */

const __vue_scope_id__$e = undefined;
/* module identifier */

const __vue_module_identifier__$e = undefined;
/* functional template */

const __vue_is_functional_template__$e = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$e = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$1,
  staticRenderFns: __vue_staticRenderFns__$1
}, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, false, undefined, undefined, undefined);

function plugin$f(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$f.installed) {
    return;
  }

  plugin$f.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$e, options);
  Vue.component(__vue_component__$e.name, __vue_component__$e);
}

var Overlay = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$f,
  install: plugin$f,
  Overlay: __vue_component__$e
});

var script$d = {
  name: 'VlInteractionRotate',
  mixins: [interaction, styleContainer],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    /**
     * Source or collection identifier from IdentityMap.
     * @type {String}
     */
    source: {
      type: String,
      required: true
    },
    angle: {
      type: Number,
      default: 0
    },
    anchor: {
      type: Array,
      validator: val => val.length >= 2
    },
    condition: {
      type: Function,
      default: always
    },
    allowAnchorMovement: {
      type: Boolean,
      default: true
    }
  },

  data() {
    return {
      currentAnchorViewProj: roundPointCoords(this.anchor),
      currentAngle: this.angle
    };
  },

  computed: {
    anchorDataProj() {
      return roundPointCoords(this.anchor);
    },

    anchorViewProj() {
      return this.pointToViewProj(this.anchor);
    },

    currentAnchorDataProj() {
      return this.pointToDataProj(this.currentAnchorViewProj);
    }

  },
  watch: {
    rev() {
      if (!this.$interaction) return;

      if (!isEqual(this.currentAnchorViewProj, this.$interaction.getAnchor())) {
        this.currentAnchorViewProj = this.$interaction.getAnchor();
      }

      if (this.currentAngle !== this.$interaction.getAngle()) {
        this.currentAngle = this.$interaction.getAngle();
      }
    },

    anchorViewProj: {
      deep: true,

      handler(value) {
        if (!value) return;
        this.setAnchor(value, true);
      }

    },
    currentAnchorDataProj: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.anchorDataProj)) return;
        this.$emit('update:anchor', value === null || value === void 0 ? void 0 : value.slice());
      }

    },

    angle(value) {
      this.setAngle(value);
    },

    currentAngle(value) {
      if (value === this.angle) return;
      this.$emit('update:angle', value);
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'condition', 'allowAnchorMovement'])
  },

  created() {
    var _this$anchorViewProj;

    this.currentAnchorViewProj = (_this$anchorViewProj = this.anchorViewProj) === null || _this$anchorViewProj === void 0 ? void 0 : _this$anchorViewProj.slice();
  },

  methods: {
    /**
     * @return {Promise<Modify>}
     * @protected
     */
    async createInteraction() {
      const source = this._source = await this.getInstance(this.source);
      assert(!!source, `Source "${this.source}" not found in identity map.`);
      let features;

      if (source instanceof Vector) {
        features = source.getFeaturesCollection();

        if (!features) {
          features = new Collection(source.getFeatures());
          this.subscribeTo(fromOlEvent(source, VectorEventType.ADDFEATURE), _ref => {
            let {
              feature
            } = _ref;
            return feature && features.push(feature);
          });
          this.subscribeTo(fromOlEvent(source, VectorEventType.REMOVEFEATURE), _ref2 => {
            let {
              feature
            } = _ref2;
            return feature && features.remove(feature);
          });
        }

        instanceOf(features, Collection, `Source "${this.source}" doesn't provide features collection.`);
      } else {
        if (isFunction(source.getFeaturesCollection)) {
          features = source.getFeaturesCollection();
        } else if (isFunction(source.getFeatures)) {
          features = source.getFeatures();
        }

        instanceOf(features, Collection, `Source "${this.source}" doesn't provide features collection.`);
      }

      return new RotateInteraction$1({
        features,
        angle: this.currentAngle,
        anchor: this.currentAnchorViewProj,
        allowAnchorMovement: this.allowAnchorMovement,
        condition: this.condition,
        style: this.$style
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @protected
     */
    subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      subscribeToInteractionChanges$2.call(this);
    },

    /**
     * @return {StyleTarget}
     * @protected
     */
    getStyleTarget() {
      return {
        getStyle: () => this._style,
        setStyle: () => {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log('style changed, scheduling recreate...');
          }

          this.scheduleRecreate();
        }
      };
    },

    getAngle() {
      var _this$$interaction;

      return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getAngle(), this.currentAngle);
    },

    setAngle(angle) {
      assert(isNumber(angle), 'Invalid angle');

      if (angle !== this.currentAngle) {
        this.currentAngle = angle;
      }

      if (this.$interaction && angle !== this.$interaction.getAngle()) {
        this.$interaction.setAngle(angle);
      }
    },

    getAnchor() {
      var _this$$interaction2;

      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const anchor = coalesce((_this$$interaction2 = this.$interaction) === null || _this$$interaction2 === void 0 ? void 0 : _this$$interaction2.getAnchor(), this.currentAnchorViewProj);
      return viewProj ? roundPointCoords(anchor) : this.pointToDataProj(anchor);
    },

    setAnchor(anchor) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isPointCoords(anchor), 'Invalid anchor');
      anchor = viewProj ? roundPointCoords(anchor) : this.pointToViewProj(anchor);

      if (!isEqual(anchor, this.currentAnchorViewProj)) {
        this.currentAnchorViewProj = anchor;
      }

      if (this.$interaction && !isEqual(anchor, this.$interaction.getAnchor())) {
        this.$interaction.setAnchor(anchor);
      }
    }

  }
};
/**
 * @private
 */

function subscribeToInteractionChanges$2() {
  const setterKey = addPrefix('set');
  const propChanges = fromOlChangeEvent(this.$interaction, ['angle', 'anchor'], true, evt => ({ ...evt,
    setter: val => {
      const args = [val];

      if (evt.prop === 'anchor') {
        args.push(true);
      }

      this[setterKey(evt.prop)](...args);
    }
  }));
  this.subscribeTo(propChanges, _ref3 => {
    let {
      setter,
      value
    } = _ref3;
    return setter(value);
  });
  const start = fromOlEvent(this.$interaction, 'rotatestart').pipe(tap(() => this.setInteracting(true)));
  const end = fromOlEvent(this.$interaction, 'rotateend').pipe(tap(() => this.setInteracting(false)));
  const progress = fromOlEvent(this.$interaction, 'rotating');
  const events = merge(start, end, progress).pipe(map(_ref4 => {
    let {
      type,
      features,
      angle,
      anchor
    } = _ref4;
    const viewProj = this.resolvedViewProjection;
    const dataProj = this.resolvedDataProjection;
    return {
      type,
      features: features instanceof Collection ? features.getArray() : features,
      angle,
      anchor: this.pointToDataProj(anchor),

      get json() {
        if (!this._json) {
          this._json = map$1(this.features, feature => writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION));
        }

        return this._json;
      }

    };
  }));
  this.subscribeTo(events, evt => this.$emit(evt.type, evt));
}

/* script */
const __vue_script__$d = script$d;
/* template */

/* style */

const __vue_inject_styles__$d = undefined;
/* scoped */

const __vue_scope_id__$d = undefined;
/* module identifier */

const __vue_module_identifier__$d = undefined;
/* functional template */

const __vue_is_functional_template__$d = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$d = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, false, undefined, undefined, undefined);

function plugin$e(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$e.installed) {
    return;
  }

  plugin$e.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$d, options);
  Vue.component(__vue_component__$d.name, __vue_component__$d);
}

var RotateInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$e,
  install: plugin$e,
  Interaction: __vue_component__$d
});

//
var script$c = {
  name: 'VlInteractionSelect',
  mixins: [featuresContainer, styleContainer, interaction],
  props: {
    /**
     * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.
     * @type {function|undefined}
     */
    filter: {
      type: Function,
      default: /*#__PURE__*/constant(true)
    },

    /**
     * A list of layers from which features should be selected. Alternatively, a filter function can be provided.
     * @type {string[]|function|undefined}
     */
    layers: {
      type: [Array, Function],
      default: undefined
    },

    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.
     * This only works for the canvas renderer and not for WebGL.
     * @type {number}
     */
    hitTolerance: {
      type: Number,
      default: 0
    },

    /**
     * A boolean that determines if the default behaviour should select only single features or all (overlapping)
     * features at the clicked map position.
     * @type {boolean}
     */
    multi: {
      type: Boolean,
      default: false
    },

    /**
     * Selected features as array of GeoJSON features with coordinates in the map view projection.
     * @type {string[]|number[]|Object[]}
     */
    features: {
      type: Array,
      default: stubArray,
      validator: value => value.every(or(isString, isNumber, isGeoJSONFeature))
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should
     * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events
     * for `add` and `remove` instead of `toggle`.
     * @type {function|undefined}
     */
    addCondition: {
      type: Function,
      default: never
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.
     * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature
     * removes all from the selection.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: singleClick
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`
     * instead of `toggle`.
     * @type {function|undefined}
     */
    removeCondition: {
      type: Function,
      default: never
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`
     * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,
     * and removes it if it is.
     * @type {function|undefined}
     */
    toggleCondition: {
      type: Function,
      default: shiftKeyOnly
    },
    useFeatureStyle: Boolean
  },

  data() {
    return {
      currentHitTolerance: this.hitTolerance
    };
  },

  computed: {
    featuresDataProj() {
      return map$1(this.features, feature => {
        if (isGeoJSONFeature(feature)) {
          feature = initializeFeature(clonePlainObject(feature));
        }

        return feature;
      });
    },

    featuresViewProj() {
      return map$1(this.features, feature => {
        if (isGeoJSONFeature(feature)) {
          feature = this.writeFeatureInViewProj(this.readFeatureInDataProj(feature));
        }

        return feature;
      });
    },

    currentFeaturesDataProj() {
      if (!this.rev) return [];
      return map$1(this.getFeatures(), feature => this.writeFeatureInDataProj(feature));
    },

    currentFeaturesViewProj() {
      if (!this.rev) return [];
      return map$1(this.getFeatures(), feature => this.writeFeatureInViewProj(feature));
    },

    currentFeatureIds() {
      return map$1(this.currentFeaturesDataProj, feature => getFeatureId(feature));
    },

    layerFilter() {
      return Array.isArray(this.layers) ? layer => this.layers.includes(getLayerId(layer)) : this.layers;
    },

    style() {
      if (!(this.rev && this.$style)) return;
      let style = this.$style;
      if (isFunction(style)) return style;
      if (!style) return;
      isArray(style) || (style = [style]);
      return style.map(style => dumpStyle(style, geom => this.writeGeometryInDataProj(geom)));
    }

  },
  watch: {
    rev() {
      if (!this.$interaction) return;

      if (this.currentHitTolerance !== this.$interaction.getHitTolerance()) {
        this.currentHitTolerance = this.$interaction.getHitTolerance();
      }
    },

    featuresViewProj: {
      deep: true,

      handler(features) {
        const ids = map$1(features, feature => isObjectLike(feature) ? getFeatureId(feature) : feature);
        if (isEqual(ids, this.currentFeatureIds)) return;
        this.unselectAll();
        forEach(features, this.select.bind(this));
      }

    },
    currentFeaturesDataProj: {
      deep: true,

      handler(value) {
        if (isEqual(value, this.featuresDataProj)) return;
        this.$emit('update:features', value && clonePlainObject(value));
      }

    },

    hitTolerance(value) {
      this.setHitTolerance(value);
    },

    currentHitTolerance(value) {
      if (value === this.hitTolerance) return;
      this.$emit('update:hitTolerance', value);
    },

    style: {
      deep: true,

      handler(value, prev) {
        if (isEqual(value, prev)) return;

        if (isPlainObject(value) || isArray(value)) {
          value = clonePlainObject(value);
        }

        this.$emit('update:style', value);
      }

    },
    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['filter', 'multi', 'wrapX', 'addCondition', 'condition', 'removeCondition', 'toggleCondition'])
  },
  methods: {
    /**
     * @return {Select}
     * @protected
     */
    createInteraction() {
      return new Select({
        multi: this.multi,
        filter: this.filter,
        layers: this.layerFilter,
        hitTolerance: this.currentHitTolerance,
        addCondition: this.addCondition,
        condition: this.condition,
        removeCondition: this.removeCondition,
        toggleCondition: this.toggleCondition,
        style: this.$style,
        features: this.$featuresCollection
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(interaction.methods.getServices.call(this), featuresContainer.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      featuresContainer.methods.subscribeAll.call(this);
      subscribeToInteractionChanges$1.call(this);
    },

    /**
     * @return {StyleTarget}
     * @protected
     */
    getStyleTarget() {
      return {
        getStyle: () => this._style,
        setStyle: () => {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log('style changed, scheduling recreate...');
          }

          this.scheduleRecreate();
        }
      };
    },

    /**
     * @return {StyleLike|undefined}
     */
    getStyle() {
      var _this$getStyleTarget;

      let style = coalesce((_this$getStyleTarget = this.getStyleTarget()) === null || _this$getStyleTarget === void 0 ? void 0 : _this$getStyleTarget.getStyle(), this._style);

      if (style === undefined && this.useFeatureStyle) {
        style = null; // disable ol/interaction/Select default styles
      }

      return style;
    },

    /**
     * @param {FeatureLike} feature
     */
    select(feature) {
      feature = this.resolveFeature(feature);
      if (!feature) return;
      this.addFeature(feature);
    },

    /**
     * @param {FeatureLike} feature
     */
    unselect(feature) {
      feature = this.resolveFeature(feature);
      if (!feature) return;
      this.removeFeature(feature);
    },

    /**
     * @return {void}
     */
    unselectAll() {
      this.clearFeatures();
    },

    /**
     * @param {Object|Vue|Feature|string|number} feature
     * @return {Feature|undefined}
     * @protected
     */
    resolveFeature(feature) {
      var _feature;

      if (!feature) return;
      feature = ((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature;
      if (feature instanceof Feature$1) return feature;
      const featureId = isString(feature) || isNumber(feature) ? feature : getFeatureId(feature);

      if (!featureId) {
        throw new Error(`${this.vmName} undefined feature id`);
      }

      feature = null;
      forEach(this.$mapVm.getLayers(), layer => {
        if (this.layerFilter && !this.layerFilter(layer)) {
          return;
        }

        const source = layer.getSource();

        if (isFunction(source === null || source === void 0 ? void 0 : source.getFeatureById)) {
          feature = source.getFeatureById(featureId);
        }

        return !feature;
      });
      return feature;
    },

    updateFeature(feature) {
      /* disable update here, because wil always work with origin feature */
    },

    getHitTolerance() {
      var _this$$interaction;

      return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getHitTolerance(), this.currentHitTolerance);
    },

    setHitTolerance(tolerance) {
      assert(isNumber(tolerance), 'Invalid tolerance');

      if (tolerance !== this.currentHitTolerance) {
        this.currentHitTolerance = tolerance;
      }

      if (this.$interaction && tolerance !== this.$interaction.getHitTolerance()) {
        this.$interaction.setHitTolerance(tolerance);
      }
    },

    async getLayer(feature) {
      feature = this.resolveFeature(feature);
      return (await this.resolveInteraction()).getLayer(feature);
    }

  }
};
/**
 * @return {void}
 * @private
 */

function subscribeToInteractionChanges$1() {
  const select = fromVueEvent(this, 'addfeature', evt => ({
    type: 'select',
    feature: evt.feature,

    get json() {
      return evt.json;
    }

  }));
  const unselect = fromVueEvent(this, 'removefeature', evt => ({
    type: 'unselect',
    feature: evt.feature,

    get json() {
      return evt.json;
    }

  }));
  const events = merge(select, unselect);
  this.subscribeTo(events, evt => this.$emit(evt.type, evt));
}

/* script */
const __vue_script__$c = script$c;
/* template */

var __vue_render__ = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", null, {
    "features": _vm.currentFeaturesDataProj
  })], 2);
};

var __vue_staticRenderFns__ = [];
/* style */

const __vue_inject_styles__$c = undefined;
/* scoped */

const __vue_scope_id__$c = undefined;
/* module identifier */

const __vue_module_identifier__$c = undefined;
/* functional template */

const __vue_is_functional_template__$c = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$c = /*#__PURE__*/normalizeComponent({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, false, undefined, undefined, undefined);

function plugin$d(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$d.installed) {
    return;
  }

  plugin$d.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$c, options);
  Vue.component(__vue_component__$c.name, __vue_component__$c);
}

var SelectInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$d,
  install: plugin$d,
  Interaction: __vue_component__$c
});

var script$b = {
  name: 'VlInteractionSnap',
  mixins: [interaction],
  props: {
    /**
     * Target source identifier from IdentityMap.
     * @type {string}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * Snap to edges
     * @type {boolean}
     */
    edge: {
      type: Boolean,
      default: true
    },

    /**
     * Snap to vertices.
     * @type {boolean}
     */
    vertex: {
      type: Boolean,
      default: true
    },

    /**
     * Pixel tolerance for considering the pointer close enough to a segment or vertex for snapping.
     * @type {number}
     */
    pixelTolerance: {
      type: Number,
      default: 10
    }
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'edge', 'vertex', 'pixelTolerance'])
  },
  methods: {
    /**
     * @return {Promise<Snap>}
     * @protected
     */
    async createInteraction() {
      let source = await this.getInstance(this.source);
      assert(!!source, `Source "${this.source}" not found in identity map.`);
      let features;

      if (!(source instanceof Vector)) {
        if (isFunction(source.getFeaturesCollection)) {
          features = source.getFeaturesCollection();
        } else if (isFunction(source.getFeatures)) {
          features = source.getFeatures();
        }

        instanceOf(features, Collection, `Source "${this.source}" doesn't provide features collection.`);
        source = null;
      }

      return new Snap({
        source,
        features,
        edge: this.edge,
        vertex: this.vertex,
        pixelTolerance: this.pixelTolerance
      });
    }

  }
};

/* script */
const __vue_script__$b = script$b;
/* template */

/* style */

const __vue_inject_styles__$b = undefined;
/* scoped */

const __vue_scope_id__$b = undefined;
/* module identifier */

const __vue_module_identifier__$b = undefined;
/* functional template */

const __vue_is_functional_template__$b = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$b = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, undefined, undefined, undefined);

function plugin$c(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$c.installed) {
    return;
  }

  plugin$c.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$b, options);
  Vue.component(__vue_component__$b.name, __vue_component__$b);
}

var SnapInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$c,
  install: plugin$c,
  Interaction: __vue_component__$b
});

const SPUTNIK_URL_TEMPLATE = 'http://tiles.maps.sputnik.ru/{z}/{x}/{y}.png?apikey={apikey}';
const SPUTNIK_ATTRIBUTIONS = '&copy; <a href="http://rt.ru/" target="_blank">Ростелеком</a>. ';
var script$a = {
  name: 'VlSourceSputnik',
  mixins: [xyzSource],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Source
    attributions: { ...source.props.attributions,
      default: SPUTNIK_ATTRIBUTIONS
    },
    // ol/source/UrlTile
    url: { ...urlTileSource.props.url,
      default: SPUTNIK_URL_TEMPLATE
    },

    /* eslint-enable vue/require-prop-types */
    // custom
    apiKey: {
      type: String
    }
  },
  computed: {
    /**
     * @type {string[]}
     */
    urlTokens() {
      return ['apiKey'];
    }

  }
};

/* script */
const __vue_script__$a = script$a;
/* template */

/* style */

const __vue_inject_styles__$a = undefined;
/* scoped */

const __vue_scope_id__$a = undefined;
/* module identifier */

const __vue_module_identifier__$a = undefined;
/* functional template */

const __vue_is_functional_template__$a = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$a = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, undefined, undefined, undefined);

function plugin$b(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$b.installed) {
    return;
  }

  plugin$b.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$a, options);
  Vue.component(__vue_component__$a.name, __vue_component__$a);
}

var SputnikSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$b,
  install: plugin$b,
  Source: __vue_component__$a
});

var script$9 = {
  name: 'VlSourceStamen',
  mixins: [xyzSource],
  props: {
    // ol/source/Stamen

    /**
     * Stamen layer name
     *
     * @type {string}
     */
    layer: {
      type: String,
      required: true
    }
  },
  computed: {
    tileGridIdent: noop,
    inputTileGridFactory: noop,
    inputTileUrlFunction: noop
  },
  methods: {
    createSource() {
      return new Stamen({
        // ol/source/Source
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        opaque: this.opaque,
        transition: this.transition,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        url: this.currentUrls[0],
        // ol/source/TileImage
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        imageSmoothing: this.imageSmoothing,
        // ol/source/XYZ
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        // ol/source/Stamen
        layer: this.layer
      });
    },

    inputUrlChanged(value) {
      this.setUrl(value);
    },

    attributionsCollapsibleChanged: noop,
    projectionChanged: noop,
    inputTileGridFactoryChanged: noop,
    tileGridChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop,
    crossOriginChanged: noop,
    tileClassChanged: noop
  }
};

/* script */
const __vue_script__$9 = script$9;
/* template */

/* style */

const __vue_inject_styles__$9 = undefined;
/* scoped */

const __vue_scope_id__$9 = undefined;
/* module identifier */

const __vue_module_identifier__$9 = undefined;
/* functional template */

const __vue_is_functional_template__$9 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$9 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, undefined, undefined, undefined);

function plugin$a(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$a.installed) {
    return;
  }

  plugin$a.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$9, options);
  Vue.component(__vue_component__$9.name, __vue_component__$9);
}

var StamenSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$a,
  install: plugin$a,
  Source: __vue_component__$9
});

/**
 * Style function component for advanced styling.
 * Plays the role of both a style that mounts itself to style target component (vl-layer-vector, vl-feature & etc.)
 * and style target for inner style containers (vl-style-box) as fallback style.
 */

var script$8 = {
  name: 'VlStyleFunc',
  mixins: [stubVNode, projTransforms, styleContainer, olCmp, waitForMap],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    /**
     * @type {function(): function(feature: Feature): Style}
     */
    function: {
      type: Function // required: true,

    },

    /**
     * @deprecated
     * @todo remove later
     */
    func: Function,

    /**
     * @deprecated Use `func` prop instead.
     * @todo remove in v0.13.x
     */
    factory: Function
  },

  data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857
    };
  },

  computed: {
    inputFunction() {
      let func = this.function || this.func;

      if (!func && this.factory) {
        func = this.factory();
      }

      return func;
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['inputFunction'])
  },

  created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.factory) {
        this.$logger.warn("'factory' prop is deprecated. Use 'function' prop instead.");
      }

      if (this.func) {
        this.$logger.warn("'func' prop is deprecated. Use 'function' prop instead.");
      }
    }

    defineServices.call(this);
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.factory) {
        this.$logger.warn("'factory' prop is deprecated. Use 'function' prop instead.");
      }

      if (this.func) {
        this.$logger.warn("'func' prop is deprecated. Use 'function' prop instead.");
      }
    }
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {function(feature: Feature): Style}
     * @protected
     */
    createOlObject() {
      // user provided style function
      const providedStyleFunc = this.inputFunction; // fallback style function made from inner style containers

      const fallbackStyleFunc = this.createStyleFunc(this.$style, this.getDefaultStyle());

      const func = function __styleFunc(feature, resolution) {
        const style = providedStyleFunc(feature, resolution); // not empty or null style

        if (style == null || Array.isArray(style) && style.length || style instanceof Style$1) {
          return style;
        }

        return fallbackStyleFunc(feature, resolution);
      };

      func.id = this.currentId;
      return func;
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$styleContainer;

      (_this$$styleContainer = this.$styleContainer) === null || _this$$styleContainer === void 0 ? void 0 : _this$$styleContainer.setStyle(this);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$styleContainer2;

      if (((_this$$styleContainer2 = this.$styleContainer) === null || _this$$styleContainer2 === void 0 ? void 0 : _this$$styleContainer2.getStyle()) === this.$styleFunction) {
        this.$styleContainer.setStyle(null);
      }

      return olCmp.methods.unmount.call(this);
    },

    /**
     * @protected
     */
    getStyleTarget() {
      return {
        getStyle: () => this._style,
        setStyle: async () => {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log('style changed, scheduling recreate...');
          }

          await this.scheduleRecreate();
        }
      };
    }

  }
};

function defineServices() {
  Object.defineProperties(this, {
    $styleFunction: {
      enumerable: true,
      get: () => this.$olObject
    },

    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.mapVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.viewVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $styleContainer: {
      enumerable: true,
      get: () => {
        var _this$$services3;

        return (_this$$services3 = this.$services) === null || _this$$services3 === void 0 ? void 0 : _this$$services3.styleContainer;
      }
    }
  });
}

/* script */
const __vue_script__$8 = script$8;
/* template */

/* style */

const __vue_inject_styles__$8 = undefined;
/* scoped */

const __vue_scope_id__$8 = undefined;
/* module identifier */

const __vue_module_identifier__$8 = undefined;
/* functional template */

const __vue_is_functional_template__$8 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$8 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, undefined, undefined, undefined);

function plugin$9(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$9.installed) {
    return;
  }

  plugin$9.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$8, options);
  Vue.component(__vue_component__$8.name, __vue_component__$8);
}

var StyleFunc = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$9,
  install: plugin$9,
  Style: __vue_component__$8
});

var script$7 = {
  name: 'VlSourceTileArcgisRest',
  mixins: [arcgisSource, tileImageSource],
  computed: {
    inputTileUrlFunction: noop
  },
  methods: {
    createSource() {
      return new TileArcGISRest({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        tileGrid: this.tileGrid,
        transition: this.transition,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        urls: this.currentUrls,
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        imageSmoothing: this.imageSmoothing,
        // ol/source/TileArcGISRest
        hidpi: this.hidpi,
        params: this.currentParams
      });
    },

    stateChanged: noop,
    attributionsCollapsibleChanged: noop,
    tileKeyChanged: noop,
    opaqueChanged: noop,
    tilePixelRatioChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop,
    tileClassChanged: noop
  }
};

/* script */
const __vue_script__$7 = script$7;
/* template */

/* style */

const __vue_inject_styles__$7 = undefined;
/* scoped */

const __vue_scope_id__$7 = undefined;
/* module identifier */

const __vue_module_identifier__$7 = undefined;
/* functional template */

const __vue_is_functional_template__$7 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$7 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, undefined, undefined, undefined);

function plugin$8(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$8.installed) {
    return;
  }

  plugin$8.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$7, options);
  Vue.component(__vue_component__$7.name, __vue_component__$7);
  Vue.component('VlSourceArcgisRest', {
    name: 'VlSourceArcgisRest',
    extends: __vue_component__$7,

    created() {
      if (process.env.NODE_ENV !== 'production') {
        this.$logger.warn('VlSourceArcgisRest component is deprecated. Use VlSourceTileArcgisRest component instead.');
      }
    }

  });
}

var TileArcgisRestSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$8,
  install: plugin$8,
  Source: __vue_component__$7
});

/**
 * Layer that provide pre-rendered, tiled images in grid that are organized by zoom levels for
 * specific resolutions. `vl-tile-layer` component implements a **source container** interface, so it should be
 * used together with tile-like `vl-source-*` components.
 */

var script$6 = {
  name: 'VlLayerTile',
  mixins: [tileLayer],
  methods: {
    /**
     * @return {Tile}
     * @protected
     */
    createLayer() {
      return new Tile({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseTile
        preload: this.currentPreload,
        useInterimTilesOnError: this.currentUseInterimTilesOnError
      });
    }

  }
};

/* script */
const __vue_script__$6 = script$6;
/* template */

/* style */

const __vue_inject_styles__$6 = undefined;
/* scoped */

const __vue_scope_id__$6 = undefined;
/* module identifier */

const __vue_module_identifier__$6 = undefined;
/* functional template */

const __vue_is_functional_template__$6 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$6 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

function plugin$7(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$7.installed) {
    return;
  }

  plugin$7.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$6, options);
  Vue.component(__vue_component__$6.name, __vue_component__$6);
}

var TileLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$7,
  install: plugin$7,
  Layer: __vue_component__$6
});

var script$5 = {
  name: 'VlSourceTileWms',
  mixins: [wmsSource, tileImageSource],
  props: {
    gutter: {
      type: Number,
      default: 0
    }
  },
  computed: {
    inputTileUrlFunction: noop
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['gutter'])
  },
  methods: {
    createSource() {
      return new TileWMS({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        tileGrid: this.tileGrid,
        transition: this.transition,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        urls: this.currentUrls,
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        tileClass: this.tileClass,
        imageSmoothing: this.imageSmoothing,
        // ol/source/TileWMS
        gutter: this.gutter,
        hidpi: this.hidpi,
        serverType: this.serverType,
        params: this.currentParams
      });
    },

    stateChanged: noop,
    attributionsCollapsibleChanged: noop,
    tileKeyChanged: noop,
    opaqueChanged: noop,
    tilePixelRatioChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop
  }
};

/* script */
const __vue_script__$5 = script$5;
/* template */

/* style */

const __vue_inject_styles__$5 = undefined;
/* scoped */

const __vue_scope_id__$5 = undefined;
/* module identifier */

const __vue_module_identifier__$5 = undefined;
/* functional template */

const __vue_is_functional_template__$5 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$5 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

function plugin$6(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$6.installed) {
    return;
  }

  plugin$6.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$5, options);
  Vue.component(__vue_component__$5.name, __vue_component__$5); // todo remove in v0.13.x

  Vue.component('VlSourceWms', {
    name: 'VlSourceWms',
    extends: __vue_component__$5,

    created() {
      if (process.env.NODE_ENV !== 'production') {
        this.$logger.warn('VlSourceWms component is deprecated. Use VlSourceTileWms component instead.');
      }
    }

  });
}

var TileWmsSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$6,
  install: plugin$6,
  Source: __vue_component__$5
});

var script$4 = {
  name: 'VlInteractionTranslate',
  mixins: [interaction],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    source: {
      type: String,
      required: true
    },
    layers: [String, Array],
    filter: Function,
    hitTolerance: {
      type: Number,
      default: 0
    }
  },

  data() {
    return {
      currentHitTolerance: this.hitTolerance
    };
  },

  computed: {
    inputFilter() {
      if (isFunction(this.filter)) return this.filter;
      let layers = this.layers;
      if (!layers) return;
      if (isString(layers)) layers = [layers];
      return (feature, layer) => layers.includes(getLayerId(layer));
    }

  },
  watch: {
    rev() {
      if (!this.$interaction) return;

      if (this.currentHitTolerance !== this.$interaction.getHitTolerance()) {
        this.currentHitTolerance = this.$interaction.getHitTolerance();
      }
    },

    hitTolerance(value) {
      this.setHitTolerance(value);
    },

    currentHitTolerance(value) {
      if (value === this.hitTolerance) return;
      this.$emit('update:hitTolerance', value);
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'inputFilter'])
  },
  methods: {
    /**
     * @return {Promise<Modify>}
     * @protected
     */
    async createInteraction() {
      const source = this._source = await this.getInstance(this.source);
      assert(!!source, `Source "${this.source}" not found in identity map.`);
      let features;

      if (source instanceof Vector) {
        features = source.getFeaturesCollection();

        if (!features) {
          features = new Collection(source.getFeatures());
          this.subscribeTo(fromOlEvent(source, VectorEventType.ADDFEATURE), _ref => {
            let {
              feature
            } = _ref;
            return feature && features.push(feature);
          });
          this.subscribeTo(fromOlEvent(source, VectorEventType.REMOVEFEATURE), _ref2 => {
            let {
              feature
            } = _ref2;
            return feature && features.remove(feature);
          });
        }

        instanceOf(features, Collection, `Source "${this.source}" doesn't provide features collection.`);
      } else {
        if (isFunction(source.getFeaturesCollection)) {
          features = source.getFeaturesCollection();
        } else if (isFunction(source.getFeatures)) {
          features = source.getFeatures();
        }

        instanceOf(features, Collection, `Source "${this.source}" doesn't provide features collection.`);
      }

      return new Translate({
        features,
        filter: this.inputFilter,
        hitTolerance: this.currentHitTolerance
      });
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      subscribeToInteractionChanges.call(this);
    },

    getHitTolerance() {
      var _this$$interaction;

      return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getHitTolerance(), this.currentHitTolerance);
    },

    setHitTolerance(tolerance) {
      assert(isNumber(tolerance), 'Invalid hit tolerance');

      if (tolerance !== this.currentHitTolerance) {
        this.currentHitTolerance = tolerance;
      }

      if (this.$interaction && tolerance !== this.$interaction.getHitTolerance()) {
        this.$interaction.setHitTolerance(tolerance);
      }
    }

  }
};
/**
 * @private
 */

function subscribeToInteractionChanges() {
  const start = fromOlEvent(this.$interaction, 'translatestart').pipe(tap(() => this.setInteracting(true)));
  const end = fromOlEvent(this.$interaction, 'translateend').pipe(tap(() => this.setInteracting(false)));
  const progress = fromOlEvent(this.$interaction, 'translating');
  const events = merge(start, end, progress).pipe(map(_ref3 => {
    let {
      type,
      features,
      coordinate,
      startCoordinate
    } = _ref3;
    const viewProj = this.resolvedViewProjection;
    const dataProj = this.resolvedDataProjection;
    return {
      type,
      features: features instanceof Collection ? features.getArray() : features,
      coordinate: this.pointToDataProj(coordinate),
      startCoordinate: this.pointToDataProj(startCoordinate),

      get json() {
        if (!this._json) {
          this._json = map$1(this.features, feature => writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION));
        }

        return this._json;
      }

    };
  }));
  this.subscribeTo(events, evt => this.$emit(evt.type, evt));
}

/* script */
const __vue_script__$4 = script$4;
/* template */

/* style */

const __vue_inject_styles__$4 = undefined;
/* scoped */

const __vue_scope_id__$4 = undefined;
/* module identifier */

const __vue_module_identifier__$4 = undefined;
/* functional template */

const __vue_is_functional_template__$4 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$4 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

function plugin$5(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$5.installed) {
    return;
  }

  plugin$5.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$4, options);
  Vue.component(__vue_component__$4.name, __vue_component__$4);
}

var TranslateInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$5,
  install: plugin$5,
  Interaction: __vue_component__$4
});

/**
 * Layer for data that is rendered client-side.
 */

var script$3 = {
  name: 'VlLayerVectorImage',
  mixins: [vectorLayer],
  props: {
    // ol/layer/VectorImage

    /**
     * @type {number}
     */
    imageRatio: {
      type: Number,
      default: 1
    }
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['imageRatio'])
  },
  methods: {
    /**
     * @return {VectorImageLayer}
     * @protected
     */
    createLayer() {
      return new VectorImage({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style,
        // ol/layer/VectorImage
        imageRatio: this.imageRatio
      });
    }

  }
};

/* script */
const __vue_script__$3 = script$3;
/* template */

/* style */

const __vue_inject_styles__$3 = undefined;
/* scoped */

const __vue_scope_id__$3 = undefined;
/* module identifier */

const __vue_module_identifier__$3 = undefined;
/* functional template */

const __vue_is_functional_template__$3 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$3 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

function plugin$4(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$4.installed) {
    return;
  }

  plugin$4.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$3, options);
  Vue.component(__vue_component__$3.name, __vue_component__$3);
}

var VectorImageLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$4,
  install: plugin$4,
  Layer: __vue_component__$3
});

const validateTileSize = /*#__PURE__*/or(isNumber, and(isArray, value => value.length === 2 && value.every(isNumber)));
var script$2 = {
  name: 'VlSourceVectorTile',
  mixins: [urlTileSource, featureHelper],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Tile
    cacheSize: { ...tileSource.props.cacheSize,
      default: 128
    },
    zDirection: { ...tileSource.props.zDirection,
      default: 1
    },

    /* eslint-enable vue/require-prop-types */
    // ol/source/VectorTile
    extent: {
      type: Array,
      validator: value => value.length === 4 && value.every(isNumber)
    },
    formatFactory: {
      type: Function,
      default: createMvtFmt
    },
    overlaps: {
      type: Boolean,
      default: true
    },
    tileClass: Function,
    maxZoom: {
      type: Number,
      default: 22
    },
    minZoom: {
      type: Number,
      default: 0,
      validator: value => value >= 0
    },
    maxResolution: Number,
    tileSize: {
      type: [Number, Array],
      default: () => [512, 512],
      validator: validateTileSize
    }
  },

  data() {
    return {
      format: undefined
    };
  },

  computed: {
    inputTileSize() {
      return isArray(this.tileSize) ? this.tileSize : [this.tileSize, this.tileSize];
    },

    derivedTileGridFactory() {
      if (isFunction(this.tileGridFactory)) {
        return this.tileGridFactory;
      }

      const extent = this.extentDataProj || extentFromProjection(this.resolvedDataProjection);
      const maxZoom = this.maxZoom;
      const minZoom = this.minZoom;
      const maxResolution = this.maxResolution;
      const tileSize = this.inputTileSize;
      return () => createXYZ({
        extent,
        maxZoom,
        minZoom,
        maxResolution,
        tileSize
      });
    },

    extentDataProj() {
      return roundExtent(this.extent);
    },

    extentViewProj() {
      return this.extentToViewProj(this.extent);
    },

    formatIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'format');
    },

    inputFormatFactory() {
      return sealFactory(this.formatFactory.bind(this));
    },

    inputTileUrlFunction() {
      const urlFunc = coalesce(this.tileUrlFunction, this.tileUrlFunc);
      if (isFunction(urlFunc)) return urlFunc;
      if (this.currentUrls.length === 0) return;
      return createTileUrlFunctionFromTemplates(this.currentUrls, this.tileGrid);
    }

  },
  watch: {
    formatIdent(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.format) {
        this.setInstance(value, this.format);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    },

    inputFormatFactory(value) {
      while (this.hasInstance(this.formatIdent)) {
        this.unsetInstance(this.formatIdent);
      }

      if (isFunction(value)) {
        this.format = this.instanceFactoryCall(this.formatIdent, value.bind(this));
      } else {
        this.format = undefined;
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['extentViewProj', 'overlaps', 'tileClass'], ['extentViewProj'])
  },

  created() {
    if (isFunction(this.inputFormatFactory)) {
      this.format = this.instanceFactoryCall(this.formatIdent, this.inputFormatFactory.bind(this));
    }
  },

  methods: {
    /**
     * @return {VectorTileSource}
     */
    createSource() {
      return new VectorTile$1({
        // ol/source/Source
        attributions: this.currentAttributions,
        attributionsCollapsible: this.attributionsCollapsible,
        projection: this.resolvedDataProjection,
        state: this.currentState,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        tileGrid: this.tileGrid,
        transition: this.transition,
        zDirection: this.zDirection,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        tileUrlFunction: this.currentTileUrlFunction,
        // ol/source/VectorTile
        format: this.format,
        extent: this.extentViewProj,
        overlaps: this.overlaps,
        tileClass: this.tileClass
      });
    },

    /**
     * @returns {void}
     */
    subscribeAll() {
      urlTileSource.methods.subscribeAll.call(this);
      subscribeToSourceEvents.call(this);
    },

    async getFeaturesInExtent(extent) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);
      return (await this.resolveSource()).getFeaturesInExtent(extent);
    },

    async clear() {
      (await this.resolveSource()).clear();
    },

    tileKeyChanged: noop,
    opaqueChanged: noop,
    tilePixelRatioChanged: noop
  }
};

function subscribeToSourceEvents() {
  this.subscribeTo(fromOlEvent(this.$source, TileEventType.TILELOADEND), evt => {
    if (!evt.tile) return;
    forEach(evt.tile.getFeatures(), feature => {
      if (!(feature instanceof Feature$1)) return;
      this.initializeFeature(feature);
    });
  });
}

/* script */
const __vue_script__$2 = script$2;
/* template */

/* style */

const __vue_inject_styles__$2 = undefined;
/* scoped */

const __vue_scope_id__$2 = undefined;
/* module identifier */

const __vue_module_identifier__$2 = undefined;
/* functional template */

const __vue_is_functional_template__$2 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$2 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

function plugin$3(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$3.installed) {
    return;
  }

  plugin$3.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$2, options);
  Vue.component(__vue_component__$2.name, __vue_component__$2);
}

var VectorTileSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$3,
  install: plugin$3,
  Source: __vue_component__$2
});

var script$1 = {
  name: 'VlSourceWmts',
  mixins: [tileImageSource],
  props: {
    // ol/source/WMTS
    layerName: {
      type: String,
      required: true
    },
    styleName: {
      type: String,
      required: true
    },
    matrixSet: {
      type: String,
      required: true
    },
    dimensions: Object,
    format: {
      type: String,
      default: 'image/jpeg'
    },
    requestEncoding: {
      type: String,
      default: 'KVP'
    },
    version: {
      type: String,
      default: '1.0.0'
    },
    // custom
    extent: {
      type: Array,
      validator: value => value.length === 4 && value.every(isNumber)
    },
    resolutions: {
      type: Array,
      validator: value => value.every(isNumber)
    },
    origin: {
      type: Array,
      validator: value => value.length === 2 && value.every(isNumber)
    },
    matrixIds: {
      type: Array,
      validator: value => value.every(or(isNumber, isString))
    },
    maxZoom: {
      type: Number,
      default: DEFAULT_MAX_ZOOM
    },
    minZoom: {
      type: Number,
      default: 0
    },
    tileSize: {
      type: [Number, Array],
      default: () => [DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE]
    }
  },
  computed: {
    extentDataProj() {
      return roundExtent(this.extent);
    },

    extentViewProj() {
      return this.extentToViewProj(this.extent);
    },

    originDataProj() {
      return roundPointCoords(this.origin);
    },

    originViewProj() {
      return this.pointToViewProj(this.origin);
    },

    inputTileSize() {
      return isArray(this.tileSize) ? this.tileSize : [this.tileSize, this.tileSize];
    },

    derivedTileGridFactory() {
      if (isFunction(this.tileGridFactory)) {
        return this.tileGridFactory;
      }

      const extent = this.extentDataProj || extentFromProjection(this.resolvedDataProjection);
      const resolutions = this.resolutions || resolutionsFromExtent(extent, this.maxZoom, this.inputTileSize);
      const origin = this.originDataProj || getCorner(extent, ExtentCorner.TOP_LEFT);
      const matrixIds = this.matrixIds || range(this.minZoom, resolutions.length);
      const tileSize = this.inputTileSize;
      const minZoom = this.minZoom;
      return () => new WMTSTileGrid({
        extent,
        origin,
        resolutions,
        minZoom,
        matrixIds,
        tileSize
      });
    },

    inputTileUrlFunction: noop
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['dimensions', 'format', 'layerName', 'styleName', 'matrixSet', 'requestEncoding', 'version'], ['dimensions'])
  },
  methods: {
    /**
     * @returns {WMTS}
     * @protected
     */
    createSource() {
      return new WMTS({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        tileGrid: this.tileGrid,
        tilePixelRatio: this.tilePixelRatio,
        transition: this.transition,
        zDirection: this.zDirection,
        // ol/source/UrlTile
        urls: this.currentUrls,
        tileLoadFunction: this.currentTileLoadFunction,
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        tileClass: this.tileClass,
        imageSmoothing: this.imageSmoothing,
        // ol/source/WMTS
        dimensions: this.dimensions,
        format: this.format,
        layer: this.layerName,
        style: this.styleName,
        matrixSet: this.matrixSet,
        requestEncoding: this.requestEncoding,
        version: this.version
      });
    },

    getDimensions() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getDimensions(), this.dimensions);
    },

    getFormat() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getFormat(), this.format);
    },

    getLayer() {
      var _this$$source3;

      return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.getLayer(), this.layerName);
    },

    getMatrixSet() {
      var _this$$source4;

      return coalesce((_this$$source4 = this.$source) === null || _this$$source4 === void 0 ? void 0 : _this$$source4.getMatrixSet(), this.matrixSet);
    },

    getRequestEncoding() {
      var _this$$source5;

      return coalesce((_this$$source5 = this.$source) === null || _this$$source5 === void 0 ? void 0 : _this$$source5.getRequestEncoding(), this.requestEncoding);
    },

    getStyle() {
      var _this$$source6;

      return coalesce((_this$$source6 = this.$source) === null || _this$$source6 === void 0 ? void 0 : _this$$source6.getStyle(), this.styleName);
    },

    getVersion() {
      var _this$$source7;

      return coalesce((_this$$source7 = this.$source) === null || _this$$source7 === void 0 ? void 0 : _this$$source7.getVersion(), this.version);
    },

    attributionsCollapsibleChanged: noop,
    stateChanged: noop,
    tileKeyChanged: noop,
    opaqueChanged: noop,
    inputTileUrlFunctionChanged: noop
  }
};

function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;
  const height = getHeight(extent);
  const width = getWidth(extent);
  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);

  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }

  return resolutions;
}

/* script */
const __vue_script__$1 = script$1;
/* template */

/* style */

const __vue_inject_styles__$1 = undefined;
/* scoped */

const __vue_scope_id__$1 = undefined;
/* module identifier */

const __vue_module_identifier__$1 = undefined;
/* functional template */

const __vue_is_functional_template__$1 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$1 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

function plugin$2(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$2.installed) {
    return;
  }

  plugin$2.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$1, options);
  Vue.component(__vue_component__$1.name, __vue_component__$1);
}

var WmtsSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$2,
  install: plugin$2,
  Source: __vue_component__$1
});

var script = {
  name: 'VlSourceXyz',
  mixins: [xyzSource]
};

/* script */
const __vue_script__ = script;
/* template */

/* style */

const __vue_inject_styles__ = undefined;
/* scoped */

const __vue_scope_id__ = undefined;
/* module identifier */

const __vue_module_identifier__ = undefined;
/* functional template */

const __vue_is_functional_template__ = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__ = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

function plugin$1(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$1.installed) {
    return;
  }

  plugin$1.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__, options);
  Vue.component(__vue_component__.name, __vue_component__);
}

var XyzSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$1,
  install: plugin$1,
  Source: __vue_component__
});

/**
 * @const {string} VueLayers version.
 */

const VERSION = '0.12.7';
/**
 * @typedef {Object} VueLayersOptions
 * @property {string} [dataProjection] Projection for all properties, events and other plain values.
 */

/**
 * Registers all VueLayers components.
 * @param {Vue|VueConstructor} Vue
 * @param {VueLayersOptions} [options]
 */

function plugin(Vue) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin.installed) {
    return;
  }

  plugin.installed = true; // install components

  Vue.use(BingmapsSource, options);
  Vue.use(ClusterSource, options);
  Vue.use(DrawInteraction, options);
  Vue.use(Feature, options);
  Vue.use(Geoloc, options);
  Vue.use(GraticuleLayer, options);
  Vue.use(GroupLayer, options);
  Vue.use(HeatmapLayer, options);
  Vue.use(ImageArcgisRestSource, options);
  Vue.use(ImageLayer, options);
  Vue.use(ImageStaticSource, options);
  Vue.use(ImageWmsSource, options);
  Vue.use(Map, options);
  Vue.use(MapboxSource, options);
  Vue.use(MapboxVectorLayer, options);
  Vue.use(ModifyInteraction, options);
  Vue.use(OsmSource, options);
  Vue.use(Overlay, options);
  Vue.use(RotateInteraction, options);
  Vue.use(SelectInteraction, options);
  Vue.use(SnapInteraction, options);
  Vue.use(SputnikSource, options);
  Vue.use(StamenSource, options);
  Vue.use(Style, options);
  Vue.use(StyleFunc, options);
  Vue.use(TileArcgisRestSource, options);
  Vue.use(TileLayer, options);
  Vue.use(TileWmsSource, options);
  Vue.use(TranslateInteraction, options);
  Vue.use(VectorImageLayer, options);
  Vue.use(VectorLayer, options);
  Vue.use(VectorSource, options);
  Vue.use(VectorTileLayer, options);
  Vue.use(VectorTileSource, options);
  Vue.use(WmtsSource, options);
  Vue.use(XyzSource, options);
}

export { BingmapsSource, ClusterSource, DrawInteraction, Feature, Geoloc, GraticuleLayer, GroupLayer, HeatmapLayer, ImageArcgisRestSource, ImageLayer, ImageStaticSource, ImageWmsSource, Map, MapboxSource, MapboxVectorLayer, ModifyInteraction, OsmSource, Overlay, RotateInteraction, SelectInteraction, SnapInteraction, SputnikSource, StamenSource, Style, StyleFunc, TileArcgisRestSource, TileLayer, TileWmsSource, TranslateInteraction, VERSION, VectorImageLayer, VectorLayer, VectorSource, VectorTileLayer, VectorTileSource, WmtsSource, XyzSource, plugin as default, plugin as install };
//# sourceMappingURL=vuelayers.esm.js.map
