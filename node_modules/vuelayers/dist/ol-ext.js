/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.12.7
 * @license MIT
 * @copyright (c) 2017-2023, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import { Control } from 'ol/control';
import { v4 } from 'uuid';
import { round, isEqual, and, isArray, every, isNumber, assert, isPlainObject, addPrefix, reduce, isNumeric, isFunction, filter, identity, noop, clonePlainObject, omit, map } from './utils';
import { getBottomLeft, getBottomRight, getTopLeft, getTopRight } from 'ol/extent';
import { Feature, PluggableMap, Overlay, View } from 'ol';
import { MVT, GeoJSON as GeoJSON$1 } from 'ol/format';
import { Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection, Circle, Geometry } from 'ol/geom';
import { isEmpty as isEmpty$1 } from 'ol/obj';
import { getLength } from 'ol/sphere';
import pointOnFeature from '@turf/point-on-feature';
import { circular } from 'ol/geom/Polygon';
import { toLonLat, fromLonLat, transform as transform$1, transformExtent as transformExtent$1, get } from 'ol/proj';
import { Style, Fill, Stroke, Image, Text, RegularShape, Circle as Circle$1, Icon } from 'ol/style';
import parseColor from 'parse-color';
import { Interaction } from 'ol/interaction';
import BaseLayer from 'ol/layer/Base';
import { Source } from 'ol/source';
import Units, { METERS_PER_UNIT } from 'ol/proj/Units';

function getControlId(control) {
  if (control instanceof Control) {
    return control.get('id');
  }

  throw new Error('Illegal control argument');
}
function setControlId(control, controlId) {
  if (control instanceof Control) {
    control.set('id', controlId);
    return control;
  }

  throw new Error('Illegal control argument');
}
function initializeControl(control, defaultControlId) {
  if (getControlId(control) == null) {
    setControlId(control, defaultControlId || v4());
  }

  return control;
}

const GeometryType = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};
const ExtentCorner = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};
const OverlayPositioning = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_CENTER: 'bottom-center',
  BOTTOM_RIGHT: 'bottom-right',
  CENTER_LEFT: 'center-left',
  CENTER_CENTER: 'center-center',
  CENTER_RIGHT: 'center-right',
  TOP_LEFT: 'top-left',
  TOP_CENTER: 'top-center',
  TOP_RIGHT: 'top-right'
};
const SourceState = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};
const WMSServerType = {
  /**
   * HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
   * @api
   */
  CARMENTA_SERVER: 'carmentaserver',

  /**
   * HiDPI support for [GeoServer](https://geoserver.org/)
   * @api
   */
  GEOSERVER: 'geoserver',

  /**
   * HiDPI support for [MapServer](https://mapserver.org/)
   * @api
   */
  MAPSERVER: 'mapserver',

  /**
   * HiDPI support for [QGIS](https://qgis.org/)
   * @api
   */
  QGIS: 'qgis'
};

const COORD_PRECISION = 6;
function roundExtent(extent) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!extent) return;
  return extent.map(x => round(x, precision));
}
function roundPointCoords(coordinates) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(x => round(x, precision));
}
function roundLineCoords(coordinates) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(point => roundPointCoords(point, precision));
}
function roundPolygonCoords(coordinates) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(line => roundLineCoords(line, precision));
}
function roundMultiPointCoords(coordinates) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  return roundLineCoords(coordinates, precision);
}
function roundMultiLineCoords(coordinates) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  return roundPolygonCoords(coordinates, precision);
}
function roundMultiPolygonCoords(coordinates) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(polygon => roundPolygonCoords(polygon, precision));
}
function roundCoords(geomType, coordinates) {
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;

  switch (geomType) {
    case GeometryType.POINT:
    case GeometryType.CIRCLE:
      return roundPointCoords(coordinates, precision);

    case GeometryType.LINE_STRING:
    case GeometryType.MULTI_POINT:
      return roundLineCoords(coordinates, precision);

    case GeometryType.POLYGON:
    case GeometryType.MULTI_LINE_STRING:
      return roundPolygonCoords(coordinates, precision);

    case GeometryType.MULTI_POLYGON:
      return roundMultiPolygonCoords(coordinates, precision);
  }
}
function flatCoords(geomType, coordinates) {
  const polygonReducer = (coords, lineString) => coords.concat(lineString);

  switch (geomType) {
    case GeometryType.POINT:
      return [coordinates];

    case GeometryType.LINE_STRING:
    case GeometryType.MULTI_POINT:
      return coordinates;

    case GeometryType.POLYGON:
    case GeometryType.MULTI_LINE_STRING:
      return coordinates.reduce(polygonReducer, []);

    case GeometryType.MULTI_POLYGON:
      return coordinates.reduce((coords, polygon) => coords.concat(polygon.reduce(polygonReducer, [])), []);

    default:
      // todo maybe return null?
      return [];
  }
}
/**
 * @param {{coordinates: number[], extent: number[]}} a
 * @param {{coordinates: number[], extent: number[]}} b
 * @returns {boolean}
 */

function isEqualCoord(a, b) {
  return isEqual(a.extent, b.extent) ? isEqual(a.coordinates, b.coordinates) : false;
}
function calcDistance(point1, point2) {
  const dx = point2[0] - point1[0];
  const dy = point2[1] - point1[1];
  const squared = dx * dx + dy * dy;
  return round(Math.sqrt(squared), COORD_PRECISION);
}
const isPointCoords = /*#__PURE__*/and(isArray, point => point.length >= 2, point => every(point, isNumber));
const isLineCoords = /*#__PURE__*/and(isArray, line => line.length >= 0, line => every(line, isPointCoords));
const isPolygonCoords = /*#__PURE__*/and(isArray, polygon => polygon.length >= 0, polygon => every(polygon, isLineCoords));
const isMultiPointCoords = isLineCoords;
const isMultiLineCoords = isPolygonCoords;
const isMultiPolygonCoords = /*#__PURE__*/and(isArray, multiPolygon => multiPolygon.length >= 0, multiPolygon => every(multiPolygon, isPolygonCoords));

// copy-paste from ol/extent
function createOrUpdate(minX, minY, maxX, maxY, extent) {
  if (extent) {
    extent[0] = minX;
    extent[1] = minY;
    extent[2] = maxX;
    extent[3] = maxY;
    return extent;
  }

  return [minX, minY, maxX, maxY];
}
function getCorner(extent, corner) {
  let coordinate;

  if (corner === ExtentCorner.BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === ExtentCorner.BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === ExtentCorner.TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === ExtentCorner.TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    assert(false, 'Invalid extent corner');
  }

  return coordinate;
}

/**
 * @param {number|number[]} lonOrCoordinates
 * @param {number} [lat]
 * @return {Point}
 */

function createPointGeom(lonOrCoordinates, lat) {
  const coordinates = Array.isArray(lonOrCoordinates) ? lonOrCoordinates : [lonOrCoordinates, lat];
  return new Point(coordinates);
}
/**
 * @param {Array<number[]>} points
 * @returns {LineString}
 */

function createLineGeom(points) {
  return new LineString(points);
}
/**
 * @param {Array<Array<number[]>>} rings
 * @returns {Polygon}
 */

function createPolygonGeom(rings) {
  return new Polygon(rings);
}
/**
 * @param {Array<number[]>} points
 * @returns {MultiPoint}
 */

function createMultiPointGeom(points) {
  return new MultiPoint(points);
}
/**
 * @param {Array<Array<number[]>>} lines
 * @returns {MultiLineString}
 */

function createMultiLineGeom(lines) {
  return new MultiLineString(lines);
}
/**
 * @param {Array<Array<Array<number[]>>>} polygons
 * @returns {MultiPolygon}
 */

function createMultiPolygonGeom(polygons) {
  return new MultiPolygon(polygons);
}
/**
 * @param {Geometry[]} geoms
 * @returns {GeometryCollection}
 */

function createGeomCollection(geoms) {
  return new GeometryCollection(geoms);
}
/**
 * @param {Coordinate|number[]} center
 * @param {number} radius
 * @return {Polygon}
 */

function createCircularPolygon(center, radius) {
  return circular(center, radius);
}
/**
 * @param {Geometry|Object} geom
 * @return {boolean}
 * @throws {Error}
 */

function isMultiGeom(geom) {
  const multiTypes = [GeometryType.MULTI_POINT, GeometryType.MULTI_LINE_STRING, GeometryType.MULTI_POLYGON, GeometryType.GEOMETRY_COLLECTION];
  return multiTypes.includes(geom.type || geom.getType());
}
/**
 * @param {Geometry|Object} geom
 * @return {SimpleGeometry|Object}
 * @throws {Error}
 */

function toSimpleGeom(geom) {
  if (geom instanceof Circle) {
    geom = createPointGeom(geom.getCenter());
  } else if (geom.type === GeometryType.CIRCLE) {
    geom = { ...geom,
      type: GeometryType.POINT
    };
  }

  const type = geom.type || geom.getType();
  const complexTypes = [GeometryType.GEOMETRY_COLLECTION];

  if (complexTypes.includes(type) === false) {
    return geom;
  }

  return (geom.geometries || geom.getGeometries())[0];
}
/**
 * @param {Geometry|Object} geom
 * @param {number} [precision=COORD_PRECISION]
 * @return {Coordinate|undefined}
 */

function findPointOnSurface(geom) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  const simpleGeom = toSimpleGeom(geom);
  const pointFeature = pointOnFeature({
    type: simpleGeom.type || simpleGeom.getType(),
    coordinates: simpleGeom.coordinates || simpleGeom.getCoordinates()
  });

  if (pointFeature !== null && pointFeature !== void 0 && pointFeature.geometry) {
    return roundCoords(pointFeature.geometry.type, pointFeature.geometry.coordinates, precision);
  }
}
function getGeometryId(geometry) {
  if (geometry instanceof Geometry) {
    return geometry.get('id');
  } else if (isPlainObject(geometry)) {
    return geometry.id;
  }

  throw new Error('Illegal geometry argument');
}
function setGeometryId(geometry, geometryId) {
  if (geometry instanceof Geometry) {
    geometry.set('id', geometryId);
    return geometry;
  } else if (isPlainObject(geometry)) {
    geometry.id = geometryId;
    return geometry;
  }

  throw new Error('Illegal geometry argument');
}
function initializeGeometry(geometry, defaultGeometryId) {
  if (getGeometryId(geometry) == null) {
    setGeometryId(geometry, defaultGeometryId || v4());
  }

  return geometry;
}
/**
 * @param value
 * @return {boolean}
 */

function isCircleGeom(value) {
  return getGeomType(value) === GeometryType.CIRCLE;
}
function getGeomCoords(geom) {
  if (!geom) return;
  const type = getGeomType(geom);

  switch (type) {
    case GeometryType.CIRCLE:
      return roundCoords(type, geom.coordinates || geom.getCenter());

    default:
      return roundCoords(type, geom.coordinates || geom.getCoordinates());
  }
}
function getGeomType(geom) {
  if (geom instanceof Geometry) {
    return geom.getType();
  }

  return geom === null || geom === void 0 ? void 0 : geom.type;
}

const EPSG_4326 = 'EPSG:4326';
const EPSG_3857 = 'EPSG:3857';
/**
 * @param {number[]} coordinate
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Coordinate|number[]}
 */

function pointToLonLat(coordinate) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinate) return;
  return roundCoords(GeometryType.POINT, toLonLat(coordinate, projection), precision);
}
/**
 * @param {number[]} coordinate
 * @param {module:ol/proj.ProjectionLike} [projection]
 * @param {number} [precision=COORD_PRECISION]
 * @return {number[]}
 */

function pointFromLonLat(coordinate) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinate) return;
  return roundCoords(GeometryType.POINT, fromLonLat(coordinate, projection), precision);
}
/**
 * @param {number[]} coordinate
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @returns {number[]}
 */

function transformPoint(coordinate, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinate) return;
  return transform(coordinate, sourceProjection, destProjection, precision);
}
/**
 * @param {number[]} coordinate
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @returns {number[]}
 */

function transform(coordinate, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinate) return;
  let coord = transform$1(coordinate, sourceProjection, destProjection);

  if (coord.some(x => isNaN(x))) {
    coord = transform$1(transform$1(coordinate, sourceProjection, EPSG_4326), EPSG_4326, destProjection);
  }

  return roundCoords(GeometryType.POINT, coord, precision);
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function lineToLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(point => pointToLonLat(point, projection, precision));
}
/**
 * @param {Array<number[]>} coordinates
 * @param {ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function lineFromLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(point => pointFromLonLat(point, projection, precision));
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @returns {number[]}
 */

function transformLine(coordinates, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(point => transformPoint(point, sourceProjection, destProjection, precision));
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function polygonToLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(line => lineToLonLat(line, projection, precision));
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function polygonFromLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(line => lineFromLonLat(line, projection, precision));
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @returns {*}
 */

function transformPolygon(coordinates, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(line => transformLine(line, sourceProjection, destProjection, precision));
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function multiPointToLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(point => pointToLonLat(point, projection, precision));
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function multiPointFromLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(point => pointFromLonLat(point, projection, precision));
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function transformMultiPoint(coordinates, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(point => transformPoint(point, sourceProjection, destProjection, precision));
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function multiLineToLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(line => lineToLonLat(line, projection, precision));
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function multiLineFromLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(line => lineFromLonLat(line, projection, precision));
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function transformMultiLine(coordinates, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(line => transformLine(line, sourceProjection, destProjection, precision));
}
/**
 * @param {Array<Array<Array<number[]>>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<Array<number[]>>>}
 */

function multiPolygonToLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(polygon => polygonToLonLat(polygon, projection, precision));
}
/**
 * @param {Array<Array<Array<number[]>>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<Array<number[]>>>}
 */

function multiPolygonFromLonLat(coordinates) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(polygon => polygonFromLonLat(polygon, projection, precision));
}
/**
 * @param {Array<Array<Array<number[]>>>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<Array<number[]>>>}
 */

function transformMultiPolygon(coordinates, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(polygon => transformPolygon(polygon, sourceProjection, destProjection, precision));
}
/**
 * Transforms by geom type
 * @type {Object<string, function>}
 */

const transforms = {
  [GeometryType.POINT]: {
    toLonLat: pointToLonLat,
    fromLonLat: pointFromLonLat,
    transform: transformPoint
  },
  [GeometryType.LINE_STRING]: {
    toLonLat: lineToLonLat,
    fromLonLat: lineFromLonLat,
    transform: transformLine
  },
  [GeometryType.POLYGON]: {
    toLonLat: polygonToLonLat,
    fromLonLat: polygonFromLonLat,
    transform: transformPolygon
  },
  [GeometryType.MULTI_POINT]: {
    toLonLat: multiPointToLonLat,
    fromLonLat: multiPointFromLonLat,
    transform: transformMultiPoint
  },
  [GeometryType.MULTI_LINE_STRING]: {
    toLonLat: multiLineToLonLat,
    fromLonLat: multiLineFromLonLat,
    transform: transformMultiLine
  },
  [GeometryType.MULTI_POLYGON]: {
    toLonLat: multiPolygonToLonLat,
    fromLonLat: multiPolygonFromLonLat,
    transform: transformMultiPolygon
  },
  [GeometryType.CIRCLE]: {
    toLonLat: pointToLonLat,
    fromLonLat: pointFromLonLat,
    transform: transformPoint
  }
};
/**
 * @param {number[]} extent
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @return {number[]}
 */

function transformExtent(extent, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!extent) return;
  if (extent.every(x => !isFinite(x))) return extent;
  let ext = transformExtent$1(extent, sourceProjection, destProjection);

  if (ext.some(x => isNaN(x))) {
    ext = transformExtent$1(transformExtent$1(extent, sourceProjection, EPSG_4326), EPSG_4326, destProjection);
  }

  return roundExtent(ext, precision);
}
/**
 * @param {number[]} extent
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG:3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {number[]}
 */

function extentFromLonLat(extent) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!extent) return;
  return transformExtent(extent, EPSG_4326, projection, precision);
}
/**
 * @param {number[]} extent
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG:3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {number[]}
 */

function extentToLonLat(extent) {
  let projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!extent) return;
  return transformExtent(extent, projection, EPSG_4326, precision);
}
function transformDistance(distance, sourceProjection, destProjection) {
  let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!distance) return;
  const line = transformLine([[0, 0], [distance, 0]], sourceProjection, destProjection, precision);
  return calcDistance(line[0], line[1]);
}

function isStyle(style) {
  return style instanceof Style || style instanceof Image || style instanceof Fill || style instanceof Stroke || style instanceof Text || style instanceof Function;
}

function getStyleId(style) {
  if (isStyle(style)) {
    return style.id;
  }

  throw new Error('Illegal style argument');
}
function setStyleId(style, styleId) {
  if (isStyle(style)) {
    style.id = styleId;
    return style;
  }

  throw new Error('Illegal style argument');
}
function initializeStyle(style, defaultStyleId) {
  if (getStyleId(style) == null) {
    setStyleId(style, defaultStyleId || v4());
  }

  return style;
}
/**
 * @return {VlStyle[]}
 */

function defaultStyle() {
  return [{
    fillColor: [255, 255, 255, 0.4],
    strokeColor: '#3399cc',
    strokeWidth: 1.25,
    imageRadius: 5
  }];
}
/**
 * @return {Object<GeometryType, VlStyle[]>}
 */

function defaultEditStyle() {
  /** @type {Object<GeometryType, VlStyle[]>} */
  const styles = {};
  const white = [255, 255, 255, 1];
  const blue = [0, 153, 255, 1];
  const width = 3;
  styles[GeometryType.LINE_STRING] = [{
    strokeColor: white,
    strokeWidth: width + 2
  }, {
    strokeColor: blue,
    strokeWidth: width
  }];
  styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
  styles[GeometryType.POLYGON] = [{
    fillColor: [255, 255, 255, 0.5]
  }].concat(styles[GeometryType.LINE_STRING]);
  styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
  styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);
  styles[GeometryType.POINT] = [{
    imageRadius: width * 2,
    fillColor: blue,
    strokeColor: white,
    strokeWidth: width / 2,
    zIndex: Infinity
  }];
  styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
  styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
  return styles;
}

const isEmpty = x => {
  if (x == null) return true;
  if (typeof x === 'number') return false;
  return (typeof x === 'string' || Array.isArray(x)) && !x.length || !Object.keys(x).length;
};
/**
 * @param {VlStyle} vlStyle
 * @param {function} [geomReader=identity]
 * @return {Style|undefined}
 */


function createStyle(vlStyle) {
  let geomReader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  if (isEmpty(vlStyle)) return;
  const olStyle = {
    text: createTextStyle(vlStyle, 'text'),
    fill: createFillStyle(vlStyle, 'fill'),
    stroke: createStrokeStyle(vlStyle, 'stroke'),
    image: createImageStyle(vlStyle, 'image'),
    geometry: createGeomStyle(vlStyle, geomReader),
    zIndex: vlStyle.zIndex,
    renderer: vlStyle.renderer
  };

  if (!isEmpty(olStyle)) {
    return new Style(olStyle);
  }
}
/**
 * @param {*} color
 * @returns {*}
 */

function normalizeColor(color) {
  let c = color;

  if (typeof color === 'string') {
    c = parseColor(color).rgba;
  }

  return c;
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Fill|undefined}
 */

function createFillStyle(vlStyle) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  const prefixKey = addPrefix(prefix); // check on already compiled style existence

  if (vlStyle[prefixKey()] instanceof Fill) return vlStyle[prefixKey()];
  const keys = ['color'].reduce((keys, key) => ({ ...keys,
    [prefixKey(key)]: key
  }), {});
  const fillStyle = reduce(vlStyle, (style, value, name) => {
    if (!keys[name] || value == null) return style;

    switch (keys[name]) {
      case 'color':
        value = normalizeColor(value);
        break;
    }

    style[keys[name]] = value;
    return style;
  }, {});

  if (!isEmpty(fillStyle)) {
    return new Fill(fillStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Stroke|undefined}
 */

function createStrokeStyle(vlStyle) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  const prefixKey = addPrefix(prefix);
  if (vlStyle[prefixKey()] instanceof Stroke) return vlStyle[prefixKey()];
  const keys = ['color', 'width', 'miterLimit', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset'].reduce((keys, key) => ({ ...keys,
    [prefixKey(key)]: key
  }), {});
  const strokeStyle = reduce(vlStyle, (style, value, name) => {
    if (!keys[name] || value == null) return style;

    switch (keys[name]) {
      case 'color':
        value = normalizeColor(value);
        break;
    }

    style[keys[name]] = value;
    return style;
  }, {});

  if (!isEmpty(strokeStyle)) {
    return new Stroke(strokeStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Image|undefined}
 * @todo split to separate circle, regShape, Icon
 */

function createImageStyle(vlStyle) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  const prefixKey = addPrefix(prefix);

  if (isEmpty(vlStyle[prefixKey('src')]) && isEmpty(vlStyle.image) && isEmpty(vlStyle[prefixKey('points')]) && !isNumeric(vlStyle[prefixKey('radius')])) {
    return;
  }

  if (vlStyle.image instanceof Image) return vlStyle.image;
  let imageStyle, Ctor;

  if (!isEmpty(vlStyle[prefixKey('src')]) || !isEmpty(vlStyle.image)) {
    // icon construction
    Ctor = Icon; // then create Icon options

    imageStyle = {
      anchor: vlStyle[prefixKey('anchor')],
      anchorOrigin: vlStyle[prefixKey('anchorOrigin')],
      anchorXUnits: vlStyle[prefixKey('anchorXUnits')],
      anchorYUnits: vlStyle[prefixKey('anchorYUnits')],
      color: vlStyle[prefixKey('color')],
      offset: vlStyle[prefixKey('offset')],
      offsetOrigin: vlStyle[prefixKey('offsetOrigin')],
      size: vlStyle[prefixKey('size')],
      img: vlStyle.image,
      imgSize: vlStyle[prefixKey('imgSize')],
      src: vlStyle[prefixKey('src')],
      crossOrigin: vlStyle[prefixKey('crossOrigin')]
    };
  } else if (vlStyle[prefixKey('points')] != null) {
    // regular shape construction
    Ctor = RegularShape; // create RegularShape options

    imageStyle = {
      points: vlStyle[prefixKey('points')],
      radius: vlStyle[prefixKey('radius')],
      radius1: vlStyle[prefixKey('radius1')],
      radius2: vlStyle[prefixKey('radius2')],
      angle: vlStyle[prefixKey('angle')]
    };
  } else {
    // circle construction
    Ctor = Circle$1; // create Circle options

    imageStyle = {
      radius: vlStyle[prefixKey('radius')]
    };
  }

  imageStyle = { ...imageStyle,
    fill: createFillStyle(vlStyle, prefixKey('fill')),
    stroke: createStrokeStyle(vlStyle, prefixKey('stroke')),
    opacity: vlStyle[prefixKey('opacity')],
    scale: vlStyle[prefixKey('scale')],
    rotation: vlStyle[prefixKey('rotation')],
    rotateWithView: vlStyle[prefixKey('rotateWithView')],
    displacement: vlStyle[prefixKey('displacement')]
  };

  if (!isEmpty(imageStyle)) {
    return new Ctor(imageStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Text|undefined}
 */

function createTextStyle(vlStyle) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (vlStyle.text == null) return;
  if (vlStyle.text instanceof Text) return vlStyle.text;
  const prefixKey = addPrefix(prefix);
  const textStyle = {
    text: vlStyle.text,
    textAlign: vlStyle.textAlign,
    textBaseline: vlStyle.textBaseline,
    font: vlStyle[prefixKey('font')],
    scale: vlStyle[prefixKey('scale')],
    offsetX: vlStyle[prefixKey('offsetX')],
    offsetY: vlStyle[prefixKey('offsetY')],
    rotation: vlStyle[prefixKey('rotation')],
    rotateWithView: vlStyle[prefixKey('rotateWithView')],
    padding: vlStyle[prefixKey('padding')],
    maxAngle: vlStyle[prefixKey('maxAngle')],
    overflow: vlStyle[prefixKey('overflow')],
    placement: vlStyle[prefixKey('placement')],
    fill: createFillStyle(vlStyle, prefixKey('fill')),
    stroke: createStrokeStyle(vlStyle, prefixKey('stroke')),
    backgroundFill: createFillStyle(vlStyle, prefixKey('backgroundFill')),
    backgroundStroke: createStrokeStyle(vlStyle, prefixKey('backgroundStroke'))
  };

  if (!isEmpty(textStyle)) {
    return new Text(textStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {function} [geomReader=identity]
 * @return {Geometry|Object|function|undefined}
 */

function createGeomStyle(vlStyle) {
  let geomReader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;

  if (isFunction(vlStyle.geom)) {
    return function __styleGeomFunc(feature) {
      return vlStyle.geom(feature);
    };
  }

  if (vlStyle.geom instanceof Geometry) {
    return vlStyle.geom;
  }

  if (vlStyle.geom) {
    return geomReader(vlStyle.geom);
  }

  return null;
}
function dumpStyle(olStyle) {
  let geomWriter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  if (!olStyle || isFunction(olStyle)) return;
  return { ...dumpFillStyle(olStyle.getFill(), 'fill'),
    ...dumpStrokeStyle(olStyle.getStroke(), 'stroke'),
    ...dumpImageStyle(olStyle.getImage(), 'image'),
    ...dumpTextStyle(olStyle.getText(), 'text'),
    ...dumpGeomStyle(olStyle.getGeometry(), geomWriter),
    zIndex: olStyle.getZIndex() // renderer: olStyle.getRenderer(),

  };
}
function dumpFillStyle(fillStyle) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!fillStyle) return {};
  const prefixKey = addPrefix(prefix);
  return {
    [prefixKey('color')]: fillStyle.getColor()
  };
}
function dumpStrokeStyle(strokeStyle) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!strokeStyle) return {};
  const prefixKey = addPrefix(prefix);
  return {
    [prefixKey('color')]: strokeStyle.getColor(),
    [prefixKey('width')]: strokeStyle.getWidth(),
    [prefixKey('miterLimit')]: strokeStyle.getMiterLimit(),
    [prefixKey('lineCap')]: strokeStyle.getLineCap(),
    [prefixKey('lineJoin')]: strokeStyle.getLineJoin(),
    [prefixKey('lineDash')]: strokeStyle.getLineDash(),
    [prefixKey('lineDashOffset')]: strokeStyle.getLineDashOffset()
  };
}
function dumpImageStyle(imageStyle) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!imageStyle) return {};
  const prefixKey = addPrefix(prefix);
  const common = {
    [prefixKey('opacity')]: imageStyle.getOpacity(),
    [prefixKey('scale')]: imageStyle.getScale(),
    [prefixKey('rotation')]: imageStyle.getRotation(),
    [prefixKey('rotateWithView')]: imageStyle.getRotateWithView(),
    [prefixKey('displacement')]: imageStyle.getDisplacement()
  };

  switch (true) {
    case imageStyle instanceof Icon:
      return { ...common,
        // fixme avoid using of internal fields, but currently Icon haven't getters for several fields
        [prefixKey('anchor')]: imageStyle.anchor_.slice(),
        [prefixKey('anchorOrigin')]: imageStyle.anchorOrigin_,
        [prefixKey('anchorXUnits')]: imageStyle.anchorXUnits_,
        [prefixKey('anchorYUnits')]: imageStyle.anchorYUnits_,
        [prefixKey('color')]: isArray(imageStyle.getColor()) ? imageStyle.getColor().slice() : imageStyle.getColor(),
        [prefixKey('offset')]: imageStyle.offset_.slice(),
        [prefixKey('offsetOrigin')]: imageStyle.offsetOrigin_,
        [prefixKey('size')]: isArray(imageStyle.getSize()) ? imageStyle.getSize().slice() : imageStyle.getSize(),
        [prefixKey('src')]: imageStyle.getSrc(),
        [prefixKey('crossOrigin')]: imageStyle.crossOrigin_
      };

    case imageStyle instanceof Circle$1:
      return { ...common,
        ...dumpFillStyle(imageStyle.getFill(), prefixKey('fill')),
        ...dumpStrokeStyle(imageStyle.getStroke(), prefixKey('stroke')),
        [prefixKey('radius')]: imageStyle.getRadius()
      };

    case imageStyle instanceof RegularShape:
      return { ...common,
        ...dumpFillStyle(imageStyle.getFill(), prefixKey('fill')),
        ...dumpStrokeStyle(imageStyle.getStroke(), prefixKey('stroke')),
        [prefixKey('points')]: imageStyle.getPoints(),
        [prefixKey('radius')]: imageStyle.getRadius(),
        [prefixKey('radius2')]: imageStyle.getRadius2(),
        [prefixKey('angle')]: imageStyle.getAngle()
      };

    default:
      return { ...common
      };
  }
}
function dumpTextStyle(textStyle) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!textStyle) return {};
  const prefixKey = addPrefix(prefix);
  return filter({
    text: textStyle.getText(),
    textAlign: textStyle.getTextAlign(),
    textBaseline: textStyle.getTextBaseline(),
    [prefixKey('font')]: textStyle.getFont(),
    [prefixKey('scale')]: textStyle.getScale(),
    [prefixKey('rotation')]: textStyle.getRotation(),
    [prefixKey('offsetX')]: textStyle.getOffsetX(),
    [prefixKey('offsetY')]: textStyle.getOffsetY(),
    [prefixKey('rotateWithView')]: textStyle.getRotateWithView(),
    [prefixKey('padding')]: textStyle.getPadding(),
    [prefixKey('maxAngle')]: textStyle.getMaxAngle(),
    [prefixKey('overflow')]: textStyle.getOverflow(),
    [prefixKey('placement')]: textStyle.getPlacement(),
    ...dumpFillStyle(textStyle.getFill(), prefixKey('fill')),
    ...dumpStrokeStyle(textStyle.getStroke(), prefixKey('stroke')),
    ...dumpFillStyle(textStyle.getBackgroundFill(), prefixKey('backgroundFill')),
    ...dumpStrokeStyle(textStyle.getBackgroundStroke(), prefixKey('backgroundStroke'))
  }, value => value != null);
}
function dumpGeomStyle(geom) {
  let geomWriter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  if (!geom) return {};
  return {
    geom: geomWriter(geom)
  };
}
/**
 * @typedef {
 *            module:ol/style/Style~Style |
 *            module:ol/style/Image~ImageStyle |
 *            module:ol/style/Fill~Fill |
 *            module:ol/style/Stroke~Stroke |
 *            module:ol/style/Text~Text |
 *            module:ol/style/Style~StyleFunction
 *          } OlAllStyle
 */

/**
 * @typedef {Object} VlStyle
 *
 * Shared
 * @property {string|number[]|undefined} fillColor
 * @property {string|number[]|undefined} strokeColor
 * @property {number|undefined} strokeWidth
 * @property {number|undefined} strokeMiterLimit
 * @property {number[]|undefined} strokeLineDash
 * @property {number|undefined} strokeLineDashOffset
 * @property {string|undefined} strokeLineCap
 * @property {string|undefined} strokeLineJoin
 * @property {number|undefined} zIndex
 * @property {Fill|undefined} fill
 * @property {Stroke|undefined} stroke
 * @property {RenderFunction|undefined} renderer
 *
 * Text only
 * @property {string|Text|undefined} text
 * @property {string|undefined} textFont
 * @property {number|string|undefined} textFontSize
 * @property {string|undefined} textFontWeight
 * @property {string|number[]|undefined} textFillColor
 * @property {string|number[]|undefined} textStrokeColor
 * @property {number|undefined} textStrokeWidth
 * @property {number|undefined} textStrokeMiterLimit
 * @property {number[]|undefined} textStrokeLineDash
 * @property {number|undefined} textStrokeLineDashOffset
 * @property {string|undefined} textStrokeLineCap
 * @property {string|undefined} textStrokeLineJoin
 * @property {number|undefined} textScale
 * @property {string|undefined} textAlign
 * @property {number|undefined} textRotation
 * @property {number|undefined} textOffsetX
 * @property {number|undefined} textOffsetY
 * @property {Stroke|undefined} textStroke
 * @property {Fill|undefined} textFill
 * @property {boolean|undefined} textRotateWithView
 * @property {number[]|undefined} textPadding
 * @property {number|undefined} textMaxAngle
 * @property {boolean|undefined} textOverflow
 * @property {string|undefined} textPlacement
 * @property {string|undefined} textBaseline
 * @property {Fill|undefined} textBackgroundFillColor
 * @property {Stroke|undefined} textBackgroundStrokeColor
 * @property {Stroke|undefined} textBackgroundStrokeWidth
 * @property {number|undefined} textBackgroundStrokeMiterLimit
 * @property {Stroke|undefined} textBackgroundStrokeLineDash
 * @property {number|undefined} textBackgroundStrokeLineDashOffset
 * @property {Stroke|undefined} textBackgroundStrokeCap
 * @property {Stroke|undefined} textBackgroundStrokeJoin
 *
 * Image only
 * @property {Image|undefined} image
 * @property {string|undefined} imageSrc
 * @property {number[]|undefined} imageSize
 * @property {number[]|undefined} imageImgSize
 * @property {number|undefined} imageOffset
 * @property {number[]|undefined} imageAnchor
 * @property {string|undefined} imageAnchorXUnits
 * @property {string|undefined} imageAnchorYUnits
 * @property {number|undefined} imageScale
 * @property {number|undefined} imageRotation
 * @property {number|undefined} imageRadius
 * @property {number|undefined} imageRadius1
 * @property {number|undefined} imageRadius2
 * @property {number|undefined} imagePoints
 * @property {number|undefined} imageAngle
 * @property {number|undefined} imageOpacity
 * @property {string|number[]|undefined} imageFillColor
 * @property {string|number[]|undefined} imageStrokeColor
 * @property {number|undefined} imageStrokeWidth
 * @property {number|undefined} imageStrokeMiterLimit
 * @property {number[]|undefined} imageStrokeLineDash
 * @property {number|undefined} imageStrokeLineDashOffset
 * @property {string|undefined} imageStrokeLineCap
 * @property {string|undefined} imageStrokeLineJoin
 * @property {IconOrigin|undefined} imageAnchorOrigin
 * @property {ColorLike|undefined} imageColor
 * @property {IconOrigin|undefined} imageOffsetOrigin
 * @property {Stroke|undefined} imageStroke
 * @property {Fill|undefined} imageFill
 * @property {string|undefined} imageCrossOrigin
 * @property {boolean|undefined} imageRotateWithView
 * @property {number[]|undefined} imageDisplacement
 *
 * @property {Geometry|Object|function|undefined} geom Coordinates should be in map projection
 */

/**
 * @param {Object} [options]
 * @return {GeoJSON}
 */

function createGeoJsonFmt(options) {
  return new GeoJSON(options);
}
/**
 * @param [options]
 * @return {MVT}
 */

function createMvtFmt(options) {
  return new MVT(options);
}
const CIRCLE_SERIALIZE_PROP = 'vl_circle';
const STYLE_SERIALIZE_PROP = 'vl_style';

class GeoJSON extends GeoJSON$1 {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(options);
    this.defaultDecimals = options.decimals != null && options.decimals > -1 ? options.decimals : undefined;
    this.defaultStyleReader = options.styleReader || noop;
    this.defaultStyleWriter = options.styleWriter || noop;
  }

  adaptOptions() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (options.decimals != null && options.decimals < 0) {
      options.decimals = undefined;
    }

    return super.adaptOptions({
      decimals: this.defaultDecimals,
      styleReader: this.defaultStyleReader,
      styleWriter: this.defaultStyleWriter,
      ...options
    });
  }

  writeGeometryObject(geometry, options) {
    options = this.adaptOptions(options);

    if (isCircleGeom(geometry)) {
      let center = geometry.getCenter().slice();
      const end = [center[0] + geometry.getRadius(), center[1]];
      const radius = getLength(new LineString([center, end]), options.featureProjection);
      center = transformPoint(center, options.featureProjection, EPSG_4326);
      geometry = createCircularPolygon(center, radius);
      options.featureProjection = EPSG_4326;
    }

    return super.writeGeometryObject(geometry, options);
  }

  writeFeatureObject(feature, options) {
    options = this.adaptOptions(options);
    /** @type {GeoJSONFeature} */

    const object = {
      type: 'Feature',
      geometry: null,
      properties: null
    };
    const id = feature.getId();

    if (id !== undefined) {
      object.id = id;
    }
    /* eslint-disable quote-props */


    const geometry = feature.getGeometry();

    if (geometry) {
      object.geometry = this.writeGeometryObject(geometry, options);

      if (isCircleGeom(geometry)) {
        object.properties = { ...(object.properties || {}),
          [CIRCLE_SERIALIZE_PROP]: {
            center: transformPoint(geometry.getCenter(), options.featureProjection, options.dataProjection),
            radius: transformDistance(geometry.getRadius(), options.featureProjection, options.dataProjection)
          }
        };
      }
    }

    const properties = feature.getProperties();
    delete properties[feature.getGeometryName()];

    if (!isEmpty$1(properties)) {
      object.properties = { ...(object.properties || {}),
        ...clonePlainObject(omit(properties, 'features'))
      };

      if (isArray(properties.features)) {
        object.properties.features = map(properties.features, feature => {
          if (feature instanceof Feature) {
            return this.writeFeatureObject(feature, options);
          }

          return feature;
        });
      }
    }

    let style = feature.getStyle();

    if (style && !isFunction(style)) {
      isArray(style) || (style = [style]);
      object.properties = { ...(object.properties || {}),
        [STYLE_SERIALIZE_PROP]: style.map(style => options.styleWriter(style, geometry => this.writeGeometryObject(geometry, options)))
      };
    }
    /* eslint-enable quote-props */


    return object;
  }

  readFeatureFromObject(object, options) {
    options = this.adaptOptions(options);
    /**
     * @type {GeoJSONFeature}
     */

    let geoJSONFeature;

    if (object.type === 'Feature') {
      geoJSONFeature = clonePlainObject(object);
    } else {
      geoJSONFeature = {
        type: 'Feature',
        geometry: clonePlainObject(object),
        properties: null
      };
    }

    const feature = new Feature();
    /* eslint-disable dot-notation */

    if (geoJSONFeature.properties && geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP]) {
      options.circle = geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP];
      delete geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP];
    }

    const geometry = this.readGeometryFromObject(geoJSONFeature.geometry, options);

    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && 'geometry_name' in geoJSONFeature !== undefined) {
      feature.setGeometryName(geoJSONFeature.geometry_name);
    }

    feature.setGeometry(geometry);

    if ('id' in geoJSONFeature) {
      feature.setId(geoJSONFeature.id);
    }

    if (geoJSONFeature.properties) {
      if (geoJSONFeature.properties[STYLE_SERIALIZE_PROP]) {
        let style = geoJSONFeature.properties[STYLE_SERIALIZE_PROP];
        isArray(style) || (style = [style]);
        feature.setStyle(style.map(style => options.styleReader(style, geometry => this.readGeometryFromObject(geometry, omit(options, ['circle'])))));
        delete geoJSONFeature.properties[STYLE_SERIALIZE_PROP];
      }

      if (isArray(geoJSONFeature.properties.features)) {
        geoJSONFeature.properties.features = map(geoJSONFeature.properties.features, feature => {
          if (isGeoJSONFeature(feature)) {
            return this.readFeatureFromObject(feature, options);
          }

          return feature;
        });
      }

      feature.setProperties(geoJSONFeature.properties, true);
    }
    /* eslint-enable dot-notation */


    return feature;
  }

  readGeometryFromObject(object, options) {
    var _options$circle, _options$circle2;

    options = this.adaptOptions(options);

    if ((_options$circle = options.circle) !== null && _options$circle !== void 0 && _options$circle.center && (_options$circle2 = options.circle) !== null && _options$circle2 !== void 0 && _options$circle2.radius) {
      return new Circle(transformPoint(options.circle.center, options.dataProjection, options.featureProjection), transformDistance(options.circle.radius, options.dataProjection, options.featureProjection));
    }

    return super.readGeometryFromObject(clonePlainObject(object), options);
  }

}
function getGeoJsonFmt() {

  return createGeoJsonFmt({
    decimals: COORD_PRECISION,
    styleReader: createStyle,
    styleWriter: dumpStyle
  });
}
/**
 * @param {Feature} feature
 * @param {ProjectionLike|undefined} [featureProjection=EPSG:3857]
 * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
 * @param {number} [decimals=COORD_PRECISION]
 * @return {Object}
 */

function writeGeoJsonFeature(feature) {
  let featureProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
  let decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!feature) return;
  return getGeoJsonFmt().writeFeatureObject(feature, {
    featureProjection,
    dataProjection,
    decimals
  });
}
/**
 * @param {Object} geoJsonFeature
 * @param {ProjectionLike|undefined} [featureProjection=EPSG:3857]
 * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
 * @param {number} [decimals=COORD_PRECISION]
 * @return {Feature}
 */

function readGeoJsonFeature(geoJsonFeature) {
  let featureProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
  let decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!geoJsonFeature) return;
  return getGeoJsonFmt().readFeature(geoJsonFeature, {
    featureProjection,
    dataProjection,
    decimals
  });
}
/**
 * @param {Geometry} geometry
 * @param {ProjectionLike|undefined} [geometryProjection=EPSG:3857]
 * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
 * @param {number} [decimals=COORD_PRECISION]
 * @return {Object}
 */

function writeGeoJsonGeometry(geometry) {
  let geometryProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
  let decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!geometry) return;
  return getGeoJsonFmt().writeGeometryObject(geometry, {
    featureProjection: geometryProjection,
    dataProjection,
    decimals
  });
}
/**
 * @param {Object|Object} geoJsonGeometry
 * @param {ProjectionLike|undefined} [geometryProjection=EPSG:3857]
 * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
 * @param {number} [decimals=COORD_PRECISION]
 * @return {Geometry}
 */

function readGeoJsonGeometry(geoJsonGeometry) {
  let geometryProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  let dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
  let decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!geoJsonGeometry) return;
  dataProjection = readProjection(geoJsonGeometry, dataProjection);
  return getGeoJsonFmt().readGeometry(geoJsonGeometry, {
    featureProjection: geometryProjection,
    dataProjection,
    decimals
  });
}
function readProjection(geoJsonObj, defaultProjection) {
  return getGeoJsonFmt().readProjection(geoJsonObj) || defaultProjection;
}
/**
 * @param {Object} feature
 * @returns {boolean}
 */

function isGeoJSONFeature(feature) {
  return isPlainObject(feature) && feature.type === 'Feature' && isGeoJSONGeometry(feature.geometry);
}
function isGeoJSONGeometry(geometry) {
  return isPlainObject(geometry) && Object.values(GeometryType).includes(geometry.type) && geometry.geometries ? geometry.geometries.every(geometry => isArray(geometry.coordinates)) : isArray(geometry === null || geometry === void 0 ? void 0 : geometry.coordinates);
}

/**
 * @param {Object|module:ol/Feature~Feature|string|number} feature
 * @return {string|number}
 * @throws {Error}
 */

function getFeatureId(feature) {
  if (feature instanceof Feature) {
    return feature.getId();
  } else if (isPlainObject(feature)) {
    return feature.id;
  }

  throw new Error('Illegal feature format');
}
/**
 * @param {module:ol/Feature~Feature|Object} feature
 * @param {string} featureId
 * @returns {module:ol/Feature~Feature|Object}
 */

function setFeatureId(feature, featureId) {
  if (feature instanceof Feature) {
    feature.setId(featureId);
    return feature;
  } else if (isPlainObject(feature)) {
    feature.id = featureId;
    return feature;
  }

  throw new Error('Illegal feature format');
}
/**
 * @param {module:ol/Feature~Feature} feature
 * @param {string|undefined} defaultFeatureId
 * @returns {Feature}
 */

function initializeFeature(feature, defaultFeatureId) {
  if (getFeatureId(feature) == null) {
    setFeatureId(feature, defaultFeatureId || v4());
  }

  return feature;
}
function getFeatureGeomName(feature) {
  if (feature instanceof Feature) {
    return feature.getGeometryName();
  }

  return 'geometry';
}
function getFeatureGeom(feature) {
  if (feature instanceof Feature) {
    return feature.getGeometry();
  } else if (isPlainObject(feature)) {
    return feature.geometry;
  }

  throw new Error('Illegal feature format');
}
function getFeatureProperties(feature) {
  if (!feature) return;
  return omit((feature instanceof Feature ? feature.getProperties() : feature.properties) || {}, [getFeatureGeomName(feature), CIRCLE_SERIALIZE_PROP, STYLE_SERIALIZE_PROP]);
}
function setFeatureProperties(feature, properties) {
  if (!feature) return;
  properties = omit(properties || {}, [getFeatureGeomName(feature), CIRCLE_SERIALIZE_PROP, STYLE_SERIALIZE_PROP]);

  if (feature instanceof Feature) {
    feature.setProperties(properties);
  } else {
    feature.properties = properties;
  }
}

/**
 * @param {module:ol/interaction/Interaction~Interaction|Object} interaction
 * @returns {string|null}
 */

function getInteractionId(interaction) {
  if (interaction instanceof Interaction) {
    return interaction.get('id');
  }

  throw new Error('Illegal interaction argument');
}
/**
 * @param {module:ol/interaction/Interaction~Interaction|Object} interaction
 * @param {string} interactionId
 * @returns {module:ol/interaction/Interaction~Interaction|Object}
 */

function setInteractionId(interaction, interactionId) {
  if (interaction instanceof Interaction) {
    interaction.set('id', interactionId);
    return interaction;
  }

  throw new Error('Illegal interaction argument');
}
function getInteractionPriority(interaction) {
  if (interaction instanceof Interaction) {
    return interaction.get('priority');
  }

  throw new Error('Illegal interaction argument');
}
function setInteractionPriority(interaction, priority) {
  if (interaction instanceof Interaction) {
    interaction.set('priority', priority);
    return interaction;
  }

  throw new Error('Illegal interaction argument');
}
function initializeInteraction(interaction, defaultInteractionId, defaultPriority) {
  if (getInteractionId(interaction) == null) {
    setInteractionId(interaction, defaultInteractionId || v4());
  }

  if (getInteractionPriority(interaction) == null) {
    setInteractionPriority(interaction, defaultPriority || 0);
  }

  return interaction;
}

function getLayerId(layer) {
  if (layer instanceof BaseLayer) {
    return layer.get('id');
  }

  throw new Error('Illegal layer argument');
}
function setLayerId(layer, layerId) {
  if (layer instanceof BaseLayer) {
    layer.set('id', layerId);
    return layer;
  }

  throw new Error('Illegal layer argument');
}
function initializeLayer(layer, defaultLayerId) {
  if (getLayerId(layer) == null) {
    setLayerId(layer, defaultLayerId || v4());
  }

  return layer;
}

function getMapId(map) {
  if (map instanceof PluggableMap) {
    return map.get('id');
  }

  throw new Error('Illegal map argument');
}
function setMapId(map, mapId) {
  if (map instanceof PluggableMap) {
    map.set('id', mapId);
    return map;
  }

  throw new Error('Illegal map argument');
}
function getMapDataProjection(map) {
  if (map instanceof PluggableMap) {
    return map.get('dataProjection');
  }

  throw new Error('Illegal map argument');
}
function setMapDataProjection(map, dataProjection) {
  if (map instanceof PluggableMap) {
    map.set('dataProjection', dataProjection);
    return map;
  }

  throw new Error('Illegal map argument');
}

function getOverlayId(overlay) {
  if (overlay instanceof Overlay) {
    return overlay.get('id');
  }

  throw new Error('Illegal overlay argument');
}
function setOverlayId(overlay, overlayId) {
  if (overlay instanceof Overlay) {
    overlay.set('id', overlayId);
    return overlay;
  }

  throw new Error('Illegal overlay argument');
}
function initializeOverlay(overlay, defaultOverlay) {
  if (getOverlayId(overlay) == null) {
    setOverlayId(overlay, defaultOverlay || v4());
  }

  return overlay;
}

function getSourceId(source) {
  if (source instanceof Source) {
    return source.get('id');
  }

  throw new Error('Illegal source argument');
}
function setSourceId(source, sourceId) {
  if (source instanceof Source) {
    source.set('id', sourceId);
    return source;
  }

  throw new Error('Illegal source argument');
}
function initializeSource(source, defaultSourceId) {
  if (getSourceId(source) == null) {
    setSourceId(source, defaultSourceId || v4());
  }

  return source;
}
function cleanSourceParams(params, filterKeys) {
  return reduce(params, (params, value, key) => {
    key = key.toUpperCase();

    if (filterKeys.includes(key)) {
      return params;
    }

    params[key] = value;
    return params;
  }, {});
}

function extentFromProjection(projection) {
  projection = get(projection);
  let extent = projection.getExtent();

  if (!extent) {
    const half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }

  return extent;
}

function getViewId(view) {
  if (view instanceof View) {
    return view.get('id');
  }

  throw new Error('Illegal view argument');
}
function setViewId(view, viewId) {
  if (view instanceof View) {
    view.set('id', viewId);
    return view;
  }

  throw new Error('Illegal view argument');
}
function initializeView(view, defaultViewId) {
  if (getViewId(view) == null) {
    setViewId(view, defaultViewId || v4());
  }

  return view;
}

function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);

  if (match) {
    // char range
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;

    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }

    return urls;
  }

  match = /\{(\d+)-(\d+)\}/.exec(url);

  if (match) {
    // number range
    const stop1 = parseInt(match[2], 10);

    for (let i = parseInt(match[1], 10); i <= stop1; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }

    return urls;
  }

  urls.push(url);
  return urls;
}

export { CIRCLE_SERIALIZE_PROP, COORD_PRECISION, EPSG_3857, EPSG_4326, ExtentCorner, GeometryType, OverlayPositioning, STYLE_SERIALIZE_PROP, SourceState, WMSServerType, calcDistance, cleanSourceParams, createCircularPolygon, createFillStyle, createGeoJsonFmt, createGeomCollection, createGeomStyle, createImageStyle, createLineGeom, createMultiLineGeom, createMultiPointGeom, createMultiPolygonGeom, createMvtFmt, createOrUpdate, createPointGeom, createPolygonGeom, createStrokeStyle, createStyle, createTextStyle, defaultEditStyle, defaultStyle, dumpFillStyle, dumpGeomStyle, dumpImageStyle, dumpStrokeStyle, dumpStyle, dumpTextStyle, expandUrl, extentFromLonLat, extentFromProjection, extentToLonLat, findPointOnSurface, flatCoords, getControlId, getCorner, getFeatureGeom, getFeatureGeomName, getFeatureId, getFeatureProperties, getGeoJsonFmt, getGeomCoords, getGeomType, getGeometryId, getInteractionId, getInteractionPriority, getLayerId, getMapDataProjection, getMapId, getOverlayId, getSourceId, getStyleId, getViewId, initializeControl, initializeFeature, initializeGeometry, initializeInteraction, initializeLayer, initializeOverlay, initializeSource, initializeStyle, initializeView, isCircleGeom, isEqualCoord, isGeoJSONFeature, isGeoJSONGeometry, isLineCoords, isMultiGeom, isMultiLineCoords, isMultiPointCoords, isMultiPolygonCoords, isPointCoords, isPolygonCoords, lineFromLonLat, lineToLonLat, multiLineFromLonLat, multiLineToLonLat, multiPointFromLonLat, multiPointToLonLat, multiPolygonFromLonLat, multiPolygonToLonLat, normalizeColor, pointFromLonLat, pointToLonLat, polygonFromLonLat, polygonToLonLat, readGeoJsonFeature, readGeoJsonGeometry, readProjection, roundCoords, roundExtent, roundLineCoords, roundMultiLineCoords, roundMultiPointCoords, roundMultiPolygonCoords, roundPointCoords, roundPolygonCoords, setControlId, setFeatureId, setFeatureProperties, setGeometryId, setInteractionId, setInteractionPriority, setLayerId, setMapDataProjection, setMapId, setOverlayId, setSourceId, setStyleId, setViewId, toSimpleGeom, transform, transformDistance, transformExtent, transformLine, transformMultiLine, transformMultiPoint, transformMultiPolygon, transformPoint, transformPolygon, transforms, writeGeoJsonFeature, writeGeoJsonGeometry };
//# sourceMappingURL=ol-ext.js.map
