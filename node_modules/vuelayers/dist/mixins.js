/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.12.7
 * @license MIT
 * @copyright (c) 2017-2023, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import { cleanSourceParams, EPSG_3857, transformPoint, transformLine, transformPolygon, transformMultiPoint, transformMultiLine, transformMultiPolygon, transformExtent as transformExtent$1, writeGeoJsonGeometry, readGeoJsonGeometry, writeGeoJsonFeature, readGeoJsonFeature, COORD_PRECISION, roundExtent, initializeLayer, getLayerId, setLayerId, initializeControl, getControlId, isGeoJSONGeometry, findPointOnSurface, dumpStyle, getFeatureProperties, initializeFeature, getFeatureId, setFeatureId, setFeatureProperties, CIRCLE_SERIALIZE_PROP, STYLE_SERIALIZE_PROP, roundPointCoords, initializeGeometry, getGeometryId, setGeometryId, getSourceId, SourceState, initializeSource, setSourceId, initializeStyle, getStyleId, setStyleId, getInteractionPriority, initializeInteraction, getInteractionId, setInteractionId, setInteractionPriority, initializeOverlay, getOverlayId, dumpStrokeStyle, dumpFillStyle, roundCoords, isEqualCoord, transforms, GeometryType, expandUrl, isGeoJSONFeature, getGeoJsonFmt, transform, WMSServerType, extentFromProjection } from './ol-ext';
import { hasProp, stubObject, identity, keys, IdentityMap, noop, newLogger, mergeDescriptors, kebabCase, coalesce, assert, isArray, addPrefix, isFunction, makeWatchers, isEqual, reduce, lowerFirst, upperFirst, isObjectLike, clonePlainObject, extractChildren, waitFor, hasAncestorVm, stubTrue, isNumber, isPlainObject, instanceOf, forEach, find, isString, isEmpty, get as get$1, or, negate, sealFactory, and, replaceTokens, pick, stubArray, every, map as map$1, constant } from './utils';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import debounce from 'debounce-promise';
import { Observable, Object as Object$1, Collection, Feature, Overlay } from 'ol';
import EventType from 'ol/events/EventType';
import ObjectEventType from 'ol/ObjectEventType';
import { merge, of, throwError, interval, race } from 'rxjs';
import { retry, filter, publishReplay, refCount, first, mergeMap, delayWhen, map, mapTo, tap, distinctUntilChanged } from 'rxjs/operators';
import { v4 } from 'uuid';
import { fromVueEvent, fromOlChangeEvent, fromOlEvent, fromVueWatcher, bufferDebounceTime } from './rx-ext';
import Vue from 'vue';
import { get } from 'ol/proj';
import CollectionEventType from 'ol/CollectionEventType';
import { defaults, Control } from 'ol/control';
import { getUid } from 'ol/util';
import { Geometry } from 'ol/geom';
import { Style, Fill, Image, Stroke, Text } from 'ol/style';
import RenderEventType from 'ol/render/EventType';
import { Source, Vector, XYZ } from 'ol/source';
import { defaults as defaults$1, Interaction } from 'ol/interaction';
import BaseLayer from 'ol/layer/Base';
import { boundingExtent as boundingExtent$1 } from 'ol/extent';
import GeometryLayout from 'ol/geom/GeometryLayout';
import TileEventType from 'ol/source/TileEventType';
import { all } from 'ol/loadingstrategy';
import { createTileUrlFunctionFromTemplates } from 'ol-tilecache';
import { createXYZ } from 'ol/tilegrid';

const EVENT_BUS_PROP = '$vlEventBus';
var eventBus = {
  beforeCreate() {
    initEventBus(); // define local getter

    Object.defineProperties(this, {
      /**
       * @type {Vue}
       */
      $eventBus: {
        enumerable: true,
        get: () => this[EVENT_BUS_PROP]
      }
    });
  }

};

function initEventBus() {
  if (hasProp(Vue, EVENT_BUS_PROP) || hasProp(Vue.prototype, EVENT_BUS_PROP)) return;
  const bus = new Vue();

  if (!hasProp(Vue, EVENT_BUS_PROP)) {
    Object.defineProperties(Vue, {
      [EVENT_BUS_PROP]: {
        enumerable: true,
        get: () => bus
      }
    });
  }

  if (!hasProp(Vue.prototype, EVENT_BUS_PROP)) {
    Object.defineProperties(Vue.prototype, {
      [EVENT_BUS_PROP]: {
        enumerable: true,
        get: () => bus
      }
    });
  }
}

const IDENTITY_MAP_PROP = '$vlIdentityMap';
const INSTANCES_POOL = 'instances';
var identMap = {
  data() {
    return {
      idents: stubObject()
    };
  },

  beforeCreate() {
    initIdentityMap(); // define local getter

    Object.defineProperties(this, {
      $identityMap: {
        enumerable: true,
        get: () => this[IDENTITY_MAP_PROP]
      }
    });
  },

  destroyed() {
    this.unsetInstances();
  },

  methods: {
    /**
     * @param parts
     * @return {string}
     */
    makeIdent() {
      for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
        parts[_key] = arguments[_key];
      }

      return parts.filter(identity).join('.');
    },

    /**
     * Caches or reuse factory result in the identity map
     * and returns result.
     *
     * @param {string|undefined} ident
     * @param {function} factory
     * @returns {*}
     */
    instanceFactoryCall(ident, factory) {
      if (ident && this.hasInstance(ident)) {
        return this.getInstance(ident);
      }

      const inst = factory();

      if (ident) {
        this.setInstance(ident, inst);
      }

      return inst;
    },

    /**
     * @param {string|undefined} ident
     * @returns {*}
     */
    getInstance(ident) {
      if (!ident || !this.hasInstance(ident)) return;
      this.idents[ident] = true;
      return this.$identityMap.get(ident, INSTANCES_POOL);
    },

    /**
     * @param ident
     * @param inst
     */
    setInstance(ident, inst) {
      if (!ident) return;
      this.idents[ident] = true;
      this.$identityMap.set(ident, inst, INSTANCES_POOL);
    },

    /**
     * @param {string|undefined} ident
     * @returns {*}
     */
    hasInstance(ident) {
      if (!ident) return;
      return this.$identityMap.has(ident, INSTANCES_POOL);
    },

    /**
     * @param {string|undefined} ident
     * @return {void}
     */
    unsetInstance(ident) {
      if (!ident) return;
      delete this.idents[ident];
      this.$identityMap.unset(ident, INSTANCES_POOL);
    },

    /**
     * Unsets all self indets
     * @return {void}
     */
    unsetInstances() {
      keys(this.idents).forEach(this.unsetInstance.bind(this));
    },

    /**
     * @param {string|undefined} fromIdent
     * @param {string|undefined} toIdent
     * @returns {boolean}
     */
    moveInstance(fromIdent, toIdent) {
      return this.$identityMap.move(fromIdent, toIdent, INSTANCES_POOL);
    }

  }
};

function initIdentityMap() {
  if (hasProp(Vue, IDENTITY_MAP_PROP) || hasProp(Vue.prototype, IDENTITY_MAP_PROP)) return;
  const imap = new IdentityMap();

  if (!hasProp(Vue, IDENTITY_MAP_PROP)) {
    Object.defineProperties(Vue, {
      [IDENTITY_MAP_PROP]: {
        enumerable: true,
        get: () => imap
      }
    });
  }

  if (!hasProp(Vue.prototype, IDENTITY_MAP_PROP)) {
    Object.defineProperties(Vue.prototype, {
      [IDENTITY_MAP_PROP]: {
        enumerable: true,
        get: () => imap
      }
    });
  }
}

/**
 * RxJS subscriptions manager.
 */

var rxSubs = {
  beforeCreate() {
    /**
     * @type {Subscription[]}
     * @private
     */
    this._rxSubs = [];
  },

  destroyed() {
    this.unsubscribeAll();
  },

  methods: {
    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {},

    /**
     * @return {void}
     * @protected
     */
    unsubscribeAll() {
      this._rxSubs.forEach(subs => subs.unsubscribe());

      this._rxSubs = [];
    },

    /**
     * @param {Observable<T>} observable
     * @param {function} [next] Next handler or Observer object.
     * @param {function} [error] Error handler.
     * @param {function} [complete] Complete handler.
     * @return {Subscription}
     * @protected
     */
    subscribeTo(observable) {
      let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      let error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;
      let complete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;

      const errorWrap = err => {
        if (process.env.NODE_ENV !== 'production') {
          if (this.$logger) {
            this.$logger.error(err.stack);
          } else {
            newLogger(this.vmName).error(err.stack);
          }
        }

        error(err);
      };

      const subs = observable.pipe(retry(3)).subscribe(next, errorWrap, complete);

      this._rxSubs.push(subs);

      return subs;
    },

    unsubscribe(subs) {
      const idx = this._rxSubs.indexOf(subs);

      if (idx === -1) return;
      subs.unsubscribe();

      this._rxSubs.splice(idx, 1);
    }

  }
};

// const SERVICES_PROP = Symbol('services')

const SERVICES_PROP = 'services';
/**
 * Service container mixin
 */

var services = {
  inject: {
    $services: SERVICES_PROP // todo works only in Vue 2.5.x
    // $services: {from: SERVICES_PROP, default: Object.create(null)},

  },

  provide() {
    return {
      [SERVICES_PROP]: this.getServices()
    };
  },

  methods: {
    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors({}, this.$services || {});
    }

  },

  beforeCreate() {
    let source = this.$parent;

    while (source) {
      if (source._provided != null && source._provided[SERVICES_PROP] != null) {
        break;
      }

      source = source.$parent;
    }

    if (source == null || source._provided[SERVICES_PROP] == null) {
      delete this.$options.inject.$services;
    }
  }

};

const VM_PROP = 'vm';
const FRAME_TIME = 1000 / 30;
const OlObjectState = {
  UNDEF: 'undef',
  CREATING: 'creating',
  CREATED: 'created',
  MOUNTING: 'mounting',
  MOUNTED: 'mounted',
  UNMOUNTING: 'unmounting',
  UNMOUNTED: 'unmounted',
  DESTROYING: 'destroying',
  DESTROYED: 'destroyed'
};
const OlObjectEvent = {
  CREATED: OlObjectState.CREATED,
  MOUNTED: OlObjectState.MOUNTED,
  UNMOUNTED: OlObjectState.UNMOUNTED,
  DESTROYED: OlObjectState.DESTROYED,
  ERROR: 'error'
};
const OlObjectAction = {
  CREATE: 'create',
  MOUNT: 'mount',
  UNMOUNT: 'unmount',
  DESTROY: 'destroy'
};
/**
 * Basic ol component mixin.
 * todo try to subscribe to generic change event here and update rev according to internal ol counter
 */

var olCmp = {
  mixins: [identMap, rxSubs, services, eventBus],
  props: {
    /**
     * @type {string|number}
     */
    id: {
      type: [String, Number],
      default: v4,
      validator: value => value != null && value !== ''
    },

    /**
     * Unique key for saving to identity map
     * @type {string|number|undefined}
     */
    ident: [String, Number]
  },

  data() {
    return {
      rev: 0,
      currentId: this.id
    };
  },

  computed: {
    /**
     * @type {string}
     */
    vmClass() {
      return kebabCase(this.$options.name);
    },

    /**
     * @type {string}
     */
    vmId() {
      return [this.vmClass, this.currentId].filter(identity).join('.');
    },

    /**
     * @type {string}
     */
    vmName() {
      return [this.$options.name, this.currentId].filter(identity).join('.');
    },

    /**
     * @type {string|undefined}
     */
    olObjIdent() {
      if (!this.ident) return;
      return this.makeIdent(this.ident);
    }

  },
  watch: {
    rev() {
      if (!this.$olObject) return;

      if (this.currentId !== this.getIdInternal()) {
        this.currentId = this.getIdInternal();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['id', 'currentId', 'olObjIdent'])
  },

  async created() {
    /**
     * @type {{warn: (function(...[*]): void), log: (function(...[*]): void), error: (function(...[*]): void)}}
     * @private
     */
    this._logger = newLogger(this.vmName);
    /**
     * @type {number}
     * @private
     */

    this._olObjectState = OlObjectState.UNDEF;
    /**
     * @type {module:ol/Object~BaseObject}
     * @private
     */

    this._olObject = undefined;
    /**
     * @type {Observable}
     * @private
     */

    this._olObjectEvents = newOlObjectEventsObs.call(this);
    defineDebounceMethods.call(this);
    defineServices$i.call(this);
    await execInit.call(this, false);
  },

  async mounted() {
    await execMount.call(this);
  },

  async beforeDestroy() {
    await execUnmount.call(this, true);
  },

  async destroyed() {
    await execDeinit.call(this);
  },

  methods: {
    /**
     * @return {Promise<void>} Resolves when initialization completes
     * @protected
     */
    beforeInit() {},

    /**
     * @return {Promise<void>} Resolves when initialization completes
     * @protected
     */
    async init() {
      this._olObject = await this.instanceFactoryCall(this.olObjIdent, this.createOlObject.bind(this));
      this._olObject[VM_PROP] || (this._olObject[VM_PROP] = []); // for loaded from IdentityMap

      if (!this._olObject[VM_PROP].includes(this)) {
        this._olObject[VM_PROP].push(this);
      }

      await this.changed();
      this.subscribeAll();
    },

    /**
     * @return {module:ol/Object~BaseObject|Promise<module:ol/Object~BaseObject>}
     * @protected
     * @abstract
     */
    createOlObject() {
      throw new Error(`${this.vmName} not implemented method: createOlObject()`);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async deinit() {
      this.unsubscribeAll();
      this.unsetInstances();

      if (this._olObject) {
        this._olObject[VM_PROP] = this._olObject[VM_PROP].filter(vm => vm !== this);
        this._olObject = undefined;
      }
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeMount() {},

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount() {},

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    unmount() {},

    /**
     * Refresh internal ol objects
     * @return {Promise<void>}
     */
    async refresh() {
      let olObj;

      try {
        olObj = await this.resolveOlObject();

        if (olObj instanceof Observable) {
          return new Promise(resolve => {
            olObj.once('change', () => resolve());
            olObj.changed();
          });
        }
      } catch (err) {// todo check why this catch not catching OLObjectNotInitializedError from resolveOlObject
      }

      return this.changed();
    },

    /**
     * @return {Promise<void>}
     */
    async scheduleRefresh() {
      try {
        await this.debounceRefresh();
      } catch (err) {}
    },

    /**
     * Internal usage only in components that doesn't support refreshing.
     * @return {Promise<void>}
     * @protected
     */
    async remount() {
      if (this.$olObjectState === OlObjectState.MOUNTED) {
        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('remounting...');
        }

        await execUnmount.call(this);
        await execMount.call(this);
      } else {
        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('remount discarded');
        }
      }
    },

    /**
     * @return {Promise<void>}
     */
    async scheduleRemount() {
      if ([OlObjectState.MOUNTING, OlObjectState.MOUNTED].includes(this.$olObjectState)) {
        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('remount scheduled');
        }

        await this.debounceRemount();
      } else {
        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('remount discarded');
        }
      }
    },

    /**
     * Only for internal purpose to support watching for properties
     * for which OpenLayers doesn't provide setters.
     * @return {Promise}
     * @protected
     */
    async recreate() {
      if ([OlObjectState.CREATED, OlObjectState.MOUNTING, OlObjectState.MOUNTED, OlObjectState.UNMOUNTING, OlObjectState.UNMOUNTED].includes(this.$olObjectState)) {
        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('recreating...');
        }

        const mounted = [OlObjectState.MOUNTING, OlObjectState.MOUNTED].includes(this.$olObjectState);

        if (mounted) {
          await execUnmount.call(this);
        }

        await execDeinit.call(this);
        await execInit.call(this);

        if (mounted) {
          await execMount.call(this);
        }
      } else {
        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('recreate discarded');
        }
      }
    },

    /**
     * @return {Promise<void>}
     */
    async scheduleRecreate() {
      if ([OlObjectState.CREATING, OlObjectState.CREATED, OlObjectState.MOUNTING, OlObjectState.MOUNTED, OlObjectState.UNMOUNTING, OlObjectState.UNMOUNTED].includes(this.$olObjectState)) {
        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('recreate scheduled');
        }

        await this.debounceRecreate();
      } else {
        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('recreate discarded');
        }
      }
    },

    /**
     * Redefine for easy call in child components
     * @returns {Object}
     * @protected
     */
    getServices() {
      return services.methods.getServices.call(this);
    },

    /**
     * @protected
     */
    subscribeAll() {
      subscribeToOlObjectEvents.call(this);
    },

    /**
     * @returns {Promise<Object>}
     * @throws {Error} If underlying OpenLayers object not initialized (incorrect initialization, already destroy).
     */
    async resolveOlObject() {
      await this.$createPromise;
      return this.$olObject || function (e) {
        throw e;
      }(new OLObjectNotInitializedError(`${this.vmName} OpenLayers object is undefined`));
    },

    /**
     * @return {Promise}
     */
    async $nextTickPromise() {
      return new Promise(this.$nextTick.bind(this));
    },

    /**
     * @return {string|number}
     */
    getId() {
      return coalesce(this.$olObject && this.getIdInternal(), this.currentId);
    },

    /**
     * @return {*}
     * @protected
     */
    getIdInternal() {
      if (this.$olObject instanceof Object$1) {
        return this.$olObject.get('id');
      }

      return this.$olObject.id;
    },

    /**
     * @param {string|number} id
     */
    setId(id) {
      assert(id != null && id !== '', 'Invalid id');

      if (this.currentId !== id) {
        this.currentId = id;
      }

      this.$olObject && this.setIdInternal(id);
    },

    /**
     * @param {*} id
     * @protected
     */
    setIdInternal(id) {
      if (this.$olObject instanceof Object$1) {
        if (this.$olObject.get('id') !== id) {
          this.$olObject.set('id', id);
        }

        return;
      }

      if (this.$olObject.id !== id) {
        this.$olObject.id = id;
      }
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async changed() {
      this.rev++;
      await this.$nextTickPromise();
    },

    /**
     * @param {string|number} value
     * @protected
     */
    idChanged(value) {
      this.setId(value);
    },

    /**
     * @param {string|number} value
     * @protected
     */
    currentIdChanged(value) {
      if (value === this.id) return;
      this.$emit('update:id', value);
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prevValue
     * @protected
     */
    olObjIdentChanged(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.$olObject) {
        this.setInstance(value, this.$olObject);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    },

    /**
     * @protected
     */
    syncNonObservable() {
      this.setId(this.getId());
    }

  }
};

function defineDebounceMethods() {
  this.debounceRefresh = debounce(this.refresh.bind(this), FRAME_TIME);
  this.debounceRemount = debounce(this.remount.bind(this), FRAME_TIME);
  this.debounceRecreate = debounce(this.recreate.bind(this), FRAME_TIME);
  this.debounceChanged = debounce(this.changed.bind(this), FRAME_TIME);
}

function defineServices$i() {
  Object.defineProperties(this, {
    /**
     * @type {{warn: (function(...[*]): void), log: (function(...[*]): void), error: (function(...[*]): void)}}
     */
    $logger: {
      enumerable: true,
      get: () => this._logger
    },

    /**
     * @type {string}
     */
    $olObjectState: {
      enumerable: true,
      get: () => this._olObjectState
    },

    /**
     * @type {module:ol/Object~BaseObject|undefined}
     */
    $olObject: {
      enumerable: true,
      get: () => this._olObject
    },
    $olObjectEvents: {
      enumerable: true,
      get: () => this._olObjectEvents
    },

    /**
     * @type {Promise<void>}
     */
    $createPromise: {
      enumerable: true,
      get: () => newLifecyclePromise.call(this, OlObjectAction.CREATE, OlObjectEvent.CREATED, {
        [OlObjectState.CREATING]: [OlObjectAction.CREATE, OlObjectEvent.CREATED]
      })
    },

    /**
     * @type {Promise<void>}
     */
    $mountPromise: {
      enumerable: true,
      get: () => this.$createPromise.then(() => newLifecyclePromise.call(this, OlObjectAction.MOUNT, OlObjectEvent.MOUNTED, {
        [OlObjectState.CREATING]: [OlObjectAction.CREATE, OlObjectEvent.CREATED],
        [OlObjectState.MOUNTING]: [OlObjectAction.MOUNT, OlObjectEvent.MOUNTED]
      }))
    },

    /**
     * @type {Promise<void>}
     */
    $unmountPromise: {
      enumerable: true,
      get: () => this.$mountPromise.then(() => newLifecyclePromise.call(this, OlObjectAction.UNMOUNT, OlObjectEvent.UNMOUNTED, {
        [OlObjectState.CREATING]: [OlObjectAction.CREATE, OlObjectEvent.CREATED],
        [OlObjectState.MOUNTING]: [OlObjectAction.MOUNT, OlObjectEvent.MOUNTED],
        [OlObjectState.UNMOUNTING]: [OlObjectAction.UNMOUNT, OlObjectEvent.UNMOUNTED]
      }))
    },

    /**
     * @type {Promise<void>}
     */
    $destroyPromise: {
      enumerable: true,
      get: () => this.$unmountPromise.then(() => newLifecyclePromise.call(this, OlObjectAction.DESTROY, OlObjectEvent.DESTROYED, {
        [OlObjectState.CREATING]: [OlObjectAction.CREATE, OlObjectEvent.CREATED],
        [OlObjectState.MOUNTING]: [OlObjectAction.MOUNT, OlObjectEvent.MOUNTED],
        [OlObjectState.UNMOUNTING]: [OlObjectAction.UNMOUNT, OlObjectEvent.UNMOUNTED],
        [OlObjectState.DESTROYING]: [OlObjectAction.DESTROY, OlObjectEvent.DESTROYED]
      }))
    }
  });
}

function newOlObjectEventsObs() {
  return merge(...Object.values(OlObjectEvent).map(name => fromVueEvent(this.$eventBus, name, args => ({
    name,
    args: isArray(args) ? args : [args]
  })).pipe(filter(_ref => {
    let {
      args
    } = _ref;
    return args[0] === this || args[1] === this;
  })))).pipe(publishReplay(), refCount());
}

function newLifecyclePromise(action, endEvent, startStates) {
  const newFinishObs = (action, endEvent) => race(this.$olObjectEvents.pipe(filter(_ref2 => {
    let {
      name
    } = _ref2;
    return name === endEvent;
  })), this.$olObjectEvents.pipe(filter(_ref3 => {
    let {
      name,
      args
    } = _ref3;
    return name === OlObjectEvent.ERROR && args[0] instanceof LifecycleError && args[0].action === action;
  })));

  return merge(newFinishObs(action, endEvent), this.$olObjectEvents.pipe(filter(_ref4 => {
    let {
      name,
      args
    } = _ref4;
    return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
  }))).pipe(first(), mergeMap(evt => {
    let obs = of(evt); // If at the time of CancelError the ol object stay in some intermediate state
    // we need to delay observable emit until current hook complete

    if (evt.name === OlObjectEvent.ERROR && evt.args[0] instanceof CanceledError && startStates[this.$olObjectState] != null) {
      obs = obs.pipe(delayWhen(() => newFinishObs(...startStates[this.$olObjectState])));
    }

    return obs;
  }), mergeMap(evt => {
    if (evt.name === OlObjectEvent.ERROR) {
      return throwError(evt.args[0]);
    }

    return of(evt);
  }), map(_ref5 => {
    let {
      args
    } = _ref5;
    return args.length === 1 ? args[0] : args;
  })).toPromise();
}
/**
 * @param {boolean} [resetEventsObs=true]
 * @returns {Promise<void>}
 * @private
 */


async function execInit() {
  let resetEventsObs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  const prevState = this._olObjectState;

  if (resetEventsObs) {
    this._olObjectEvents = newOlObjectEventsObs.call(this);
  }

  this._olObjectEvents.subscribe();

  try {
    const canceled = await Promise.race([Promise.resolve(this.beforeInit()).then(() => false), this.$olObjectEvents.pipe(filter(_ref6 => {
      let {
        name,
        args
      } = _ref6;
      return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
    }), first()).toPromise().then(() => true)]);

    if (canceled) {
      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log(`ol object ${OlObjectAction.CREATE} canceled`);
      }

      return;
    }

    this._olObjectState = OlObjectState.CREATING;
    await this.init();
    this._olObjectState = OlObjectState.CREATED;

    if (process.env.VUELAYERS_DEBUG) {
      this.$logger.log(`ol object ${OlObjectEvent.CREATED}`);
    }

    this.$emit(OlObjectEvent.CREATED, this);
    this.$eventBus.$emit(OlObjectEvent.CREATED, this);
  } catch (err) {
    const lcErr = new LifecycleError(err, this.vmName, OlObjectAction.CREATE);
    this._olObjectState = prevState;
    this.$emit(OlObjectEvent.ERROR, lcErr, this);
    this.$eventBus.$emit(OlObjectEvent.ERROR, lcErr, this);
    throw lcErr;
  }
}
/**
 * @return {Promise<void>}
 * @private
 */


async function execMount() {
  const prevState = this._olObjectState;

  try {
    await this.$createPromise;
    const canceled = await Promise.race([Promise.resolve(this.beforeMount()).then(() => false), this.$olObjectEvents.pipe(filter(_ref7 => {
      let {
        name,
        args
      } = _ref7;
      return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
    }), first()).toPromise().then(() => true)]);

    if (canceled) {
      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log(`ol object ${OlObjectAction.MOUNT} canceled`);
      }

      return;
    }

    this._olObjectState = OlObjectState.MOUNTING;
    await this.mount();
    this._olObjectState = OlObjectState.MOUNTED;

    if (process.env.VUELAYERS_DEBUG) {
      this.$logger.log(`ol object ${OlObjectEvent.MOUNTED}`);
    }

    this.$emit(OlObjectEvent.MOUNTED, this);
    this.$eventBus.$emit(OlObjectEvent.MOUNTED, this);
  } catch (err) {
    if (err instanceof CanceledError) {
      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log(`ol object ${OlObjectAction.MOUNT} canceled`);
      }

      return;
    }

    const lcErr = new LifecycleError(err, this.vmName, OlObjectAction.MOUNT);
    this._olObjectState = prevState;
    this.$emit(OlObjectEvent.ERROR, lcErr, this);
    this.$eventBus.$emit(OlObjectEvent.ERROR, lcErr, this);
    throw lcErr;
  }
}
/**
 * @param {boolean} [fireCancel=false]
 * @return {void|Promise<void>}
 * @private
 */


async function execUnmount() {
  let fireCancel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  const prevState = this._olObjectState;

  if (fireCancel) {
    if ([OlObjectState.UNDEF, OlObjectState.CREATING, OlObjectState.CREATED, OlObjectState.MOUNTING].includes(this.$olObjectState)) {
      const err = new CanceledError(`${this.vmName} ol object lifecycle canceled`);
      this.$emit(OlObjectEvent.ERROR, err, this);
      this.$eventBus.$emit(OlObjectEvent.ERROR, err, this);
    }
  }

  try {
    try {
      await this.$mountPromise;
    } catch (err) {
      if (err instanceof CanceledError) {
        if (this.$olObjectState !== OlObjectState.MOUNTED) {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log(`ol object ${OlObjectAction.UNMOUNT} canceled`);
          }

          return;
        }
      } else {
        throw err;
      }
    }

    this._olObjectState = OlObjectState.UNMOUNTING;
    await this.unmount();
    this._olObjectState = OlObjectState.UNMOUNTED;

    if (process.env.VUELAYERS_DEBUG) {
      this.$logger.log(`ol object ${OlObjectEvent.UNMOUNTED}`);
    }

    this.$emit(OlObjectEvent.UNMOUNTED, this);
    this.$eventBus.$emit(OlObjectEvent.UNMOUNTED, this);
  } catch (err) {
    const lcErr = new LifecycleError(err, this.vmName, OlObjectAction.UNMOUNT);
    this._olObjectState = prevState;
    this.$emit(OlObjectEvent.ERROR, this, lcErr);
    this.$eventBus.$emit(OlObjectEvent.ERROR, this, lcErr);
    throw lcErr;
  }
}
/**
 * @returns {Promise<void>}
 * @private
 */


async function execDeinit() {
  const prevState = this._olObjectState;

  try {
    try {
      await this.$unmountPromise;
    } catch (err) {
      if (err instanceof CanceledError) {
        if (this.$olObjectState !== OlObjectState.CREATED) {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log(`ol object ${OlObjectAction.DESTROY} canceled`);
          }

          return;
        }
      } else {
        throw err;
      }
    }

    this._olObjectState = OlObjectState.DESTROYING;
    await this.deinit();
    this._olObjectState = OlObjectState.DESTROYED;

    if (process.env.VUELAYERS_DEBUG) {
      this.$logger.log(`ol object ${OlObjectEvent.DESTROYED}`);
    }

    this.$emit(OlObjectEvent.DESTROYED, this);
    this.$eventBus.$emit(OlObjectEvent.DESTROYED, this);
  } catch (err) {
    const lcErr = new LifecycleError(err, this.vmName, OlObjectAction.DESTROY);
    this._olObjectState = prevState;
    this.$emit(OlObjectEvent.ERROR, this, lcErr);
    this.$eventBus.$emit(OlObjectEvent.ERROR, this, lcErr);
    throw lcErr;
  }
}

function subscribeToOlObjectEvents() {
  if (this.$olObject instanceof Observable) {
    const setterKey = addPrefix('set');
    const propChanges = fromOlChangeEvent(this.$olObject, ['id'], true, evt => ({ ...evt,
      setter: this[setterKey(evt.prop)]
    }));
    this.subscribeTo(propChanges, _ref8 => {
      let {
        setter,
        value
      } = _ref8;
      return setter(value);
    });
    this.subscribeTo(merge(fromOlEvent(this.$olObject, EventType.CHANGE), fromOlEvent(this.$olObject, ObjectEventType.PROPERTYCHANGE)), this.debounceChanged.bind(this));
    this.subscribeTo(fromOlEvent(this.$olObject, EventType.ERROR), evt => this.$emit(OlObjectEvent.ERROR, evt));
  } else {
    this.subscribeTo(interval(FRAME_TIME), this.syncNonObservable.bind(this));
  }
}

class LifecycleError extends Error {
  constructor(err, vmName, action) {
    if (err instanceof LifecycleError) {
      err = err.err;
    }

    const baseMessage = `${vmName} ${action} ol object failed`;
    const message = `${baseMessage}: ${err.message}`;
    super(message);

    _defineProperty(this, "name", 'LifecycleError');

    this.vmName = vmName;
    this.action = action;
    this.err = err;

    if (err.stack) {
      this.stack = `${baseMessage}: ${err.stack}`;
    } else {
      if (isFunction(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
    }
  }

}
class CanceledError extends Error {
  constructor(message) {
    super(message);

    _defineProperty(this, "name", 'CanceledError');

    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }

}
function isCreateError(err) {
  return err instanceof LifecycleError && err.action === OlObjectAction.CREATE;
}
function isMountError(err) {
  return err instanceof LifecycleError && err.action === OlObjectAction.MOUNT;
}
function isUnmountError(err) {
  return err instanceof LifecycleError && err.action === OlObjectAction.UNMOUNT;
}
function isDestroyError(err) {
  return err instanceof LifecycleError && err.action === OlObjectAction.DESTROY;
}
class OLObjectNotInitializedError extends Error {
  constructor(message) {
    super(message);

    _defineProperty(this, "name", 'OLObjectNotInitializedError');

    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }

}
function makeChangeOrRecreateWatchers(props) {
  let deepProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return makeWatchers(props, prop => ({
    deep: deepProps.includes(prop),

    handler() {
      const handler = this[`${prop}Changed`];

      if (isFunction(handler)) {
        return handler(...arguments);
      }

      if (isEqual(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1])) return;

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log(`${prop} changed, scheduling recreate... %O ===> %O`, arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 0 ? undefined : arguments[0]);
      }

      return this.scheduleRecreate();
    }

  }));
}

const serialize = value => {
  if (value == null) return;
  return typeof value === 'object' ? JSON.stringify(value) : value;
};

const cleanArcGisSourceParams = params => cleanSourceParams(params, ['FORMAT', 'F', 'LAYERS', 'LAYERDEFS', 'DYNAMICLAYERS', 'DPI', 'TRANSPARENT', 'TIME', 'LAYERTIMEOPTIONS', 'GDBVERSION', 'MAPSCALE', 'ROTATION', 'DATUMTRANSFORMATIONS', 'MAPRANGEVALUES', 'LAYERRANGEVALUES', 'LAYERPARAMETERVALUES', 'HISTORICMOMENT']);
/**
 * Shared ArcGIS source params and methods.
 */


var arcgisSource = {
  props: {
    // ArcGIS params from https://developers.arcgis.com/rest/services-reference/export-map.htm

    /**
     * @type {boolean}
     */
    hidpi: {
      type: Boolean,
      default: true
    },

    /**
     * @type {string}
     */
    format: {
      type: String,
      default: 'PNG32'
    },

    /**
     * @type {string|string[]|undefined}
     */
    layers: [String, Array],

    /**
     * @type {Object|string|undefined}
     */
    layerDefs: [Object, String],

    /**
     * @type {Object[]|string|undefined}
     */
    dynamicLayers: [Array, String],

    /**
     * @type {number|undefined}
     */
    dpi: Number,

    /**
     * @type {boolean}
     */
    transparent: {
      type: Boolean,
      default: true
    },

    /**
     * @type {string|string[]|undefined}
     */
    time: [String, Array],

    /**
     * @type {Object|string|undefined}
     */
    layerTimeOptions: [Object, String],

    /**
     * @type {string|undefined}
     */
    gdbVersion: String,

    /**
     * @type {string|undefined}
     */
    mapScale: String,

    /**
     * @type {number|undefined}
     */
    rotation: Number,

    /**
     * @type {Array|string|undefined}
     */
    datumTransformations: [Array, String],

    /**
     * @type {Array|string|undefined}
     */
    mapRangeValues: [Array, String],

    /**
     * @type {Array|string|undefined}
     */
    layerRangeValues: [Array, String],

    /**
     * @type {Array|string|undefined}
     */
    layerParameterValues: [Array, String],

    /**
     * @type {number|undefined}
     */
    historicMoment: Number,

    /**
     * Additional ArcGIS request parameters
     * @params {Object|undefined}
     */
    params: Object
  },

  data() {
    return {
      currentParams: undefined
    };
  },

  computed: {
    /**
     * @returns {string|undefined}
     */
    inputLayers() {
      return isArray(this.layers) ? this.layers.join(',') : this.layers;
    },

    /**
     * @type {string|undefined}
     */
    inputTime() {
      return isArray(this.time) ? this.time.join(',') : this.time;
    },

    /**
     * @return {undefined|string}
     */
    inputLayerDefs() {
      return serialize(this.layerDefs);
    },

    /**
     * @return {undefined|string}
     */
    inputDynamicLayers() {
      return serialize(this.dynamicLayers);
    },

    /**
     * @return {undefined|string}
     */
    inputLayerTimeOptions() {
      return serialize(this.layerTimeOptions);
    },

    /**
     * @return {undefined|string}
     */
    inputDatumTransformations() {
      return serialize(this.datumTransformations);
    },

    /**
     * @return {undefined|string}
     */
    inputMapRangeValues() {
      return serialize(this.mapRangeValues);
    },

    /**
     * @return {undefined|string}
     */
    inputLayerRangeValues() {
      return serialize(this.layerRangeValues);
    },

    /**
     * @return {undefined|string}
     */
    inputLayerParameterValues() {
      return serialize(this.layerParameterValues);
    },

    /**
     * @return {undefined|string}
     */
    inputHistoricMoment() {
      return serialize(this.historicMoment);
    },

    /**
     * @returns {Object|null}
     */
    customParams() {
      return this.params ? cleanArcGisSourceParams(this.params) : undefined;
    },

    /**
     * @returns {Object}
     */
    inputParams() {
      return { ...(this.customParams || {}),
        LAYERS: this.inputLayers,
        FORMAT: this.format,
        LAYERDEFS: this.inputLayerDefs,
        DYNAMICLAYERS: this.inputDynamicLayers,
        DPI: this.dpi,
        TRANSPARENT: this.transparent,
        TIME: this.inputTime,
        LAYERTIMEOPTIONS: this.inputLayerTimeOptions,
        GDBVERSION: this.gdbVersion,
        MAPSCALE: this.mapScale,
        ROTATION: this.rotation,
        DATUMTRANSFORMATIONS: this.inputDatumTransformations,
        MAPRANGEVALUES: this.inputMapRangeValues,
        LAYERRANGEVALUES: this.inputLayerRangeValues,
        LAYERPARAMETERVALUES: this.inputLayerParameterValues,
        HISTORICMOMENT: this.inputHistoricMoment
      };
    },

    ... /*#__PURE__*/reduce(['format', 'inputLayers', 'inputLayerDefs', 'inputDynamicLayers', 'dpi', 'transparent', 'inputTime', 'inputLayerTimeOptions', 'gdbVersion', 'mapScale', 'rotation', 'inputDatumTransformations', 'inputMapRangeValues', 'inputLayerRangeValues', 'inputLayerParameterValues', 'inputHistoricMoment'], (props, inProp) => {
      const prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      const curProp = 'current' + upperFirst(prop);

      props[curProp] = function () {
        return coalesce((this.currentParams || {})[prop.toUpperCase()], (this.inputParams || {})[prop.toUpperCase()]);
      };

      return props;
    }, {})
  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (!isEqual(this.currentParams, this.$source.getParams())) {
        this.currentParams = this.$source.getParams();
      }
    },

    ... /*#__PURE__*/makeWatchers(['currentFormat', 'currentLayers', 'currentLayerDefs', 'currentDynamicLayers', 'currentDpi', 'currentTransparent', 'currentTime', 'currentLayerTimeOptions', 'currentGdbVersion', 'currentMapScale', 'currentRotation', 'currentDatumTransformations', 'currentMapRangeValues', 'currentLayerRangeValues', 'currentLayerParameterValues', 'currentHistoricMoment'], curProp => function (value) {
      const prop = lowerFirst(curProp.slice(7));
      const inProp = hasProp(this, 'input' + upperFirst(prop)) ? 'input' + upperFirst(prop) : prop;
      if (isEqual(value, this[inProp])) return;
      this.$emit('update:' + prop, isObjectLike(value) ? clonePlainObject(value) : value);
    }),
    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['hidpi', 'inputParams', 'currentParams'], ['inputParams', 'currentParams'])
  },

  created() {
    this.currentParams = this.inputParams && clonePlainObject(this.inputParams);
  },

  methods: {
    /**
     * @returns {Object}
     */
    getParams() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getParams(), this.currentParams);
    },

    /**
     * @param {Object} params
     */
    updateParams(params) {
      params = reduce({ ...this.currentParams,
        ...params
      }, (params, value, name) => ({ ...params,
        [name.toUpperCase()]: value
      }), {});

      if (!isEqual(params, this.currentParams)) {
        this.currentParams = params;
      }

      if (this.$source && !isEqual(params, this.$source.getParams())) {
        this.$source.updateParams(params);
      }
    },

    /**
     * @param {string} param
     * @param {*} value
     */
    updateParam(param, value) {
      this.updateParams({
        [param.toUpperCase()]: value
      });
    },

    /**
     * @param {Object|undefined} value
     * @protected
     */
    inputParamsChanged(value) {
      this.updateParams(value);
    },

    /**
     * @param {Object|undefined} value
     * @protected
     */
    currentParamsChanged(value) {
      value = value ? cleanArcGisSourceParams(value) : undefined;
      if (isEqual(value, this.customParams)) return;
      this.$emit('update:params', value && clonePlainObject(value));
    }

  }
};

/**
 * Mixin with helpers for projection transforms between current view projection and global defined projection.
 */

var projTransforms = {
  computed: {
    /**
     * @return {module:ol/proj~ProjectionLike}
     */
    resolvedViewProjection() {
      return coalesce(this.viewProjection, // may or may not be present
      EPSG_3857);
    },

    /**
     * @return {module:ol/proj~ProjectionLike}
     */
    resolvedDataProjection() {
      var _this$$options;

      return coalesce(this.dataProjection, // may or may not be present
      (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, // may or may not be present
      this.resolvedViewProjection);
    }

  },
  watch: {
    resolvedViewProjection() {
      return this.resolvedViewProjectionChanged(...arguments);
    },

    resolvedDataProjection() {
      return this.resolvedDataProjectionChanged(...arguments);
    }

  },
  methods: {
    pointToViewProj(point) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformPoint(point, this.resolvedDataProjection, this.resolvedViewProjection, precision);
    },

    pointToDataProj(point) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformPoint(point, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    lineToViewProj(line) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformLine(line, this.resolvedDataProjection, this.resolvedViewProjection, precision);
    },

    lineToDataProj(line) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformLine(line, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    polygonToViewProj(polygon) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformPolygon(polygon, this.resolvedDataProjection, this.resolvedViewProjection, precision);
    },

    polygonToDataProj(polygon) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformPolygon(polygon, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    multiPointToViewProj(multiPoint) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformMultiPoint(multiPoint, this.resolvedDataProjection, this.resolvedViewProjection, precision);
    },

    multiPointToDataProj(multiPoint) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformMultiPoint(multiPoint, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    multiLineToViewProj(multiLine) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformMultiLine(multiLine, this.resolvedDataProjection, this.resolvedViewProjection, precision);
    },

    multiLineToDataProj(multiLine) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformMultiLine(multiLine, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    multiPolygonToViewProj(multiPolygon) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformMultiPolygon(multiPolygon, this.resolvedDataProjection, this.resolvedViewProjection, precision);
    },

    multiPolygonToDataProj(multiPolygon) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformMultiPolygon(multiPolygon, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    extentToViewProj(extent) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformExtent$1(extent, this.resolvedDataProjection, this.resolvedViewProjection, precision);
    },

    extentToDataProj(extent) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return transformExtent$1(extent, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    writeGeometryInDataProj(geometry) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return writeGeoJsonGeometry(geometry, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    writeGeometryInViewProj(geometry) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return writeGeoJsonGeometry(geometry, this.resolvedViewProjection, this.resolvedViewProjection, precision);
    },

    readGeometryInDataProj(geometry) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return readGeoJsonGeometry(geometry, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    readGeometryInViewProj(geometry) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return readGeoJsonGeometry(geometry, this.resolvedViewProjection, this.resolvedViewProjection, precision);
    },

    writeFeatureInDataProj(feature) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return writeGeoJsonFeature(feature, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    writeFeatureInViewProj(feature) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return writeGeoJsonFeature(feature, this.resolvedViewProjection, this.resolvedViewProjection, precision);
    },

    readFeatureInDataProj(feature) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return readGeoJsonFeature(feature, this.resolvedViewProjection, this.resolvedDataProjection, precision);
    },

    readFeatureInViewProj(feature) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
      return readGeoJsonFeature(feature, this.resolvedViewProjection, this.resolvedViewProjection, precision);
    },

    /**
     * @param {string} value
     * @param {string} prev
     * @protected
     */
    resolvedViewProjectionChanged(value, prev) {
      if (value === prev) return;
      this.$emit('update:viewProjection', value);
    },

    /**
     * @param {string} value
     * @param {string} prev
     * @protected
     */
    resolvedDataProjectionChanged(value, prev) {
      if (value === prev) return;
      this.$emit('update:dataProjection', value);
    }

  }
};

/**
 * Renders stub VNode for component.
 */

var stubVNode = {
  /**
   * @param {function} h
   * @returns {VNode}
   */
  render(h) {
    var _this$$options;

    const options = ((_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.stubVNode) || {}; // render as HTML comment

    if (options.empty) {
      const vnode = h();

      if (typeof options.empty === 'string') {
        vnode.text = options.empty;
      } else if (typeof options.empty === 'function') {
        vnode.text = options.empty.call(this);
      }

      return vnode;
    }

    let children;

    if (options.slots === false) {
      children = undefined;
    } else {
      children = extractChildren(this.$slots, options.slots);
    }

    const attrs = typeof options.attrs === 'function' ? options.attrs.call(this) : options.attrs;
    const data = {
      attrs,
      style: {
        display: 'none !important'
      }
    };
    return h(options.tag || 'i', data, children);
  }

};

var waitForMap = {
  methods: {
    async beforeInit() {
      try {
        await waitFor(() => this.$mapVm != null, race(this.$olObjectEvents.pipe(filter(_ref => {
          let {
            name,
            args
          } = _ref;
          return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
        })), fromVueEvent(this.$eventBus, OlObjectEvent.ERROR).pipe(filter(_ref2 => {
          let [err, vm] = _ref2;
          return isCreateError(err) && hasProp(vm, '$map') && hasAncestorVm(this, vm);
        }))).pipe(mapTo(stubTrue())));

        if (this.$mapVm.resolvedViewProjection !== this.viewProjection) {
          this.viewProjection = this.$mapVm.resolvedViewProjection;
        }

        if (this.$mapVm.resolvedDataProjection !== this.dataProjection) {
          this.dataProjection = this.$mapVm.resolvedDataProjection;
        }

        this.subscribeTo(fromVueWatcher(this, () => this.$mapVm.resolvedViewProjection), _ref3 => {
          let {
            value
          } = _ref3;

          if (value !== this.viewProjection) {
            this.viewProjection = value;
          }
        });
        this.subscribeTo(fromVueWatcher(this, () => this.$mapVm.resolvedDataProjection), _ref4 => {
          let {
            value
          } = _ref4;

          if (value !== this.dataProjection) {
            this.dataProjection = value;
          }
        });
        await this.$nextTickPromise();
        return olCmp.methods.beforeInit.call(this);
      } catch (err) {
        err.message = `${this.vmName} wait for $mapVm injection: ${err.message}`;
        throw err;
      }
    }

  }
};

/**
 * Base layer mixin.
 */

var baseLayer = {
  mixins: [stubVNode, projTransforms, olCmp, waitForMap],
  stubVNode: {
    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    // ol/layer/Base

    /**
     * A CSS class name to set to the layer element.
     * @type {string}
     */
    className: {
      type: String,
      default: 'ol-layer'
    },

    /**
     * @type {number}
     */
    opacity: {
      type: Number,
      default: 1
    },

    /**
     * @type {boolean}
     */
    visible: {
      type: Boolean,
      default: true
    },

    /**
     * @type {number[]|undefined}
     */
    extent: {
      type: Array,
      validator: value => value.length === 4 && value.every(isNumber)
    },

    /**
     * @type {string|undefined}
     */
    extentProjection: {
      type: String,
      validator: value => !!get(value)
    },

    /**
     * @type {number|undefined}
     */
    zIndex: Number,

    /**
     * @type {number|undefined}
     */
    minResolution: Number,

    /**
     * @type {number|undefined}
     */
    maxResolution: Number,

    /**
     * @type {number|undefined}
     */
    minZoom: Number,

    /**
     * @type {number|undefined}
     */
    maxZoom: Number
  },

  data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentExtentViewProj: roundExtent(this.extent),
      currentMaxResolution: this.maxResolution,
      currentMinResolution: this.minResolution,
      currentMaxZoom: this.maxZoom,
      currentMinZoom: this.minZoom,
      currentOpacity: this.opacity,
      currentVisible: this.visible,
      currentZIndex: this.zIndex
    };
  },

  computed: {
    resolvedExtentProjection() {
      return coalesce(this.extentProjection, this.resolvedDataProjection);
    },

    extentDataProj() {
      return roundExtent(this.extent);
    },

    extentViewProj() {
      return transformExtent$1(this.extent, this.resolvedExtentProjection, this.resolvedViewProjection);
    },

    currentExtentDataProj() {
      return transformExtent$1(this.currentExtentViewProj, this.resolvedViewProjection, this.resolvedExtentProjection);
    }

  },
  watch: {
    rev() {
      if (!this.$layer) return;

      if (!isEqual(this.currentExtentViewProj, this.$layer.getExtent())) {
        this.currentExtentViewProj = this.$layer.getExtent();
      }

      if (this.currentMaxResolution !== this.$layer.getMaxResolution()) {
        this.currentMaxResolution = this.$layer.getMaxResolution();
      }

      if (this.currentMinResolution !== this.$layer.getMinResolution()) {
        this.currentMinResolution = this.$layer.getMinResolution();
      }

      if (this.currentMaxZoom !== this.$layer.getMaxZoom()) {
        this.currentMaxZoom = this.$layer.getMaxZoom();
      }

      if (this.currentMinZoom !== this.$layer.getMinZoom()) {
        this.currentMinZoom = this.$layer.getMinZoom();
      }

      if (this.currentOpacity !== this.$layer.getOpacity()) {
        this.currentOpacity = this.$layer.getOpacity();
      }

      if (this.currentVisible !== this.$layer.getVisible()) {
        this.currentVisible = this.$layer.getVisible();
      }

      if (this.currentZIndex !== this.$layer.getZIndex()) {
        this.currentZIndex = this.$layer.getZIndex();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['className', 'opacity', 'currentOpacity', 'visible', 'currentVisible', 'extentViewProj', 'currentExtentDataProj', 'zIndex', 'currentZIndex', 'minResolution', 'currentMinResolution', 'maxResolution', 'currentMaxResolution', 'minZoom', 'currentMinZoom', 'maxZoom', 'currentMaxZoom'], ['extentViewProj', 'currentExtentDataProj'])
  },

  created() {
    var _this$extentViewProj;

    defineServices$h.call(this);
    this.currentExtentViewProj = (_this$extentViewProj = this.extentViewProj) === null || _this$extentViewProj === void 0 ? void 0 : _this$extentViewProj.slice();
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {Promise<module:ol/layer/Base~BaseLayer>}
     * @protected
     */
    async createOlObject() {
      return initializeLayer(await this.createLayer(), this.currentId);
    },

    /**
     * @return {module:ol/layer/Base~BaseLayer|Promise<module:ol/layer/Base~BaseLayer>}
     * @protected
     * @abstract
     */
    createLayer() {
      throw new Error(`${this.vmName} not implemented method: createLayer`);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$layersContaine;

      (_this$$layersContaine = this.$layersContainer) === null || _this$$layersContaine === void 0 ? void 0 : _this$$layersContaine.addLayer(this);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$layersContaine2;

      (_this$$layersContaine2 = this.$layersContainer) === null || _this$$layersContaine2 === void 0 ? void 0 : _this$$layersContaine2.removeLayer(this);
      return olCmp.methods.unmount.call(this);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(olCmp.methods.getServices.call(this), {
        get layerVm() {
          return vm;
        }

      });
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToLayerEvents$3.call(this);
    },

    /**
     * @returns {string|number}
     * @protected
     */
    getIdInternal() {
      return getLayerId(this.$layer);
    },

    /**
     * @param {string|number} id
     * @protected
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setLayerId(this.$layer, id);
    },

    /**
     * @return {Promise<module:ol/layer/Base~BaseLayer>}
     */
    resolveLayer: olCmp.methods.resolveOlObject,

    /**
     * @param {boolean} [viewProj=false]
     * @returns {number[]|undefined}
     */
    getExtent() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this.$layer) {
        return viewProj ? this.currentExtentViewProj : this.currentExtentDataProj;
      }

      const extent = this.$layer.getExtent();
      if (viewProj) return roundExtent(extent);
      return transformExtent$1(extent, this.resolvedViewProjection, this.resolvedExtentProjection);
    },

    /**
     * @param {number[]} extent
     * @param {boolean} [viewProj=false]
     */
    setExtent(extent) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(extent == null || isArray(extent) && extent.length === 4, 'Invalid extent');
      extent = viewProj ? roundExtent(extent) : transformExtent$1(extent, this.resolvedExtentProjection, this.resolvedViewProjection);

      if (!isEqual(extent, this.currentExtentViewProj)) {
        this.currentExtentViewProj = extent;
      }

      if (this.$layer && !isEqual(extent, this.$layer.getExtent())) {
        this.$layer.setExtent(extent);
      }
    },

    /**
     * @returns {number|undefined}
     */
    getMaxResolution() {
      var _this$$layer;

      return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getMaxResolution(), this.currentMaxResolution);
    },

    /**
     * @param {number} resolution
     */
    setMaxResolution(resolution) {
      resolution = Number(resolution);
      assert(isNumber(resolution), 'Invalid max resolution');

      if (resolution !== this.currentMaxResolution) {
        this.currentMaxResolution = resolution;
      }

      if (this.$layer && resolution !== this.$layer.getMaxResolution()) {
        this.$layer.setMaxResolution(resolution);
      }
    },

    /**
     * @returns {number|undefined}
     */
    getMinResolution() {
      var _this$$layer2;

      return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getMinResolution(), this.currentMinResolution);
    },

    /**
     * @param {number} resolution
     */
    setMinResolution(resolution) {
      resolution = Number(resolution);
      assert(isNumber(resolution), 'Invalid min resolution');

      if (resolution !== this.currentMinResolution) {
        this.currentMinResolution = resolution;
      }

      if (this.$layer && resolution !== this.$layer.getMinResolution()) {
        this.$layer.getMinResolution(resolution);
      }
    },

    /**
     * @returns {number}
     */
    getMaxZoom() {
      var _this$$layer3;

      return coalesce((_this$$layer3 = this.$layer) === null || _this$$layer3 === void 0 ? void 0 : _this$$layer3.getMaxZoom(), this.currentMaxZoom);
    },

    /**
     * @param {number} zoom
     */
    setMaxZoom(zoom) {
      zoom = Number(zoom);
      assert(isNumber(zoom), 'Invalid max zoom');

      if (zoom !== this.currentMaxZoom) {
        this.currentMaxZoom = zoom;
      }

      if (this.$layer && zoom !== this.$layer.getMaxZoom()) {
        this.$layer.setMaxZoom(zoom);
      }
    },

    /**
     * @returns {number}
     */
    getMinZoom() {
      var _this$$layer4;

      return coalesce((_this$$layer4 = this.$layer) === null || _this$$layer4 === void 0 ? void 0 : _this$$layer4.getMinZoom(), this.currentMinZoom);
    },

    /**
     * @param {number} zoom
     */
    setMinZoom(zoom) {
      zoom = Number(zoom);
      assert(isNumber(zoom), 'Invalid min zoom');

      if (zoom !== this.currentMinZoom) {
        this.currentMinZoom = zoom;
      }

      if (this.$layer && zoom !== this.$layer.getMinZoom()) {
        this.$layer.setMinZoom(zoom);
      }
    },

    /**
     * @returns {number}
     */
    getOpacity() {
      var _this$$layer5;

      return coalesce((_this$$layer5 = this.$layer) === null || _this$$layer5 === void 0 ? void 0 : _this$$layer5.getOpacity(), this.currentOpacity);
    },

    /**
     * @param {number} opacity
     */
    setOpacity(opacity) {
      opacity = Number(opacity);
      assert(isNumber(opacity), 'Invalid opacity');

      if (opacity !== this.currentOpacity) {
        this.currentOpacity = opacity;
      }

      if (this.$layer && opacity !== this.$layer.getOpacity()) {
        this.$layer.setOpacity(opacity);
      }
    },

    /**
     * @returns {boolean}
     */
    getVisible() {
      var _this$$layer6;

      return coalesce((_this$$layer6 = this.$layer) === null || _this$$layer6 === void 0 ? void 0 : _this$$layer6.getVisible(), this.currentVisible);
    },

    /**
     * @param {boolean} visible
     */
    setVisible(visible) {
      visible = !!visible;

      if (visible !== this.currentVisible) {
        this.currentVisible = visible;
      }

      if (this.$layer && visible !== this.$layer.getVisible()) {
        this.$layer.setVisible(visible);
      }
    },

    /**
     * @returns {number}
     */
    getZIndex() {
      var _this$$layer7;

      return coalesce((_this$$layer7 = this.$layer) === null || _this$$layer7 === void 0 ? void 0 : _this$$layer7.getZIndex(), this.currentZIndex);
    },

    /**
     * @param {number} zIndex
     */
    setZIndex(zIndex) {
      zIndex = Number(zIndex);
      assert(isNumber(zIndex), 'Invalid zIndex');

      if (zIndex !== this.currentZIndex) {
        this.currentZIndex = zIndex;
      }

      if (this.$layer && zIndex !== this.$layer.getZIndex()) {
        this.$layer.setZIndex(zIndex);
      }
    },

    /**
     * @param {number[]} pixel
     * @return {boolean}
     */
    async isAtPixel(pixel) {
      const layer = await this.resolveLayer();
      return this.$mapVm.forEachLayerAtPixel(pixel, mapLayer => mapLayer === layer);
    },

    /**
     * @param {number} value
     * @protected
     */
    opacityChanged(value) {
      this.setOpacity(value);
    },

    /**
     * @param {number} value
     * @protected
     */
    currentOpacityChanged(value) {
      if (value === this.opacity) return;
      this.$emit('update:opacity', value);
    },

    /**
     * @param {boolean} value
     * @protected
     */
    visibleChanged(value) {
      this.setVisible(value);
    },

    /**
     * @param {boolean} value
     * @protected
     */
    currentVisibleChanged(value) {
      if (value === this.visible) return;
      this.$emit('update:visible', value);
    },

    /**
     * @param {number[]|undefined} value
     * @protected
     */
    extentViewProjChanged(value) {
      this.setExtent(value, true);
    },

    /**
     * @param {number[]|undefined} value
     * @protected
     */
    currentExtentDataProjChanged(value) {
      if (isEqual(value, this.extentDataProj)) return;
      this.$emit('update:extent', value.slice());
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    zIndexChanged(value) {
      this.setZIndex(value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    currentZIndexChanged(value) {
      if (value === this.zIndex) return;
      this.$emit('update:zIndex', value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    minResolutionChanged(value) {
      this.setMinResolution(value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    currentMinResolutionChanged(value) {
      if (value === this.minResolution) return;
      this.$emit('update:minResolution', value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    maxResolutionChanged(value) {
      this.setMaxResolution(value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    currentMaxResolutionChanged(value) {
      if (value === this.maxResolution) return;
      this.$emit('update:maxResolution', value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    minZoomChanged(value) {
      this.setMinZoom(value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    currentMinZoomChanged(value) {
      if (value === this.minZoom) return;
      this.$emit('update:minZoom', value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    maxZoomChanged(value) {
      this.setMaxZoom(value);
    },

    /**
     * @param {number|undefined} value
     * @protected
     */
    currentMaxZoomChanged(value) {
      if (value === this.maxZoom) return;
      this.$emit('update:maxZoom', value);
    }

  }
};

function defineServices$h() {
  Object.defineProperties(this, {
    /**
     * @type {module:ol/layer/Base~BaseLayer|undefined}
     */
    $layer: {
      enumerable: true,
      get: () => this.$olObject
    },

    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.mapVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.viewVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $layersContainer: {
      enumerable: true,
      get: () => {
        var _this$$services3;

        return (_this$$services3 = this.$services) === null || _this$$services3 === void 0 ? void 0 : _this$$services3.layersContainer;
      }
    }
  });
}

async function subscribeToLayerEvents$3() {
  const setterKey = addPrefix('set');
  const propChanges = fromOlChangeEvent(this.$layer, ['opacity', 'visible', 'zIndex', 'minResolution', 'maxResolution', 'minZoom', 'maxZoom', 'extent'], true, evt => ({ ...evt,
    setter: val => {
      const args = [val];

      if (evt.prop === 'extent') {
        args.push(true);
      }

      this[setterKey(evt.prop)](...args);
    }
  }));
  this.subscribeTo(propChanges, _ref => {
    let {
      setter,
      value
    } = _ref;
    return setter(value);
  });
}

/**
 * @typedef {module:ol/control/Control~Control|Object} ControlLike
 */

/**
 * Controls collection
 */

var controlsContainer = {
  mixins: [identMap, rxSubs],
  computed: {
    /**
     * @type {string|undefined}
     */
    controlsCollectionIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'controls_collection');
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['controlsCollectionIdent'])
  },

  created() {
    /**
     * @type {module:ol/Collection~Collection<module:ol/control/Control~Control>}
     * @private
     */
    this._controlsCollection = this.instanceFactoryCall(this.controlsCollectionIdent, () => new Collection());
    this._controlSubs = {};
    defineServices$g.call(this);
  },

  methods: {
    /**
     * @returns {{readonly controlsContainer: Object}}
     * @protected
     */
    getServices() {
      const vm = this;
      return {
        get controlsContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      subscribeToCollectionEvents$4.call(this);
    },

    /**
     * @param {ControlLike[]|module:ol/Collection~Collection<ControlLike>} defaultControls
     */
    initDefaultControls(defaultControls) {
      this.getControls().forEach(control => {
        if (control.get('vl_default')) {
          this.removeControl(control);
        }
      });
      let controls;

      if (isArray(defaultControls) || defaultControls instanceof Collection) {
        controls = defaultControls;
      } else if (defaultControls !== false) {
        controls = defaults(isPlainObject(defaultControls) ? defaultControls : undefined);
      }

      if (controls) {
        controls.forEach(control => control.set('vl_default', true));
        this.addControls(controls);
      }
    },

    /**
     * @param {ControlLike} control
     * @return {Control}
     */
    initializeControl(control) {
      var _control;

      control = ((_control = control) === null || _control === void 0 ? void 0 : _control.$control) || control;
      instanceOf(control, Control);
      return initializeControl(control);
    },

    /**
     * @param {ControlLike[]|module:ol/Collection~Collection<ControlLike>} controls
     */
    addControls(controls) {
      forEach(controls, this.addControl.bind(this));
    },

    /**
     * @param {ControlLike} control
     */
    addControl(control) {
      control = this.initializeControl(control);
      if (this.getControlById(getControlId(control))) return;
      this.$controlsCollection.push(control);
    },

    /**
     * @param {ControlLike[]|module:ol/Collection~Collection<ControlLike>} controls
     */
    removeControls(controls) {
      forEach(controls, this.removeControl.bind(this));
    },

    /**
     * @param {ControlLike} control
     */
    removeControl(control) {
      var _control2;

      control = this.getControlById(getControlId(((_control2 = control) === null || _control2 === void 0 ? void 0 : _control2.$control) || control));
      if (!control) return;
      this.$controlsCollection.remove(control);
    },

    /**
     * @return {void}
     */
    clearControls() {
      this.$controlsCollection.clear();
    },

    /**
     * @returns {Array<module:ol/control/Control~Control>}
     */
    getControls() {
      return this.$controlsCollection.getArray().slice();
    },

    /**
     * @returns {module:ol/Collection~Collection<module:ol/control/Control~Control>}
     */
    getControlsCollection() {
      return this._controlsCollection;
    },

    /**
     * @param {string|number} controlId
     * @returns {ControlLike}
     */
    getControlById(controlId) {
      return find(this.getControls(), control => getControlId(control) === controlId);
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prevValue
     * @protected
     */
    controlsCollectionIdentChanged(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.$controlsCollection) {
        this.setInstance(value, this.$controlsCollection);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    }

  }
};

function defineServices$g() {
  Object.defineProperties(this, {
    $controlsCollection: {
      enumerable: true,
      get: this.getControlsCollection
    }
  });
}

function subscribeToCollectionEvents$4() {
  const adds = fromOlEvent(this.$controlsCollection, CollectionEventType.ADD).pipe(map(evt => ({ ...evt,
    element: this.initializeControl(evt.element)
  })), tap(_ref => {
    let {
      element
    } = _ref;
    const uid = getUid(element);
    const propChanges = fromOlChangeEvent(element, 'id', true);
    this._controlSubs[uid] = this.subscribeTo(propChanges, this.scheduleRefresh.bind(this));
  }));
  const removes = fromOlEvent(this.$controlsCollection, CollectionEventType.REMOVE).pipe(tap(_ref2 => {
    let {
      element
    } = _ref2;
    const uid = getUid(element);

    if (this._controlSubs[uid]) {
      this.unsubscribe(this._controlSubs[uid]);
      delete this._controlSubs[uid];
    }
  }));
  const events = merge(adds, removes).pipe(bufferDebounceTime(FRAME_TIME));
  this.subscribeTo(events, async events => {
    await this.debounceChanged();
    forEach(events, _ref3 => {
      let {
        type,
        element
      } = _ref3;
      this.$emit(type + 'control', element); // todo remove in v0.13.x

      this.$emit(type + ':control', element);
    });
  });
}

/**
 * @typedef {Geometry|Object} GeometryLike
 */

/**
 * @typedef {Object} GeometryTarget
 * @property {function(): Geometry|undefined} getGeometry
 * @property {function(Geometry|undefined): void} setGeometry
 */

/**
 * Geometry container
 */

var geometryContainer = {
  mixins: [projTransforms],

  created() {
    this._geometry = undefined;
    this._geometryVm = undefined;
    defineService.call(this);
  },

  methods: {
    /**
     * @returns {{readonly geometryContainer: Object}}
     * @protected
     */
    getServices() {
      const vm = this;
      return {
        get geometryContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {GeometryTarget|undefined}
     * @protected
     */
    getGeometryTarget() {
      throw new Error(`${this.vmName} not implemented method: getGeometryTarget()`);
    },

    /**
     * @return {module:ol/geom/Geometry~Geometry|undefined}
     */
    getGeometry() {
      var _this$getGeometryTarg;

      return coalesce((_this$getGeometryTarg = this.getGeometryTarget()) === null || _this$getGeometryTarg === void 0 ? void 0 : _this$getGeometryTarg.getGeometry(), this._geometry);
    },

    /**
     * @return {Object}
     */
    getGeometryVm() {
      return this._geometryVm;
    },

    /**
     * @param {GeometryLike|undefined} geom
     * @param {boolean} [viewProj=false]
     */
    setGeometry(geom) {
      var _geom;

      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      geom = ((_geom = geom) === null || _geom === void 0 ? void 0 : _geom.$geometry) || geom;

      if (isGeoJSONGeometry(geom)) {
        if (viewProj) {
          geom = this.readGeometryInViewProj(geom);
        } else {
          geom = this.readGeometryInDataProj(geom);
        }
      }

      geom || (geom = undefined);
      assert(!geom || geom instanceof Geometry, 'Invalid geometry');
      const geomTarget = this.getGeometryTarget();

      if (geomTarget && geom !== geomTarget.getGeometry()) {
        geomTarget.setGeometry(geom);
        this.scheduleRefresh();
      }

      if (geom !== this._geometry) {
        var _geom2;

        this._geometry = geom;
        this._geometryVm = ((_geom2 = geom) === null || _geom2 === void 0 ? void 0 : _geom2.vm) && geom.vm[0];
        this.scheduleRefresh();
      }
    }

  }
};

function defineService() {
  Object.defineProperties(this, {
    $geometry: {
      enumerable: true,
      get: this.getGeometry
    },
    $geometryVm: {
      enumerable: true,
      get: this.getGeometryVm
    }
  });
}

/**
 * @typedef {
 *            module:ol/style/Style~Style |
 *            Array<module:ol/style/Style~Style> |
 *            module:ol/style/Style~StyleFunction
 *          } OlStyleLike
 */

/**
 * @typedef {Object} StyleTarget
 * @property {function(OlStyleLike|undefined): void} setStyle
 * @property {function(): OlStyleLike|undefined} getStyle
 */

/**
 * @typedef {OlStyleLike|Object} StyleLike
 */

/**
 * Style container mixin.
 */

var styleContainer = {
  created() {
    this._style = undefined;
    defineServices$f.call(this);
  },

  methods: {
    /**
     * @returns {{readonly styleContainer: Object}}
     * @protected
     */
    getServices() {
      const vm = this;
      return {
        get styleContainer() {
          return vm;
        }

      };
    },

    /**
     * Default style factory
     * @return {OlStyleLike|undefined}
     * @protected
     */
    getDefaultStyle() {},

    /**
     * Returns OL object that can be styled (i.e. has setStyle/getStyle methods) or undefined
     * @return {StyleTarget|undefined}
     * @protected
     * @abstract
     */
    getStyleTarget() {
      throw new Error(`${this.vmName} not implemented method: getStyleTarget()`);
    },

    /**
     * @return {StyleLike|undefined}
     */
    getStyle() {
      var _this$getStyleTarget;

      return coalesce((_this$getStyleTarget = this.getStyleTarget()) === null || _this$getStyleTarget === void 0 ? void 0 : _this$getStyleTarget.getStyle(), this._style);
    },

    /**
     * @param {StyleLike} style
     */
    addStyle(style) {
      if (!style) return;
      const olStyle = (style === null || style === void 0 ? void 0 : style.$style) || style;
      let currentStyle = this._style;

      if (isFunction(olStyle)) {
        if (currentStyle) {
          if (process.env.NODE_ENV !== 'production') {
            this.$logger.warn('Component already has style components among its descendants. ' + 'Avoid use of multiple vl-style-func or combining vl-style-func with vl-style-box on the same level.');
          }
        }

        currentStyle = style;
      } else {
        if (!isArray(currentStyle)) {
          if (currentStyle) {
            if (process.env.NODE_ENV !== 'production') {
              this.$logger.warn('Component already has style components among its descendants. ' + 'Avoid use of multiple vl-style-func or combining vl-style-func with vl-style-box on the same level.');
            }
          }

          currentStyle = [];
        }

        if (!currentStyle.includes(olStyle)) {
          currentStyle.push(olStyle);
        }
      }

      this.setStyle(currentStyle);
    },

    /**
     * @param {StyleLike|undefined} style
     */
    removeStyle(style) {
      var _style;

      if (!style) return;
      style = ((_style = style) === null || _style === void 0 ? void 0 : _style.$style) || style;
      let currentStyle = this._style;

      if (currentStyle === style) {
        currentStyle = undefined;
      } else if (isArray(currentStyle)) {
        currentStyle = currentStyle.filter(s => s !== style);

        if (currentStyle.length === 0) {
          currentStyle = undefined;
        }
      }

      this.setStyle(currentStyle);
    },

    /**
     * @param {StyleLike|undefined} style
     */
    setStyle(style) {
      style || (style = undefined);

      if (style) {
        if (hasProp(style, '$style') || hasProp(style, '$styleFunction')) {
          style = style.$style || style.$styleFunction;
        } else if (isArray(style)) {
          style = style.map(style => (style === null || style === void 0 ? void 0 : style.$style) || style);
        }

        if (isFunction(style)) {
          style = this.createStyleFunc(style, this.getDefaultStyle());
        } else {
          isArray(style) || (style = [style]);
          style.length > 0 || (style = undefined);
        }
      }

      const styleTarget = this.getStyleTarget();

      if (styleTarget && !isEqual(style, styleTarget.getStyle())) {
        styleTarget.setStyle(style);
        this.scheduleRefresh();
      }

      if (!isEqual(style, this._style)) {
        this._style = style;
        this.scheduleRefresh();
      }
    },

    /**
     * Style function factory
     * @param {StyleLike|undefined} style
     * @param {StyleLike|undefined} defaultStyle
     * @returns {module:ol/style/Style~StyleFunction}
     * @protected
     */
    createStyleFunc(style, defaultStyle) {
      return function __styleFunc(feature, resolution) {
        if (!feature.getGeometry()) return;
        let compiledStyle;

        if (style && isFunction(style)) {
          // style - custom ol/style/Style~StyleFunction
          compiledStyle = style(feature, resolution);
        } else if (isArray(style)) {
          // style - array of ol/style/Style objects
          compiledStyle = style.slice();
        } // not empty or null style


        if (compiledStyle == null || isArray(compiledStyle) && compiledStyle.length || compiledStyle instanceof Style) {
          return compiledStyle;
        } // fallback to default style


        if (defaultStyle) {
          return isFunction(defaultStyle) ? defaultStyle(feature, resolution) : defaultStyle;
        }

        return null;
      };
    }

  }
};

function defineServices$f() {
  Object.defineProperties(this, {
    $style: {
      enumerable: true,
      get: this.getStyle
    }
  });
}

/**
 * A vector object for geographic features with a geometry and other attribute properties,
 * similar to the features in vector file formats like **GeoJSON**.
 */

var feature = {
  mixins: [stubVNode, projTransforms, geometryContainer, styleContainer, olCmp, waitForMap],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    properties: {
      type: Object,
      default: stubObject
    }
  },

  data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentProperties: clonePlainObject(this.properties),
      currentGeometryName: 'geometry'
    };
  },

  computed: {
    geometryDataProj() {
      if (!(this.rev && this.$geometry)) return;
      return this.writeGeometryInDataProj(this.$geometry);
    },

    geometryViewProj() {
      if (!(this.rev && this.$geometry)) return;
      return this.writeGeometryInViewProj(this.$geometry);
    },

    pointDataProj() {
      return this.pointToDataProj(this.pointViewProj);
    },

    pointViewProj() {
      if (!(this.rev && this.$geometry)) return;
      return findPointOnSurface(this.$geometry);
    },

    style() {
      if (!(this.rev && this.$style)) return;
      let style = this.$style;
      if (isFunction(style)) return style;
      if (!style) return;
      isArray(style) || (style = [style]);
      return style.map(style => dumpStyle(style, geom => this.writeGeometryInDataProj(geom)));
    }

  },
  watch: {
    rev() {
      if (!this.$feature) return;

      if (!isEqual(this.currentProperties, getFeatureProperties(this.$feature))) {
        this.currentProperties = getFeatureProperties(this.$feature);
      }

      if (this.currentGeometryName !== this.$feature.getGeometryName()) {
        this.currentGeometryName = this.$feature.getGeometryName();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['properties', 'currentProperties', 'currentGeometryName', 'geometryDataProj', 'pointDataProj', 'style'], ['properties', 'currentProperties', 'geometryDataProj', 'pointDataProj', 'style'])
  },

  created() {
    defineServices$e.call(this);
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * Create feature without inner style applying, feature level style
     * will be applied in the layer level style function.
     * @return {module:ol/Feature~Feature}
     * @protected
     */
    createOlObject() {
      const feature = initializeFeature(this.createFeature(), this.currentId);
      feature.setGeometryName(this.currentGeometryName);
      feature.setGeometry(this.$geometry);
      feature.setStyle(this.$style);
      return feature;
    },

    /**
     * @returns {Feature}
     */
    createFeature() {
      return new Feature(this.currentProperties);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeMount() {
      try {
        await waitFor(() => this.$geometryVm != null, race(this.$olObjectEvents.pipe(filter(_ref => {
          let {
            name,
            args
          } = _ref;
          return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
        })), fromVueEvent(this.$eventBus, ObjectEventType.ERROR).pipe(filter(_ref2 => {
          let [err, vm] = _ref2;
          return (isCreateError(err) || isMountError(err)) && hasProp(vm, '$geometry') && hasAncestorVm(vm, this);
        }))).pipe(mapTo(stubTrue())));
        return olCmp.methods.beforeMount.call(this);
      } catch (err) {
        err.message = `${this.vmName} wait for $geometry failed: ${err.message}`;
        throw err;
      }
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$featuresContai;

      (_this$$featuresContai = this.$featuresContainer) === null || _this$$featuresContai === void 0 ? void 0 : _this$$featuresContai.addFeature(this);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$featuresContai2;

      (_this$$featuresContai2 = this.$featuresContainer) === null || _this$$featuresContai2 === void 0 ? void 0 : _this$$featuresContai2.removeFeature(this);
      return olCmp.methods.unmount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToEvents.call(this);
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(olCmp.methods.getServices.call(this), geometryContainer.methods.getServices.call(this), styleContainer.methods.getServices.call(this), {
        get featureVm() {
          return vm;
        }

      });
    },

    /**
     * @return {string|number}
     */
    getIdInternal() {
      return getFeatureId(this.$feature);
    },

    /**
     * @param {string|number} id
     * @return {void}
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setFeatureId(this.$feature, id);
    },

    /**
     * @return {Promise<Feature>}
     */
    resolveFeature: olCmp.methods.resolveOlObject,

    /**
     * @return {Feature}
     * @protected
     */
    getGeometryTarget() {
      return this.$feature;
    },

    /**
     * @return {Feature}
     * @protected
     */
    getStyleTarget() {
      return this.$feature;
    },

    /**
     * @return {string}
     */
    getGeometryName() {
      var _this$$feature;

      return coalesce((_this$$feature = this.$feature) === null || _this$$feature === void 0 ? void 0 : _this$$feature.getGeometryName(), this.currentGeometryName);
    },

    /**
     * @param {string} geometryName
     */
    setGeometryName(geometryName) {
      assert(isString(geometryName) && !isEmpty(geometryName), 'Invalid geometry name');

      if (geometryName !== this.currentGeometryName) {
        this.currentGeometryName = geometryName;
      }

      if (this.$feature && geometryName !== this.$feature.getGeometryName()) {
        this.$feature.setGeometryName(geometryName);
      }
    },

    /**
     * @return {Object}
     */
    getProperties() {
      return coalesce(this.$feature && getFeatureProperties(this.$feature), this.currentProperties);
    },

    /**
     * @param {Object} properties
     */
    setProperties(properties) {
      properties = getFeatureProperties({
        properties
      });

      if (!isEqual(properties, this.currentProperties)) {
        this.currentProperties = properties;
      }

      if (this.$feature && !isEqual(properties, getFeatureProperties(this.$feature))) {
        setFeatureProperties(this.$feature, properties);
      }
    },

    /**
     * Checks if feature lies at `pixel`.
     * @param {number[]} pixel
     * @return {Promise<boolean>}
     */
    async isAtPixel(pixel) {
      const selfFeature = await this.resolveFeature();
      let layerFilter;

      if (this.$layerVm) {
        const selfLayer = await this.$layerVm.resolveLayer();

        layerFilter = layer => layer === selfLayer;
      }

      return this.$mapVm.forEachFeatureAtPixel(pixel, feature => feature === selfFeature, {
        layerFilter
      });
    },

    /**
     * @param {Object|undefined} value
     * @protected
     */
    propertiesChanged(value) {
      this.setProperties(value);
    },

    /**
     * @param {Object|undefined} value
     * @protected
     */
    currentPropertiesChanged(value) {
      if (isEqual(value, this.properties)) return;
      this.$emit('update:properties', value && clonePlainObject(value));
    },

    /**
     * @param {string} value
     * @param {string} prev
     * @protected
     */
    currentGeometryNameChanged(value, prev) {
      if (value === prev) return;
      this.$emit('update:geometryName', value);
    },

    /**
     * @param {Object|undefined} value
     * @param {Object|undefined} prev
     * @protected
     */
    geometryDataProjChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:geometry', value && clonePlainObject(value));
    },

    /**
     * @param {Object|undefined} value
     * @param {Object|undefined} prev
     * @protected
     */
    pointDataProjChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:point', value && clonePlainObject(value));
    },

    /**
     * @param {Object|Function|Array|undefined} value
     * @param {Object|Function|Array|undefined} prev
     * @protected
     */
    styleChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:style', isObjectLike(value) ? clonePlainObject(value) : value);
    }

  }
};

function defineServices$e() {
  Object.defineProperties(this, {
    $feature: {
      enumerable: true,
      get: () => this.$olObject
    },
    $layerVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.layerVm;
      }
    },
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.mapVm;
      }
    },
    $featuresContainer: {
      enumerable: true,
      get: () => {
        var _this$$services3;

        return (_this$$services3 = this.$services) === null || _this$$services3 === void 0 ? void 0 : _this$$services3.featuresContainer;
      }
    }
  });
}

async function subscribeToEvents() {
  const propChanges = fromOlEvent(this.$feature, ObjectEventType.PROPERTYCHANGE, _ref3 => {
    let {
      key
    } = _ref3;

    switch (key) {
      case this.$feature.getGeometryName():
        return {
          prop: 'geometry',
          value: this.$feature.getGeometry(),
          setter: geom => this.setGeometry(geom, true)
        };

      default:
        return {
          prop: 'properties',
          value: getFeatureProperties(this.$feature),
          setter: this.setProperties
        };
    }
  }).pipe(distinctUntilChanged(isEqual));
  this.subscribeTo(propChanges, _ref4 => {
    let {
      setter,
      value
    } = _ref4;
    return setter(value);
  });
}

var featureHelper = {
  methods: {
    /**
     * @param {FeatureLike} feature
     * @param {boolean} [viewProj=false]
     * @return {Feature}
     * @protected
     */
    initializeFeature(feature) {
      var _feature;

      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      feature = ((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature;

      if (isPlainObject(feature)) {
        if (viewProj) {
          feature = this.readFeatureInViewProj(feature);
        } else {
          feature = this.readFeatureInDataProj(feature);
        }
      }

      return initializeFeature(feature);
    },

    /**
     * @param {module:ol/Feature~Feature} feature
     * @param {module:ol/Feature~Feature} newFeature
     * @protected
     */
    updateFeature(feature, newFeature) {
      var _this$$mapVm;

      if ((_this$$mapVm = this.$mapVm) !== null && _this$$mapVm !== void 0 && _this$$mapVm.isInteracting()) return;
      const featureJson = this.writeFeatureInViewProj(feature);
      const newFeatureJson = this.writeFeatureInViewProj(newFeature);
      if (isEqual(featureJson, newFeatureJson)) return;

      if (getFeatureId(feature) !== getFeatureId(newFeature)) {
        setFeatureId(feature, getFeatureId(newFeature));
      }

      const properties = getFeatureProperties(newFeature);
      const currentProperties = getFeatureProperties(feature);

      if (!isEqual(properties, currentProperties)) {
        setFeatureProperties(feature, properties);
      }

      const geomJson = get$1(newFeatureJson, `properties.${CIRCLE_SERIALIZE_PROP}`) || newFeatureJson.geometry || null;
      const currentGeomJson = get$1(featureJson, `properties.${CIRCLE_SERIALIZE_PROP}`) || featureJson.geometry || null;

      if (!isEqual(geomJson, currentGeomJson)) {
        feature.setGeometry(newFeature.getGeometry() || null);
      }

      const style = newFeature.getStyle();
      const currentStyle = feature.getStyle();

      if (isFunction(currentStyle) && isFunction(style)) {
        if (currentStyle !== style) {
          feature.setStyle(style);
        }
      } else if (isFunction(style)) {
        feature.setStyle(style);
      }

      const styleJson = get$1(newFeatureJson, `properties.${STYLE_SERIALIZE_PROP}`) || null;
      const currentStyleJson = get$1(featureJson, `properties.${STYLE_SERIALIZE_PROP}`) || null;

      if (!isEqual(styleJson, currentStyleJson)) {
        feature.setStyle(style);
      }
    }

  }
};

/**
 * @typedef {module:ol/Feature~Feature|Object} FeatureLike
 */

/**
 * Features container
 */

var featuresContainer = {
  mixins: [identMap, rxSubs, projTransforms, featureHelper],
  computed: {
    /**
     * @returns {string|undefined}
     */
    featuresCollectionIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'features_collection');
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['featuresCollectionIdent'])
  },

  created() {
    /**
     * @type {module:ol/Collection~Collection<module:ol/Feature~Feature>}
     * @private
     */
    this._featuresCollection = this.instanceFactoryCall(this.featuresCollectionIdent, () => new Collection());
    this._featureSubs = {};
    defineServices$d.call(this);
  },

  methods: {
    /**
     * @returns {{readonly featuresContainer: Object}}
     * @protected
     */
    getServices() {
      const vm = this;
      return {
        get featuresContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      subscribeToCollectionEvents$3.call(this);
    },

    /**
     * @param {FeatureLike[]|module:ol/Collection~Collection<FeatureLike>} features
     * @param {boolean} [viewProj=false]
     */
    addFeatures(features) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      forEach(features, feature => this.addFeature(feature, viewProj));
    },

    /**
     * @param {FeatureLike} feature
     * @param {boolean} [viewProj=false]
     */
    addFeature(feature) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      feature = this.initializeFeature(feature, viewProj); // todo add hash {featureId => featureIdx, ....}

      const foundFeature = this.getFeatureById(getFeatureId(feature));

      if (foundFeature == null) {
        this.$featuresCollection.push(feature);
      } else {
        this.updateFeature(foundFeature, feature);
      }
    },

    /**
     * @param {FeatureLike[]|module:ol/Collection~Collection<FeatureLike>} features
     */
    removeFeatures(features) {
      forEach(features, this.removeFeature.bind(this));
    },

    /**
     * @param {FeatureLike} feature
     */
    removeFeature(feature) {
      var _feature;

      feature = this.getFeatureById(getFeatureId(((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature));
      if (!feature) return;
      this.$featuresCollection.remove(feature);
    },

    /**
     * @return {void}
     */
    clearFeatures() {
      this.$featuresCollection.clear();
    },

    /**
     * @param {string|number} featureId
     * @return {module:ol/Feature~Feature|undefined}
     */
    getFeatureById(featureId) {
      // todo add hash {featureId => featureIdx, ....}
      return find(this.getFeatures(), feature => getFeatureId(feature) === featureId);
    },

    /**
     * @return {Array<module:ol/Feature~Feature>}
     */
    getFeatures() {
      return this.$featuresCollection.getArray().slice();
    },

    /**
     * @return {module:ol/Collection~Collection<module:ol/Feature~Feature>}
     */
    getFeaturesCollection() {
      return this._featuresCollection;
    },

    /**
     * @param {function} callback
     * @return {*}
     */
    forEachFeature(callback) {
      let res;
      this.$featuresCollection.forEach(function () {
        res = callback(...arguments);
      });
      return res;
    },

    /**
     * @param {number[]} extent
     * @param {function} callback
     * @param {boolean} [viewProj=false]
     * @returns {*}
     */
    forEachFeatureInExtent(extent, callback) {
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);
      return this.forEachFeature(feature => {
        const geometry = feature.getGeometry();

        if (geometry && geometry.intersectsExtent(extent)) {
          const result = callback(feature);

          if (result) {
            return result;
          }
        }
      });
    },

    /**
     * @param {number[]} extent
     * @param {function} callback
     * @param {boolean} [viewProj=false]
     * @returns {*}
     */
    forEachFeatureIntersectingExtent(extent, callback) {
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return this.forEachFeatureInExtent(extent, callback, viewProj);
    },

    /**
     * @param {number[]} coordinate
     * @param {boolean} [viewProj=false]
     * @returns {Array<module:ol/Feature~Feature>}
     */
    getFeaturesAtCoordinate(coordinate) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return this.getFeaturesInExtent([coordinate[0], coordinate[1], coordinate[0], coordinate[1]], viewProj);
    },

    /**
     * @param {number[]} extent
     * @param {boolean} [viewProj=false]
     * @returns {Array<module:ol/Feature~Feature>}
     */
    getFeaturesInExtent(extent) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const features = [];
      this.forEachFeatureIntersectingExtent(extent, feature => {
        features.push(feature);
      }, viewProj);
      return features;
    },

    /**
     * @param {number[]} coordinate
     * @param {function} [filter]
     * @param {boolean} [viewProj=false]
     * @returns {module:ol/Feature~Feature}
     */
    getClosestFeatureToCoordinate(coordinate) {
      let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      coordinate = viewProj ? roundPointCoords(coordinate) : this.pointToViewProj(coordinate);
      let closestFeature;
      let minSquaredDistance = Infinity;
      this.forEachFeature(feature => {
        if (!filter(feature)) return;
        const geometry = feature.getGeometry();
        if (!geometry) return;
        const closestPoint = geometry.getClosestPoint(coordinate);
        const prevSquaredDistance = minSquaredDistance;
        minSquaredDistance = Math.pow(closestPoint[0] - coordinate[0], 2) + Math.pow(closestPoint[1] - coordinate[1]);

        if (minSquaredDistance < prevSquaredDistance) {
          closestFeature = feature;
        }
      });
      return closestFeature;
    },

    /**
     * @param {boolean} [viewProj=false]
     * @returns {number[]}
     */
    getFeaturesExtent() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let extent;
      this.forEachFeature(feature => {
        const geometry = feature.getGeometry();
        if (!geometry) return;
        const geomExtent = geometry.getExtent();

        if (!extent) {
          extent = geomExtent;
        } else {
          extent = [geomExtent[0] < extent[0] ? geomExtent[0] : extent[0], geomExtent[1] < extent[1] ? geomExtent[1] : extent[1], geomExtent[2] > extent[2] ? geomExtent[2] : extent[2], geomExtent[3] > extent[3] ? geomExtent[3] : extent[3]];
        }
      });
      return viewProj ? extent : this.extentToDataProj(extent);
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prevValue
     * @protected
     */
    featuresCollectionIdentChanged(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.$featuresCollection) {
        this.setInstance(value, this.$featuresCollection);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    }

  }
};

function defineServices$d() {
  Object.defineProperties(this, {
    $featuresCollection: {
      enumerable: true,
      get: this.getFeaturesCollection
    }
  });
}

function subscribeToCollectionEvents$3() {
  const adds = fromOlEvent(this.$featuresCollection, CollectionEventType.ADD).pipe(map(evt => ({ ...evt,
    element: this.initializeFeature(evt.element)
  })), tap(_ref => {
    let {
      element
    } = _ref;
    const uid = getUid(element);
    const propChanges = fromOlEvent(element, ObjectEventType.PROPERTYCHANGE);
    const changes = fromOlEvent(element, EventType.CHANGE);
    const events = merge(propChanges, changes).pipe(distinctUntilChanged(isEqual));
    this._featureSubs[uid] = this.subscribeTo(events, this.debounceChanged.bind(this));
  }));
  const removes = fromOlEvent(this.$featuresCollection, CollectionEventType.REMOVE).pipe(tap(_ref2 => {
    let {
      element
    } = _ref2;
    const uid = getUid(element);

    if (this._featureSubs[uid]) {
      this.unsubscribe(this._featureSubs[uid]);
      delete this._featureSubs[uid];
    }
  }));
  const events = merge(adds, removes).pipe(map(_ref3 => {
    let {
      type,
      element
    } = _ref3;
    const viewProj = this.resolvedViewProjection;
    const dataProj = this.resolvedDataProjection;
    return {
      type,
      feature: element,

      get json() {
        if (!this._json) {
          this._json = writeGeoJsonFeature(this.feature, viewProj, dataProj, COORD_PRECISION);
        }

        return this._json;
      }

    };
  }), bufferDebounceTime(FRAME_TIME));
  this.subscribeTo(events, async events => {
    await this.debounceChanged();
    forEach(events, evt => {
      this.$emit(evt.type + 'feature', evt); // todo remove in v0.13.x

      this.$emit(evt.type + ':feature', evt.feature);
    });
  });
}

/**
 * @typedef {module:ol/style/Fill~Fill|Object|undefined} FillStyleLike
 */

/**
 * @typedef {Object} FillStyleTarget
 * @property {function(): module:ol/style/Fill~Fill|undefined} getFill
 * @property {function(module:ol/style/Fill~Fill|undefined): void} setFill
 */

/**
 * Fill style container.
 */

var fillStyleContainer = {
  created() {
    this._fill = undefined;
    this._fillVm = undefined;
    defineServices$c.call(this);
  },

  methods: {
    /**
     * @returns {{readonly fillStyleContainer: Object}}
     */
    getServices() {
      const vm = this;
      return {
        get fillStyleContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {FillStyleTarget}
     */
    getFillStyleTarget() {
      throw new Error(`${this.vmName} not implemented method: getFillStyleTarget()`);
    },

    /**
     * @returns {module:ol/style/Fill~Fill|undefined}
     */
    getFill() {
      var _this$getFillStyleTar;

      return coalesce((_this$getFillStyleTar = this.getFillStyleTarget()) === null || _this$getFillStyleTar === void 0 ? void 0 : _this$getFillStyleTar.getFill(), this._fill);
    },

    /**
     * @return {Object}
     */
    getFillVm() {
      return this._fillVm;
    },

    /**
     * @param {module:ol/style/Fill~Fill|undefined} fill
     */
    setFill(fill) {
      var _fill;

      fill = ((_fill = fill) === null || _fill === void 0 ? void 0 : _fill.$style) || fill;
      fill || (fill = undefined);
      assert(!fill || fill instanceof Fill, 'Invalid fill style');

      if (fill !== this._fill) {
        var _fill2;

        this._fill = fill;
        this._fillVm = ((_fill2 = fill) === null || _fill2 === void 0 ? void 0 : _fill2.vm) && fill.vm[0];
        this.scheduleRefresh();
      }

      const fillTarget = this.getFillStyleTarget();

      if (fillTarget && fill !== fillTarget.getFill()) {
        fillTarget.setFill(fill);
        this.scheduleRefresh();
      }
    }

  }
};

function defineServices$c() {
  Object.defineProperties(this, {
    $fill: {
      enumerable: true,
      get: this.getFill
    },
    $fillVm: {
      enumerable: true,
      get: this.getFillVm
    }
  });
}

/**
 * Base geometry mixin.
 */

var geometry = {
  mixins: [stubVNode, projTransforms, olCmp, waitForMap],
  stubVNode: {
    empty() {
      return this.vmId;
    }

  },

  data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      extentViewProj: undefined
    };
  },

  computed: {
    type() {
      if (!(this.rev && this.$geometry)) return;
      return this.getType();
    },

    extentDataProj() {
      return this.extentToDataProj(this.extentViewProj);
    }

  },
  watch: {
    rev() {
      if (!this.$geometry) return;

      if (!isEqual(this.extentViewProj, this.$geometry.getExtent())) {
        this.extentViewProj = this.$geometry.getExtent().slice();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['extentDataProj'], ['extentDataProj'])
  },

  created() {
    defineServices$b.call(this);
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {Promise<module:ol/geom/Geometry~Geometry>}
     * @protected
     */
    async createOlObject() {
      return initializeGeometry(await this.createGeometry(), this.currentId);
    },

    /**
     * @return {module:ol/geom/Geometry~Geometry|Promise<module:ol/geom/Geometry~Geometry>}
     * @protected
     * @abstract
     */
    createGeometry() {
      throw new Error(`${this.vmName} not implemented method: createGeometry()`);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$geometryContai;

      (_this$$geometryContai = this.$geometryContainer) === null || _this$$geometryContai === void 0 ? void 0 : _this$$geometryContai.setGeometry(this);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$geometryContai2;

      if (((_this$$geometryContai2 = this.$geometryContainer) === null || _this$$geometryContai2 === void 0 ? void 0 : _this$$geometryContai2.getGeometryVm()) === this) {
        this.$geometryContainer.setGeometry(null);
      }

      return olCmp.methods.unmount.call(this);
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(olCmp.methods.getServices.call(this), {
        get geometryVm() {
          return vm;
        }

      });
    },

    /**
     * @returns {void}
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToGeometryEvents.call(this);
    },

    /**
     * @returns {string|number}
     */
    getIdInternal() {
      return getGeometryId(this.$geometry);
    },

    /**
     * @param {string|number} id
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setGeometryId(this.$geometry, id);
    },

    /**
     * @return {Promise<module:ol/geom/Geometry~Geometry>}
     */
    resolveGeometry: olCmp.methods.resolveOlObject,

    /**
     * @returns {string}
     */
    getType() {
      var _this$$geometry;

      return coalesce((_this$$geometry = this.$geometry) === null || _this$$geometry === void 0 ? void 0 : _this$$geometry.getType(), this.type);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @returns {number[]}
     */
    getExtent() {
      var _this$$geometry2;

      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const extent = coalesce((_this$$geometry2 = this.$geometry) === null || _this$$geometry2 === void 0 ? void 0 : _this$$geometry2.getExtent(), this.extentViewProj);
      return viewProj ? roundExtent(extent) : this.extentToDataProj(extent);
    },

    /**
     * @param {number[]} point
     * @param {boolean} [viewProj=false]
     * @returns {Promise<number[]>}
     */
    async getClosestPoint(point) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      point = viewProj ? roundPointCoords(point) : this.pointToViewProj(point);
      const closestPoint = (await this.resolveGeometry()).getClosestPoint(point);
      return viewProj ? roundPointCoords(closestPoint) : this.pointToDataProj(closestPoint);
    },

    /**
     * @param {number[]} coordinate
     * @param {boolean} [viewProj=false]
     * @returns {Promise<boolean>}
     */
    async intersectsCoordinate(coordinate) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      coordinate = viewProj ? roundPointCoords(coordinate) : this.pointToViewProj(coordinate);
      return (await this.resolveGeometry()).intersectsCoordinate(coordinate);
    },

    /**
     * @param {number[]} extent
     * @param {boolean} [viewProj=false]
     * @returns {Promise<boolean>}
     */
    async intersectsExtent(extent) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);
      return (await this.resolveGeometry()).intersectsExtent(extent);
    },

    /**
     * @param {number} angle Angle in radians
     * @param {number[]} anchor
     * @param {boolean} [viewProj=false]
     * @returns {Promise<void>}
     */
    async rotate(angle, anchor) {
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      anchor = viewProj ? roundPointCoords(anchor) : this.pointToViewProj(anchor);
      (await this.resolveGeometry()).rotate(angle, anchor);
    },

    /**
     * @param {number} sx
     * @param {number} [sy]
     * @param {number[]} [anchor]
     * @param {boolean} [viewProj=false]
     * @returns {Promise<void>}
     */
    async scale(sx, sy, anchor) {
      let viewProj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      anchor = viewProj ? roundPointCoords(anchor) : this.pointToViewProj(anchor);
      [sx] = viewProj ? roundPointCoords([sx, 0]) : this.pointToViewProj([sx, 0]);
      [, sy] = viewProj ? roundPointCoords([0, sy]) : this.pointToViewProj([0, sy]);
      (await this.resolveGeometry()).scale(sx, sy, anchor);
    },

    /**
     * @param {number} tolerance
     * @returns {Promise<module:ol/geom/Geometry~Geometry>}
     */
    async simplify(tolerance) {
      return (await this.resolveGeometry()).simplify(tolerance);
    },

    /**
     * @param dx
     * @param dy
     * @param {boolean} [viewProj=false]
     * @returns {Promise<*>}
     */
    async translate(dx, dy) {
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      [dx] = viewProj ? roundPointCoords([dx, 0]) : this.pointToViewProj([dx, 0]);
      [, dy] = viewProj ? roundPointCoords([0, dy]) : this.pointToViewProj([0, dy]);
      return (await this.resolveGeometry()).translate(dx, dy);
    },

    /**
     * @param {number[]} value
     * @param {number[]} prev
     * @protected
     */
    extentDataProjChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:extent', value === null || value === void 0 ? void 0 : value.slice());
    }

  }
};

function defineServices$b() {
  Object.defineProperties(this, {
    /**
     * @type {module:ol/geom/Geometry~Geometry|undefined}
     */
    $geometry: {
      enumerable: true,
      get: () => this.$olObject
    },

    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.mapVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.viewVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $geometryContainer: {
      enumerable: true,
      get: () => {
        var _this$$services3;

        return (_this$$services3 = this.$services) === null || _this$$services3 === void 0 ? void 0 : _this$$services3.geometryContainer;
      }
    }
  });
}

async function subscribeToGeometryEvents() {}

/**
 * @typedef {Source|Object} SourceLike
 */

/**
 * @typedef {Object} SourceTarget
 * @property {function(): Source|undefined} getSource
 * @property {function(Source|undefined): void} setSource
 */

/**
 * Source container mixin.
 */

var sourceContainer = {
  created() {
    /**
     * @type {module:ol/source/Source~Source|undefined}
     * @private
     */
    this._source = undefined;
    /**
     * @type {Object|undefined}
     * @private
     */

    this._sourceVm = undefined;
    defineServices$a.call(this);
  },

  methods: {
    /**
     * @returns {{readonly sourceContainer: Object}}
     * @protected
     */
    getServices() {
      const vm = this;
      return {
        get sourceContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {SourceTarget|undefined}
     * @protected
     */
    getSourceTarget() {
      throw new Error(`${this.vmName} not implemented method: getSourceTarget()`);
    },

    /**
     * @return {module:ol/source/Source~Source|undefined}
     */
    getSource() {
      var _this$getSourceTarget;

      return coalesce((_this$getSourceTarget = this.getSourceTarget()) === null || _this$getSourceTarget === void 0 ? void 0 : _this$getSourceTarget.getSource(), this._source);
    },

    /**
     * @return {Object}
     */
    getSourceVm() {
      return this._sourceVm;
    },

    /**
     * @param {SourceLike|undefined} source
     */
    setSource(source) {
      var _source;

      source = ((_source = source) === null || _source === void 0 ? void 0 : _source.$source) || source;
      source || (source = undefined);
      assert(!source || source instanceof Source, 'Invalid source');
      const sourceTarget = this.getSourceTarget();

      if (sourceTarget && source !== sourceTarget.getSource()) {
        sourceTarget.setSource(source);
        this.scheduleRefresh();
      }

      if (source !== this._source) {
        var _source2;

        this._source = source;
        this._sourceVm = ((_source2 = source) === null || _source2 === void 0 ? void 0 : _source2.vm) && source.vm[0];
        this.scheduleRefresh();
      }
    }

  }
};

function defineServices$a() {
  Object.defineProperties(this, {
    $source: {
      enumerable: true,
      get: this.getSource
    },
    $sourceVm: {
      enumerable: true,
      get: this.getSourceVm
    }
  });
}

/**
 * Base simple layer mixin.
 */

var layer = {
  mixins: [sourceContainer, baseLayer],
  props: {
    // ol/layer/Layer

    /**
     * @type {function|undefined}
     */
    render: Function,
    // custom

    /**
     * @type {boolean}
     */
    overlay: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    source() {
      if (!(this.rev && this.$source)) return;
      return {
        id: getSourceId(this.$source),
        type: this.$source.constructor.name
      };
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'render', 'overlay'], ['source'])
  },
  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      if (this.overlay && this.$mapVm) {
        this.setMap(this.$mapVm);
        return;
      }

      return baseLayer.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      if (this.overlay) {
        this.setMap(null);
        return;
      }

      return baseLayer.methods.unmount.call(this);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(baseLayer.methods.getServices.call(this), sourceContainer.methods.getServices.call(this));
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      baseLayer.methods.subscribeAll.call(this);
      subscribeToLayerEvents$2.call(this);
    },

    /**
     * @return {module:ol/layer/Base~BaseLayer}
     * @protected
     */
    getSourceTarget() {
      return this.$layer;
    },

    /**
     * @returns {module:ol/renderer/Layer~LayerRenderer}
     */
    getRenderer() {
      var _this$$layer;

      return (_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getRenderer();
    },

    /**
     * @param {module:ol/Map~Map|Object|undefined} map
     */
    setMap(map) {
      var _map, _this$$layer2;

      map = ((_map = map) === null || _map === void 0 ? void 0 : _map.$map) || map;
      (_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.setMap(map);
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prev
     * @protected
     */
    sourceChanged(value, prev) {
      if (value === prev) return;
      this.$emit('update:source', value);
    }

  }
};

async function subscribeToLayerEvents$2() {
  const setterKey = addPrefix('set');
  const sourceChanges = fromOlChangeEvent(this.$layer, 'source', true).pipe(tap(_ref => {
    let {
      value: source
    } = _ref;

    if (this._sourceSubs) {
      this.unsubscribe(this._sourceSubs);
    }

    if (source) {
      this._sourceSubs = this.subscribeTo(fromOlChangeEvent(source, 'id', true), this.scheduleRefresh.bind(this));
    }
  }), map(evt => ({ ...evt,
    setter: this[setterKey(evt.prop)]
  })));
  this.subscribeTo(sourceChanges, _ref2 => {
    let {
      setter,
      value
    } = _ref2;
    return setter(value);
  });
  const renderEvents = fromOlEvent(this.$layer, [RenderEventType.PRERENDER, RenderEventType.POSTRENDER]);
  this.subscribeTo(renderEvents, evt => this.$emit(evt.type, evt));
}

var imageLayer = {
  mixins: [layer]
};

const validateAttributions = /*#__PURE__*/or(isString, isFunction, value => isArray(value) && value.every(isString));
/**
 * Base source mixin.
 */

var source = {
  mixins: [stubVNode, projTransforms, olCmp, waitForMap],
  stubVNode: {
    empty() {
      return this.vmId;
    }

  },
  props: {
    // ol/source/Source

    /**
     * @type {string|string[]|undefined}
     */
    attributions: {
      type: [String, Array, Function],
      validator: validateAttributions
    },

    /**
     * @type {boolean}
     */
    attributionsCollapsible: {
      type: Boolean,
      default: true
    },

    /**
     * @type {string|undefined}
     */
    projection: {
      type: String,
      validator: value => !!get(value)
    },

    /**
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: true
    },

    /**
     * @type {string|undefined}
     */
    state: {
      type: String,
      default: SourceState.READY,
      validator: value => Object.values(SourceState).includes(value)
    }
  },

  data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentAttributions: adaptAttributions(this.attributions),
      currentState: this.state
    };
  },

  computed: {
    inputAttributions() {
      return adaptAttributions(this.attributions);
    },

    currentResolutions() {
      return this.rev ? this.getResolutions() : [];
    },

    resolvedDataProjection() {
      var _this$$options;

      return coalesce(this.projection, this.dataProjection, // may or may not be present
      (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, // may or may not be present
      this.resolvedViewProjection);
    }

  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (this.currentAttributions !== this.$source.getAttributions()) {
        this.currentAttributions = this.$source.getAttributions();
      }

      if (this.currentState !== this.$source.getState()) {
        this.currentState = this.$source.getState();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['inputAttributions', 'currentAttributions', 'state', 'currentState', 'attributionsCollapsible', 'projection', 'wrapX', 'currentResolutions'], ['inputAttributions', 'currentAttributions', 'currentResolutions'])
  },

  created() {
    defineServices$9.call(this);
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {Promise<module:ol/source/Source~Source>}
     * @protected
     */
    async createOlObject() {
      return initializeSource(await this.createSource(), this.currentId);
    },

    /**
     * @return {module:ol/source/Source~Source|Promise<module:ol/source/Source~Source>}
     * @protected
     * @abstract
     */
    createSource() {
      throw new Error(`${this.vmName} not implemented method: createSource()`);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$sourceContaine;

      (_this$$sourceContaine = this.$sourceContainer) === null || _this$$sourceContaine === void 0 ? void 0 : _this$$sourceContaine.setSource(this);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$sourceContaine2;

      if (((_this$$sourceContaine2 = this.$sourceContainer) === null || _this$$sourceContaine2 === void 0 ? void 0 : _this$$sourceContaine2.getSourceVm()) === this) {
        this.$sourceContainer.setSource(null);
      }

      return olCmp.methods.unmount.call(this);
    },

    /**
     * @returns {Promise<void>}
     */
    async refresh() {
      const source = await this.resolveSource();
      return new Promise(resolve => {
        source.once('change', () => resolve());
        source.refresh();
      });
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(olCmp.methods.getServices.call(this), {
        get sourceVm() {
          return vm;
        }

      });
    },

    /**
     * @protected
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToSourceEvents$3.call(this);
    },

    /**
     * @returns {string|number}
     * @protected
     */
    getIdInternal() {
      return getSourceId(this.$source);
    },

    /**
     * @param {string|number} id
     * @protected
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setSourceId(this.$source, id);
    },

    /**
     * @return {Promise<module:ol/source/Source~Source>}
     */
    resolveSource: olCmp.methods.resolveOlObject,

    /**
     * @returns {string|string[]|undefined}
     */
    getAttributions() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getAttributions(), this.currentAttributions);
    },

    /**
     * @param {string} attributions
     */
    setAttributions(attributions) {
      assert(!attributions || validateAttributions(attributions), 'Invalid attributions');
      attributions = adaptAttributions(attributions);

      if (!isEqual(attributions, this.currentAttributions)) {
        this.currentAttributions = attributions;
      }

      if (this.$source && !isEqual(attributions, this.$source.getAttributions())) {
        this.$source.setAttributions(attributions);
      }
    },

    /**
     * @returns {boolean}
     */
    getAttributionsCollapsible() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getAttributionsCollapsible(), this.attributionsCollapsible);
    },

    /**
     * @returns {module:ol/proj/Projection~Projection}
     */
    getProjection() {
      var _this$$source3;

      return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.getProjection(), get(this.resolvedDataProjection));
    },

    /**
     * @returns {string}
     */
    getState() {
      var _this$$source4;

      return coalesce((_this$$source4 = this.$source) === null || _this$$source4 === void 0 ? void 0 : _this$$source4.getState(), this.currentState);
    },

    /**
     * @returns {boolean}
     */
    getWrapX() {
      var _this$$source5;

      return coalesce((_this$$source5 = this.$source) === null || _this$$source5 === void 0 ? void 0 : _this$$source5.getWrapX(), this.wrapX);
    },

    /**
     * @returns {number[]}
     */
    getResolutions() {
      try {
        var _this$$source6;

        // can be not implemented in source class
        return coalesce((_this$$source6 = this.$source) === null || _this$$source6 === void 0 ? void 0 : _this$$source6.getResolutions(), []);
      } catch (err) {
        return [];
      }
    },

    /**
     * @param {string|string[]|Function|undefined} value
     * @protected
     */
    inputAttributionsChanged(value) {
      this.setAttributions(value);
    },

    /**
     * @param {string|string[]|Function|undefined} value
     * @protected
     */
    currentAttributionsChanged(value) {
      if (isEqual(value, this.inputAttributions)) return;
      this.$emit('update:attributions', value);
    },

    /**
     * @param {string} value
     * @protected
     */
    stateChanged(value) {
      if (value === this.currentState) return;

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('state changed, scheduling recreate... %O ===> %O', this.currentState, value);
      }

      this.currentState = value;
      return this.scheduleRecreate();
    },

    /**
     * @param {string} value
     * @protected
     */
    currentStateChanged(value) {
      if (value === this.state) return;
      this.$emit('update:state', value);
    },

    /**
     * @param {number[]} value
     * @param {number[]} prev
     * @protected
     */
    currentResolutionsChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:resolutions', value === null || value === void 0 ? void 0 : value.slice());
    }

  }
};

function defineServices$9() {
  Object.defineProperties(this, {
    /**
     * @type {module:ol/source/Source~Source|undefined}
     */
    $source: {
      enumerable: true,
      get: () => this.$olObject
    },

    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.mapVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.viewVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $sourceContainer: {
      enumerable: true,
      get: () => {
        var _this$$services3;

        return (_this$$services3 = this.$services) === null || _this$$services3 === void 0 ? void 0 : _this$$services3.sourceContainer;
      }
    }
  });
}

function subscribeToSourceEvents$3() {}

function adaptAttributions(attributions) {
  if (!attributions) return;
  if (isFunction(attributions)) return attributions;
  return () => isArray(attributions) ? attributions : [attributions];
}

const ImageSourceEventType = {
  IMAGELOADSTART: 'imageloadstart',
  IMAGELOADEND: 'imageloadend',
  IMAGELOADERROR: 'imageloaderror'
};
/**
 * Base image source mixin.
 */

var imageSource = {
  mixins: [source],
  props: {
    // ol/source/Image

    /**
     * @type {string}
     */
    projection: { ...source.props.projection,
      default: EPSG_3857
    },

    /**
     * @type {number[]|undefined}
     */
    resolutions: Array
  },
  computed: {
    inputResolutions() {
      var _this$resolutions;

      return (_this$resolutions = this.resolutions) === null || _this$resolutions === void 0 ? void 0 : _this$resolutions.slice();
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['inputResolutions'], ['inputResolutions'])
  },
  methods: {
    /**
     * @protected
     */
    subscribeAll() {
      source.methods.subscribeAll.call(this);
      subscribeToSourceEvents$2.call(this);
    },

    attributionsCollapsibleChanged: noop,
    wrapXChanged: noop
  }
};

async function subscribeToSourceEvents$2() {
  const events = fromOlEvent(this.$source, [ImageSourceEventType.IMAGELOADSTART, ImageSourceEventType.IMAGELOADEND, ImageSourceEventType.IMAGELOADERROR]);
  this.subscribeTo(events, evt => this.$emit(evt.type, evt));
}

/**
 * Basic style mixin.
 */

var style = {
  mixins: [stubVNode, olCmp],
  stubVNode: {
    empty() {
      return this.vmId;
    }

  },

  created() {
    defineServices$8.call(this);
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeInit() {
      return olCmp.methods.beforeInit.call(this);
    },

    /**
     * @return {OlStyle|Promise<OlStyle>}
     * @protected
     */
    async createOlObject() {
      return initializeStyle(await this.createStyle(), this.currentId);
    },

    /**
     * @return {OlStyle|Promise<OlStyle>}
     * @protected
     * @abstract
     */
    createStyle() {
      throw new Error(`${this.vmName} not implemented method: createStyle()`);
    },

    /**
     * @return {Promise<void>}
     */
    async mount() {
      await olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     */
    async unmount() {
      await olCmp.methods.unmount.call(this);
    },

    /**
     * @return {Promise<void>}
     */
    async remount() {
      await olCmp.methods.remount.call(this);
      await this.refresh();

      if (this.$mapVm) {
        await this.$mapVm.render();
      }
    },

    /**
     * @return {Promise<void>}
     */
    async refresh() {
      await olCmp.methods.refresh.call(this);
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(olCmp.methods.getServices.call(this), {
        get styleVm() {
          return vm;
        }

      });
    },

    /**
     * @protected
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
    },

    /**
     * @param {string|number} id
     */
    setId(id) {
      assert(id != null && id !== '', 'Invalid id');

      if (this.currentId !== id) {
        this.currentId = id;
        this.scheduleRefresh();
      }

      this.$olObject && this.setIdInternal(id);
    },

    /**
     * @returns {string|number}
     */
    getIdInternal() {
      return getStyleId(this.$style);
    },

    /**
     * @param {string|number} id
     * @returns {void}
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setStyleId(this.$style, id);
      this.scheduleRefresh();
    },

    /**
     * @return {Promise<OlStyle>}
     */
    resolveStyle: olCmp.methods.resolveOlObject,

    /**
     * @protected
     */
    syncNonObservable() {
      olCmp.methods.syncNonObservable.call(this);
    }

  }
};

function defineServices$8() {
  Object.defineProperties(this, {
    /**
     * @type {OlStyle|undefined}
     */
    $style: {
      enumerable: true,
      get: () => this.$olObject
    },

    /**
     * @type {Object|undefined}
     */
    $styleContainer: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.styleContainer;
      }
    }
  });
}

var imageStyle = {
  mixins: [style],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    // ol/style/Image

    /**
     * @type {number}
     */
    opacity: {
      type: Number,
      default: 1
    },

    /**
     * @type {boolean}
     */
    rotateWithView: Boolean,

    /**
     * @type {number}
     */
    rotation: {
      type: Number,
      default: 0
    },

    /**
     * @type {number}
     */
    scale: {
      type: Number,
      default: 1
    },
    displacement: {
      type: Array,
      default: () => [0, 0]
    }
  },

  data() {
    return {
      currentOpacity: this.opacity,
      currentRotateWithView: this.rotateWithView,
      currentRotation: this.rotation,
      currentScale: this.scale
    };
  },

  computed: {
    inputDisplacement() {
      var _this$displacement;

      return (_this$displacement = this.displacement) === null || _this$displacement === void 0 ? void 0 : _this$displacement.slice();
    }

  },
  watch: {
    rev() {
      if (!this.$style) return;
      this.setOpacity(this.getOpacity());
      this.setRotateWithView(this.getRotateWithView());
      this.setRotation(this.getRotation());
      this.setScale(this.getScale());
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['opacity', 'currentOpacity', 'rotateWithView', 'currentRotateWithView', 'rotation', 'currentRotation', 'scale', 'currentScale', 'inputDisplacement'], ['inputDisplacement'])
  },

  created() {
    defineServices$7.call(this);
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$imageStyleCont;

      (_this$$imageStyleCont = this.$imageStyleContainer) === null || _this$$imageStyleCont === void 0 ? void 0 : _this$$imageStyleCont.setImage(this);
      return style.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$imageStyleCont2;

      if (((_this$$imageStyleCont2 = this.$imageStyleContainer) === null || _this$$imageStyleCont2 === void 0 ? void 0 : _this$$imageStyleCont2.getImageVm()) === this) {
        await this.$imageStyleContainer.setImage(null);
      }

      return style.methods.unmount.call(this);
    },

    /**
     * @return {Promise<void>}
     */
    async refresh() {
      var _this$$imageStyleCont3;

      await Promise.all([style.methods.refresh.call(this), (_this$$imageStyleCont3 = this.$imageStyleContainer) === null || _this$$imageStyleCont3 === void 0 ? void 0 : _this$$imageStyleCont3.refresh()]);
    },

    /**
     * @protected
     */
    syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setOpacity(this.getOpacity());
      this.setRotateWithView(this.getRotateWithView());
      this.setRotation(this.getRotation());
      this.setScale(this.getScale());
    },

    /**
     * @returns {number}
     */
    getOpacity() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getOpacity(), this.currentOpacity);
    },

    /**
     * @param {number} opacity
     */
    setOpacity(opacity) {
      if (opacity !== this.currentOpacity) {
        this.currentOpacity = opacity;
        this.scheduleRefresh();
      }

      if (this.$style && opacity !== this.$style.getOpacity()) {
        this.$style.setOpacity(opacity);
        this.scheduleRefresh();
      }
    },

    /**
     * @returns {boolean}
     */
    getRotateWithView() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getRotateWithView(), this.currentRotateWithView);
    },

    /**
     * @param {boolean} rotateWithView
     */
    setRotateWithView(rotateWithView) {
      if (rotateWithView !== this.currentRotateWithView) {
        this.currentRotateWithView = rotateWithView;
        this.scheduleRefresh();
      }

      if (this.$style && rotateWithView !== this.$style.getRotateWithView()) {
        this.$style.setRotateWithView(rotateWithView);
        this.scheduleRefresh();
      }
    },

    /**
     * @returns {number}
     */
    getRotation() {
      var _this$$style3;

      return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getRotation(), this.currentRotation);
    },

    /**
     * @param {number} rotation
     */
    setRotation(rotation) {
      if (rotation !== this.currentRotation) {
        this.currentRotation = rotation;
        this.scheduleRefresh();
      }

      if (this.$style && rotation !== this.$style.getRotation()) {
        this.$style.setRotation(rotation);
        this.scheduleRefresh();
      }
    },

    /**
     * @returns {number}
     */
    getScale() {
      var _this$$style4;

      return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getScale(), this.currentScale);
    },

    /**
     * @param {number} scale
     */
    setScale(scale) {
      if (scale !== this.currentScale) {
        this.currentScale = scale;
        this.scheduleRefresh();
      }

      if (this.$style && scale !== this.$style.getScale()) {
        this.$style.setScale(scale);
        this.scheduleRefresh();
      }
    },

    /**
     * @return {number[]}
     */
    getDisplacement() {
      var _this$$style5;

      return coalesce((_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getDisplacement(), this.inputDisplacement);
    },

    /**
     * @param {number} value
     * @protected
     */
    opacityChanged(value) {
      this.setOpacity(value);
    },

    /**
     * @param {number} value
     * @protected
     */
    currentOpacityChanged(value) {
      if (value === this.opacity) return;
      this.$emit('update:opacity', value);
    },

    /**
     * @param {boolean} value
     * @protected
     */
    rotateWithViewChanged(value) {
      this.setRotateWithView(value);
    },

    /**
     * @param {boolean} value
     * @protected
     */
    currentRotateWithViewChanged(value) {
      if (value === this.rotateWithView) return;
      this.$emit('update:rotateWithView', value);
    },

    /**
     * @param {number} value
     * @protected
     */
    rotationChanged(value) {
      this.setRotation(value);
    },

    /**
     * @param {number} value
     * @protected
     */
    currentRotationChanged(value) {
      if (value === this.rotation) return;
      this.$emit('update:rotation', value);
    },

    /**
     * @param {number} value
     * @protected
     */
    scaleChanged(value) {
      this.setScale(value);
    },

    /**
     * @param {number} value
     * @protected
     */
    currentScaleChanged(value) {
      if (value === this.scale) return;
      this.$emit('update:scale', value);
    }

  }
};

function defineServices$7() {
  Object.defineProperties(this, {
    /**
     * @type {Object|undefined}
     */
    $imageStyleContainer: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.imageStyleContainer;
      }
    }
  });
}

/**
 * @typedef {module:ol/style/Image~ImageStyle|Object|undefined} ImageStyleLike
 */

/**
 * @typedef {Object} ImageStyleTarget
 * @property {function(): module:ol/style/Image~ImageStyle|undefined} getImage
 * @property {function(module:ol/style/Image~ImageStyle|undefined): void} setImage
 */

/**
 * Image style container.
 */

var imageStyleContainer = {
  created() {
    this._image = undefined;
    this._imageVm = undefined;
    defineServices$6.call(this);
  },

  methods: {
    /**
     * @returns {{readonly imageStyleContainer: Object}}
     */
    getServices() {
      const vm = this;
      return {
        get imageStyleContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {ImageStyleTarget|undefined}
     */
    getImageStyleTarget() {
      throw new Error(`${this.vmName} not implemented method: getImageStyleTarget()`);
    },

    /**
     * @returns {module:ol/style/Image~ImageStyle|undefined}
     */
    getImage() {
      var _this$getImageStyleTa;

      return coalesce((_this$getImageStyleTa = this.getImageStyleTarget()) === null || _this$getImageStyleTa === void 0 ? void 0 : _this$getImageStyleTa.getImage(), this._image);
    },

    /**
     * @return {Object}
     */
    getImageVm() {
      return this._imageVm;
    },

    /**
     * @param {module:ol/style/Image~ImageStyle|undefined} image
     */
    setImage(image) {
      var _image;

      image = ((_image = image) === null || _image === void 0 ? void 0 : _image.$style) || image;
      image || (image = undefined);
      assert(!image || image instanceof Image, 'Invalid image style');
      const imageTarget = this.getImageStyleTarget();

      if (imageTarget && image !== imageTarget.getImage()) {
        imageTarget.setImage(image);
        this.scheduleRefresh();
      }

      if (image !== this._image) {
        var _image2;

        this._image = image;
        this._imageVm = ((_image2 = image) === null || _image2 === void 0 ? void 0 : _image2.vm) && image.vm[0];
        this.scheduleRefresh();
      }
    }

  }
};

function defineServices$6() {
  Object.defineProperties(this, {
    $image: {
      enumerable: true,
      get: this.getImage
    },
    $imageVm: {
      enumerable: true,
      get: this.getImageVm
    }
  });
}

/**
 * Base interaction mixin.
 */

var interaction = {
  mixins: [stubVNode, projTransforms, olCmp, waitForMap],
  stubVNode: {
    empty() {
      return this.vmId;
    }

  },
  props: {
    /**
     * @type {boolean}
     */
    active: {
      type: Boolean,
      default: true
    },

    /**
     * Priority of interactions in the event handling stream.
     * The higher the value, the sooner it will handle map event.
     * @type {number}
     */
    priority: {
      type: Number,
      default: 0
    }
  },

  data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentActive: this.active,
      currentPriority: this.priority,
      interacting: false
    };
  },

  watch: {
    rev() {
      if (!this.$interaction) return;

      if (this.currentActive !== this.$interaction.getActive()) {
        this.currentActive = this.$interaction.getActive();
      }

      if (this.currentPriority !== getInteractionPriority(this.$interaction)) {
        this.currentPriority = getInteractionPriority(this.$interaction);
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['active', 'currentActive', 'priority', 'currentPriority'])
  },

  created() {
    defineServices$5.call(this);
  },

  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    async beforeInit() {
      await Promise.all([olCmp.methods.beforeInit.call(this), waitForMap.methods.beforeInit.call(this)]);
    },

    /**
     * @return {Promise<module:ol/interaction/Interaction~Interaction>}
     * @protected
     */
    async createOlObject() {
      const interaction = initializeInteraction(await this.createInteraction(), this.currentId, this.currentPriority);
      interaction.setActive(this.currentActive);
      interaction.set('interacting', this.interacting);
      return interaction;
    },

    /**
     * @return {module:ol/interaction/Interaction~Interaction|Promise<module:ol/interaction/Interaction~Interaction>}
     * @protected
     * @abstract
     */
    createInteraction() {
      throw new Error(`${this.vmName} not implemented method: createInteraction()`);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async mount() {
      var _this$$interactionsCo;

      (_this$$interactionsCo = this.$interactionsContainer) === null || _this$$interactionsCo === void 0 ? void 0 : _this$$interactionsCo.addInteraction(this);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    async unmount() {
      var _this$$interactionsCo2;

      (_this$$interactionsCo2 = this.$interactionsContainer) === null || _this$$interactionsCo2 === void 0 ? void 0 : _this$$interactionsCo2.removeInteraction(this);
      return olCmp.methods.unmount.call(this);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(olCmp.methods.getServices.call(this), {
        get interactionVm() {
          return vm;
        }

      });
    },

    /**
     * @returns {void}
     */
    subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToInteractionEvents.call(this);
    },

    /**
     * @return {Promise<module:ol/interaction/Interaction~Interaction>}
     */
    resolveInteraction: olCmp.methods.resolveOlObject,

    /**
     * @returns {string|number}
     */
    getIdInternal() {
      return getInteractionId(this.$interaction);
    },

    /**
     * @param {string|number} id
     * @returns {void}
     */
    setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setInteractionId(this.$interaction, id);
    },

    /**
     * @returns {boolean}
     */
    getActive() {
      var _this$$interaction;

      return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getActive(), this.currentActive);
    },

    /**
     * @param {boolean} active
     */
    setActive(active) {
      active = !!active;

      if (active !== this.currentActive) {
        this.currentActive = active;
      }

      if (this.$interaction && active !== this.$interaction.getActive()) {
        this.$interaction.setActive(active);
      }
    },

    /**
     * @returns {number}
     */
    getPriority() {
      return coalesce(this.$interaction && getInteractionPriority(this.$interaction), this.currentPriority);
    },

    /**
     * @param {number} priority
     */
    setPriority(priority) {
      var _this$$interactionsCo3;

      assert(isNumber(priority), 'Invalid priority');

      if (priority !== this.currentPriority) {
        this.currentPriority = priority;
      }

      if (this.$interaction && priority !== getInteractionPriority(this.$interaction)) {
        setInteractionPriority(this.$interaction, priority);
      } // eslint-disable-next-line no-unused-expressions


      (_this$$interactionsCo3 = this.$interactionsContainer) === null || _this$$interactionsCo3 === void 0 ? void 0 : _this$$interactionsCo3.sortInteractions();
    },

    /**
     * @return {module:ol/Map~Map|undefined}
     */
    getMap() {
      var _this$$interaction2;

      return coalesce((_this$$interaction2 = this.$interaction) === null || _this$$interaction2 === void 0 ? void 0 : _this$$interaction2.getMap(), this.$map);
    },

    // /**
    //  * @param {module:ol/Map~Map} map
    //  */
    // setMap (map) {
    //   this.$interaction?.setMap(map)
    // },
    setInteracting(flag) {
      flag = !!flag;

      if (flag !== this.interacting) {
        this.interacting = flag;
      }

      if (this.$interaction && flag !== this.$interaction.get('interacting')) {
        this.$interaction.set('interacting', flag);
      }
    },

    isInteracting() {
      var _this$$interaction3;

      return coalesce((_this$$interaction3 = this.$interaction) === null || _this$$interaction3 === void 0 ? void 0 : _this$$interaction3.get('interacting'), this.interacting);
    },

    /**
     * @param {boolean} value
     * @protected
     */
    activeChanged(value) {
      this.setActive(value);
    },

    /**
     * @param {boolean} value
     * @protected
     */
    currentActiveChanged(value) {
      if (value === this.active) return;
      this.$emit('update:active', value);
    },

    /**
     * @param {number} value
     * @protected
     */
    priorityChanged(value) {
      this.setPriority(value);
    },

    /**
     * @param {number} value
     * @protected
     */
    currentPriorityChanged(value) {
      if (value === this.priority) return;
      this.$emit('update:priority', value);
    }

  }
};

function defineServices$5() {
  Object.defineProperties(this, {
    /**
     * @type {module:ol/interaction/Interaction~Interaction|undefined}
     */
    $interaction: {
      enumerable: true,
      get: () => this.$olObject
    },

    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: () => {
        var _this$$services;

        return (_this$$services = this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.mapVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: () => {
        var _this$$services2;

        return (_this$$services2 = this.$services) === null || _this$$services2 === void 0 ? void 0 : _this$$services2.viewVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $interactionsContainer: {
      enumerable: true,
      get: () => {
        var _this$$services3;

        return (_this$$services3 = this.$services) === null || _this$$services3 === void 0 ? void 0 : _this$$services3.interactionsContainer;
      }
    }
  });
}

async function subscribeToInteractionEvents() {
  const setterKey = addPrefix('set');
  const propChanges = fromOlChangeEvent(this.$interaction, ['active', 'priority'], true, evt => ({ ...evt,
    setter: this[setterKey(evt.prop)]
  }));
  this.subscribeTo(propChanges, _ref => {
    let {
      setter,
      value
    } = _ref;
    return setter(value);
  });
}

/**
 * @typedef {module:ol/interaction/Interaction~Interaction|Object} InteractionLike
 */

/**
 * Interactions container
 */

var interactionsContainer = {
  mixins: [identMap, rxSubs],
  computed: {
    /**
     * @returns {string|undefined}
     */
    interactionsCollectionIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'interactions_collection');
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['interactionsCollectionIdent'])
  },

  created() {
    /**
     * @type {module:ol/Collection~Collection<module:ol/interaction/Interaction~Interaction>}
     * @private
     */
    this._interactionsCollection = this.instanceFactoryCall(this.interactionsCollectionIdent, () => new Collection());
    this._interactionSubs = {};
    defineServices$4.call(this);
  },

  methods: {
    /**
     * @returns {{readonly interactionsContainer: Object}}
     * @protected
     */
    getServices() {
      const vm = this;
      return {
        get interactionsContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      subscribeToCollectionEvents$2.call(this);
    },

    /**
     * @param {InteractionLike[]|module:ol/Collection~Collection<InteractionLike>} defaultInteractions
     */
    initDefaultInteractions(defaultInteractions) {
      this.getInteractions().forEach(interaction => {
        if (interaction.get('vl_default')) {
          this.removeInteraction(interaction);
        }
      });
      let interactions;

      if (isArray(defaultInteractions) || defaultInteractions instanceof Collection) {
        interactions = defaultInteractions;
      } else if (defaultInteractions !== false) {
        interactions = defaults$1(isPlainObject(defaultInteractions) ? this.defaultInteractions : undefined);
      }

      if (interactions) {
        interactions.forEach(interaction => interaction.set('vl_default', true));
        this.addInteractions(interactions);
      }
    },

    /**
     * @param {InteractionLike} interaction
     * @return {Interaction}
     */
    initializeInteraction(interaction) {
      var _interaction;

      interaction = ((_interaction = interaction) === null || _interaction === void 0 ? void 0 : _interaction.$interaction) || interaction;
      instanceOf(interaction, Interaction);
      return initializeInteraction(interaction);
    },

    /**
     * @param {InteractionLike[]|module:ol/Collection~Collection<InteractionLike>} interactions
     */
    addInteractions(interactions) {
      forEach(interactions, this.addInteraction.bind(this));
    },

    /**
     * @param {InteractionLike} interaction
     */
    addInteraction(interaction) {
      interaction = this.initializeInteraction(interaction);
      if (this.getInteractionById(getInteractionId(interaction))) return;
      this.$interactionsCollection.push(interaction);
      this.sortInteractions();
    },

    /**
     * @param {InteractionLike[]|module:ol/Collection~Collection<InteractionLike>} interactions
     */
    removeInteractions(interactions) {
      forEach(interactions, this.removeInteraction.bind(this));
    },

    /**
     * @param {InteractionLike} interaction
     */
    removeInteraction(interaction) {
      var _interaction2;

      interaction = this.getInteractionById(getInteractionId(((_interaction2 = interaction) === null || _interaction2 === void 0 ? void 0 : _interaction2.$interaction) || interaction));
      if (!interaction) return;
      this.$interactionsCollection.remove(interaction);
      this.sortInteractions();
    },

    /**
     * @return {void}
     */
    clearInteractions() {
      this.$interactionsCollection.clear();
    },

    /**
     * @return {module:ol/interaction/Interaction~Interaction[]}
     */
    getInteractions() {
      return this.$interactionsCollection.getArray().slice();
    },

    /**
     * @return {module:ol/Collection~Collection<module:ol/interaction/Interaction~Interaction>}
     */
    getInteractionsCollection() {
      return this._interactionsCollection;
    },

    /**
     * @param {string|number} interactionId
     * @return {module:ol/interaction/Interaction~Interaction|undefined}
     */
    getInteractionById(interactionId) {
      return find(this.getInteractions(), interaction => getInteractionId(interaction) === interactionId);
    },

    /**
     * @param {function} [sorter]
     */
    sortInteractions(sorter) {
      sorter || (sorter = this.getDefaultInteractionsSorter());
      this.$interactionsCollection.getArray().sort(sorter);
    },

    /**
     * @return {function(): number}
     * @protected
     */
    getDefaultInteractionsSorter() {
      // sort interactions by priority in asc order
      // the higher the priority, the earlier the interaction handles the event
      return (a, b) => {
        const ap = getInteractionPriority(a) || 0;
        const bp = getInteractionPriority(b) || 0;
        return ap === bp ? 0 : ap - bp;
      };
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prevValue
     * @protected
     */
    interactionsCollectionIdentChanged(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.$interactionsCollection) {
        this.setInstance(value, this.$interactionsCollection);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    }

  }
};

function defineServices$4() {
  Object.defineProperties(this, {
    $interactionsCollection: {
      enumerable: true,
      get: this.getInteractionsCollection
    }
  });
}

function subscribeToCollectionEvents$2() {
  const adds = fromOlEvent(this.$interactionsCollection, CollectionEventType.ADD).pipe(map(evt => ({ ...evt,
    element: this.initializeInteraction(evt.element)
  })), tap(_ref => {
    let {
      element
    } = _ref;
    const uid = getUid(element);
    const propChanges = fromOlChangeEvent(element, 'id', true);
    this._interactionSubs[uid] = this.subscribeTo(propChanges, this.scheduleRefresh.bind(this));
  }));
  const removes = fromOlEvent(this.$interactionsCollection, CollectionEventType.REMOVE).pipe(tap(_ref2 => {
    let {
      element
    } = _ref2;
    const uid = getUid(element);

    if (this._interactionSubs[uid]) {
      this.unsubscribe(this._interactionSubs[uid]);
      delete this._interactionSubs[uid];
    }
  }));
  const events = merge(adds, removes).pipe(bufferDebounceTime(FRAME_TIME));
  this.subscribeTo(events, async events => {
    await this.debounceChanged();
    forEach(events, _ref3 => {
      let {
        type,
        element
      } = _ref3;
      this.$emit(type + 'interaction', element); // todo remove in v0.13.x

      this.$emit(type + ':interaction', element);
    });
  });
}

/**
 * @typedef {module:ol/layer/Base~BaseLayer|Object} LayerLike
 */

/**
 * Layers container mixin.
 */

var layersContainer = {
  mixins: [identMap, rxSubs],
  computed: {
    /**
     * @returns {string|undefined}
     */
    layersCollectionIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'layers_collection');
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['layersCollectionIdent'])
  },

  created() {
    /**
     * @type {module:ol/Collection~Collection<module:ol/layer/Base~BaseLayer>}
     * @private
     */
    this._layersCollection = this.instanceFactoryCall(this.layersCollectionIdent, () => new Collection());
    this._layerSubs = {};
    defineServices$3.call(this);
  },

  methods: {
    /**
     * @returns {{readonly layersContainer: Object}}
     * @protected
     */
    getServices() {
      const vm = this;
      return {
        get layersContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      subscribeToCollectionEvents$1.call(this);
    },

    /**
     * @param {LayerLike} layer
     * @return {BaseLayer}
     */
    initializeLayer(layer) {
      var _layer;

      layer = ((_layer = layer) === null || _layer === void 0 ? void 0 : _layer.$layer) || layer;
      instanceOf(layer, BaseLayer);
      return initializeLayer(layer);
    },

    /**
     * @param {LayerLike[]|module:ol/Collection~Collection<LayerLike>} layers
     */
    addLayers(layers) {
      forEach(layers, this.addLayer.bind(this));
    },

    /**
     * @param {LayerLike} layer
     */
    addLayer(layer) {
      layer = this.initializeLayer(layer);
      if (this.getLayerById(getLayerId(layer))) return;
      this.$layersCollection.push(layer);
    },

    /**
     * @param {LayerLike[]|module:ol/Collection~Collection<LayerLike>} layers
     */
    removeLayers(layers) {
      forEach(layers, this.removeLayer.bind(this));
    },

    /**
     * @param {LayerLike} layer
     */
    removeLayer(layer) {
      var _layer2;

      layer = this.getLayerById(getLayerId(((_layer2 = layer) === null || _layer2 === void 0 ? void 0 : _layer2.$layer) || layer));
      if (!layer) return;
      this.$layersCollection.remove(layer);
    },

    /**
     * @return {void}
     */
    clearLayers() {
      this.$layersCollection.clear();
    },

    /**
     * @return {Array<module:ol/layer/Base~BaseLayer>}
     */
    getLayers() {
      return this.$layersCollection.getArray().slice();
    },

    /**
     * @return {module:ol/Collection~Collection<module:ol/layer/Base~BaseLayer>}
     */
    getLayersCollection() {
      return this._layersCollection;
    },

    /**
     * @param {string|number} layerId
     * @return {module:ol/layer/Base~BaseLayer|undefined}
     */
    getLayerById(layerId) {
      return find(this.getLayers(), layer => getLayerId(layer) === layerId);
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prevValue
     * @protected
     */
    layersCollectionIdentChanged(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.$layersCollection) {
        this.setInstance(value, this.$layersCollection);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    }

  }
};

function defineServices$3() {
  Object.defineProperties(this, {
    $layersCollection: {
      enumerable: true,
      get: this.getLayersCollection
    }
  });
}

function subscribeToCollectionEvents$1() {
  const adds = fromOlEvent(this.$layersCollection, CollectionEventType.ADD).pipe(map(evt => ({ ...evt,
    element: this.initializeLayer(evt.element)
  })), tap(_ref => {
    let {
      element
    } = _ref;
    const uid = getUid(element);
    const propChanges = fromOlChangeEvent(element, 'id', true);
    this._layerSubs[uid] = this.subscribeTo(propChanges, this.scheduleRefresh.bind(this));
  }));
  const removes = fromOlEvent(this.$layersCollection, CollectionEventType.REMOVE).pipe(tap(_ref2 => {
    let {
      element
    } = _ref2;
    const uid = getUid(element);

    if (this._layerSubs[uid]) {
      this.unsubscribe(this._layerSubs[uid]);
      delete this._layerSubs[uid];
    }
  }));
  const events = merge(adds, removes).pipe(bufferDebounceTime(FRAME_TIME));
  this.subscribeTo(events, async events => {
    await this.debounceChanged();
    forEach(events, _ref3 => {
      let {
        type,
        element
      } = _ref3;
      this.$emit(type + 'layer', element); // todo remove in v0.13.x

      this.$emit(type + ':layer', element);
    });
  });
}

/**
 * @typedef {module:ol/Overlay~Overlay|Object} OverlayLike
 */

/**
 * Overlays container mixin.
 */

var overlaysContainer = {
  mixins: [identMap, rxSubs],
  computed: {
    /**
     * @returns {string|undefined}
     */
    overlaysCollectionIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'overlays_collection');
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['overlaysCollectionIdent'])
  },

  created() {
    /**
     * @type {module:ol/Collection~Collection<module:ol/Overlay~Overlay>}
     * @private
     */
    this._overlaysCollection = this.instanceFactoryCall(this.overlaysCollectionIdent, () => new Collection());
    this._overlaySubs = {};
    defineServices$2.call(this);
  },

  methods: {
    /**
     * @returns {readonly overlaysContainer: Object}}
     * @protected
     */
    getServices() {
      const vm = this;
      return {
        get overlaysContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll() {
      subscribeToCollectionEvents.call(this);
    },

    /**
     * @param {OverlayLike} overlay
     * @return {Overlay}
     */
    initializeOverlay(overlay) {
      var _overlay;

      overlay = ((_overlay = overlay) === null || _overlay === void 0 ? void 0 : _overlay.$overlay) || overlay;
      instanceOf(overlay, Overlay);
      return initializeOverlay(overlay);
    },

    /**
     * @param {OverlayLike[]|module:ol/Collection~Collection<OverlayLike>} overlays
     */
    addOverlays(overlays) {
      forEach(overlays, this.addOverlay.bind(this));
    },

    /**
     * @param {OverlayLike} overlay
     */
    addOverlay(overlay) {
      overlay = this.initializeOverlay(overlay);
      if (this.getOverlayById(getOverlayId(overlay))) return;
      this.$overlaysCollection.push(overlay);
    },

    /**
     * @param {OverlayLike[]|module:ol/Collection~Collection<OverlayLike>} overlays
     */
    removeOverlays(overlays) {
      forEach(overlays, this.removeOverlay.bind(this));
    },

    /**
     * @param {OverlayLike} overlay
     */
    removeOverlay(overlay) {
      var _overlay2;

      overlay = this.getOverlayById(getOverlayId(((_overlay2 = overlay) === null || _overlay2 === void 0 ? void 0 : _overlay2.$overlay) || overlay));
      if (!overlay) return;
      this.$overlaysCollection.remove(overlay);
    },

    /**
     * @return {void}
     */
    clearOverlays() {
      this.$overlaysCollection.clear();
    },

    /**
     * @return {Array<module:ol/Overlay~Overlay>}
     */
    getOverlays() {
      return this.$overlaysCollection.getArray().slice();
    },

    /**
     * @return {module:ol/Collection~Collection<module:ol/Overlay~Overlay>}
     */
    getOverlaysCollection() {
      return this._overlaysCollection;
    },

    /**
     * @param {string|number} overlayId
     * @return {module:ol/Overlay~Overlay|undefined}
     */
    getOverlayById(overlayId) {
      return find(this.getOverlays(), overlay => getOverlayId(overlay) === overlayId);
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prevValue
     * @protected
     */
    overlaysCollectionIdentChanged(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.$overlaysCollection) {
        this.setInstance(value, this.$overlaysCollection);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    }

  }
};

function defineServices$2() {
  Object.defineProperties(this, {
    $overlaysCollection: {
      enumerable: true,
      get: this.getOverlaysCollection
    }
  });
}

function subscribeToCollectionEvents() {
  const adds = fromOlEvent(this.$overlaysCollection, CollectionEventType.ADD).pipe(map(evt => ({ ...evt,
    element: this.initializeOverlay(evt.element)
  })), tap(_ref => {
    let {
      element
    } = _ref;
    const uid = getUid(element);
    const propChanges = fromOlChangeEvent(element, 'id', true);
    this._overlaySubs[uid] = this.subscribeTo(propChanges, this.scheduleRefresh.bind(this));
  }));
  const removes = fromOlEvent(this.$overlaysCollection, CollectionEventType.REMOVE).pipe(tap(_ref2 => {
    let {
      element
    } = _ref2;
    const uid = getUid(element);

    if (this._overlaySubs[uid]) {
      this.unsubscribe(this._overlaySubs[uid]);
      delete this._overlaySubs[uid];
    }
  }));
  const events = merge(adds, removes).pipe(bufferDebounceTime(FRAME_TIME));
  this.subscribeTo(events, async events => {
    await this.debounceChanged();
    forEach(events, _ref3 => {
      let {
        type,
        element
      } = _ref3;
      this.$emit(type + 'overlay', element); // todo remove in v0.13.x

      this.$emit(type + ':overlay', element);
    });
  });
}

/**
 * @typedef {module:ol/style/Stroke~Stroke|Object|undefined} StrokeStyleLike
 */

/**
 * @typedef {Object} StrokeStyleTarget
 * @property {function(): module:ol/style/Stroke~Stroke|undefined} getStroke
 * @property {function(module:ol/style/Stroke~Stroke|undefined): void} setStroke
 */

/**
 * Stroke style container.
 */

var strokeStyleContainer = {
  created() {
    this._stroke = undefined;
    this._strokeVm = undefined;
    defineServices$1.call(this);
  },

  methods: {
    /**
     * @returns {{readonly strokeStyleContainer: Object}}
     */
    getServices() {
      const vm = this;
      return {
        get strokeStyleContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {StrokeStyleTarget}
     */
    getStrokeStyleTarget() {
      throw new Error(`${this.vmName} not implemented method: getStrokeStyleTarget()`);
    },

    /**
     * @returns {module:ol/style/Stroke~Stroke|undefined}
     */
    getStroke() {
      var _this$getStrokeStyleT;

      return coalesce((_this$getStrokeStyleT = this.getStrokeStyleTarget()) === null || _this$getStrokeStyleT === void 0 ? void 0 : _this$getStrokeStyleT.getStroke(), this._stroke);
    },

    /**
     * @return {Object}
     */
    getStrokeVm() {
      return this._strokeVm;
    },

    /**
     * @param {module:ol/style/Stroke~Stroke|undefined} stroke
     */
    setStroke(stroke) {
      var _stroke;

      stroke = ((_stroke = stroke) === null || _stroke === void 0 ? void 0 : _stroke.$style) || stroke;
      stroke || (stroke = undefined);
      assert(!stroke || stroke instanceof Stroke, 'Invalid stroke');
      const strokeTarget = this.getStrokeStyleTarget();

      if (strokeTarget && stroke !== strokeTarget.getStroke()) {
        strokeTarget.setStroke(stroke);
        this.scheduleRefresh();
      }

      if (stroke !== this._stroke) {
        var _stroke2;

        this._stroke = stroke;
        this._strokeVm = ((_stroke2 = stroke) === null || _stroke2 === void 0 ? void 0 : _stroke2.vm) && stroke.vm[0];
        this.scheduleRefresh();
      }
    }

  }
};

function defineServices$1() {
  Object.defineProperties(this, {
    $stroke: {
      enumerable: true,
      get: this.getStroke
    },
    $strokeVm: {
      enumerable: true,
      get: this.getStrokeVm
    }
  });
}

var regShapeStyle = {
  mixins: [fillStyleContainer, strokeStyleContainer, imageStyle],
  props: {
    // ol/style/RegularShape
    points: Number,
    radius: Number,
    radius1: Number,
    radius2: Number,
    angle: {
      type: Number,
      default: 0
    }
  },
  computed: {
    stroke() {
      if (!(this.rev && this.$stroke)) return;
      return dumpStrokeStyle(this.$stroke);
    },

    fill() {
      if (!(this.rev && this.$fill)) return;
      return dumpFillStyle(this.$fill);
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['points', 'radius', 'radius1', 'radius2', 'angle', 'stroke', 'fill'], ['stroke', 'fill'])
  },
  methods: {
    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(style.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this));
    },

    /**
     * @protected
     */
    syncNonObservable() {
      imageStyle.methods.syncNonObservable.call(this);
    },

    /**
     * @return {FillStyleTarget}
     * @protected
     */
    getFillStyleTarget() {
      return {
        getFill: () => {
          var _this$$style;

          return (_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getFill();
        },
        setFill: () => {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log('fill changed, scheduling recreate...');
          }

          this.scheduleRecreate();
        }
      };
    },

    /**
     * @return {StrokeStyleTarget}
     * @protected
     */
    getStrokeStyleTarget() {
      return {
        getStroke: () => {
          var _this$$style2;

          return (_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getStroke();
        },
        setStroke: () => {
          if (process.env.VUELAYERS_DEBUG) {
            this.$logger.log('stroke changed, scheduling recreate...');
          }

          this.scheduleRecreate();
        }
      };
    },

    getAnchor() {
      var _this$$style3;

      return (_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getAnchor();
    },

    getAngle() {
      var _this$$style4;

      return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getAngle(), this.angle);
    },

    getImage() {
      var _this$$style5;

      return (_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getImage();
    },

    getOrigin() {
      var _this$$style6;

      return (_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getOrigin();
    },

    getPoints() {
      var _this$$style7;

      return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getPoints(), this.points);
    },

    getRadius() {
      var _this$$style8;

      return coalesce((_this$$style8 = this.$style) === null || _this$$style8 === void 0 ? void 0 : _this$$style8.getRadius(), this.radius);
    },

    getRadius2() {
      var _this$$style9;

      return coalesce((_this$$style9 = this.$style) === null || _this$$style9 === void 0 ? void 0 : _this$$style9.getRadius2(), this.radius2);
    },

    getSize() {
      var _this$$style10;

      return (_this$$style10 = this.$style) === null || _this$$style10 === void 0 ? void 0 : _this$$style10.getSize();
    },

    /**
     * @param {Object|undefined} value
     * @param {Object|undefined} prev
     * @protected
     */
    strokeChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:stroke', value && clonePlainObject(value));
    },

    /**
     * @param {Object|undefined} value
     * @param {Object|undefined} prev
     * @protected
     */
    fillChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:fill', value && clonePlainObject(value));
    }

  }
};

/**
 * Base simple geometry with coordinates mixin.
 */

var simpleGeometry = {
  mixins: [geometry],
  props: {
    // ol/geom/SimpleGeometry

    /**
     * @type {number[]} Coordinates in map data projection
     */
    coordinates: {
      type: Array,
      required: true,
      validator: /*#__PURE__*/negate(isEmpty)
    } // todo add support of coord layout
    // /**
    //  * @type {string}
    //  */
    // layout: {
    //   type: String,
    //   default: GeometryLayout.XY,
    //   validator: value => Object.values(GeometryLayout).includes(value.toUpperCase()),
    // },

  },

  data() {
    return {
      currentCoordinatesViewProj: clonePlainObject(this.coordinates)
    };
  },

  computed: {
    coordinatesDataProj() {
      return roundCoords(this.type, this.coordinates);
    },

    coordinatesViewProj() {
      return this.coordinatesToViewProj(this.coordinates);
    },

    currentCoordinatesDataProj() {
      return this.coordinatesToDataProj(this.currentCoordinatesViewProj);
    },

    pointDataProj() {
      return this.rev ? this.findPointOnSurface() : findPointOnSurface({
        type: this.type,
        coordinates: this.coordinatesDataProj
      });
    },

    pointViewProj() {
      return this.rev ? this.findPointOnSurface(true) : findPointOnSurface({
        type: this.type,
        coordinates: this.coordinatesViewProj
      });
    }

  },
  watch: {
    rev() {
      if (!this.$geometry) return;

      if (!isEqualCoord({
        coordinates: this.currentCoordinatesViewProj,
        extent: boundingExtent(this.currentCoordinatesViewProj)
      }, {
        coordinates: this.$geometry.getCoordinates(),
        extent: this.$geometry.getExtent()
      })) {
        this.currentCoordinatesViewProj = this.$geometry.getCoordinates();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['coordinatesViewProj', 'currentCoordinatesDataProj', 'pointDataProj'], ['coordinatesViewProj', 'currentCoordinatesDataProj', 'pointDataProj'])
  },

  created() {
    this.currentCoordinatesViewProj = clonePlainObject(this.coordinatesViewProj);
    this.extentViewProj = boundingExtent(this.currentCoordinatesViewProj);
  },

  methods: {
    /**
     * @returns {function}
     */
    getCoordinatesTransformFunction() {
      return transforms[this.getType()].transform;
    },

    /**
     * @param {number[]} coordinates
     * @returns {Promise<number[]>}
     */
    coordinatesToDataProj(coordinates) {
      const transform = this.getCoordinatesTransformFunction();
      return transform(coordinates, this.resolvedViewProjection, this.resolvedDataProjection);
    },

    /**
     * @param {number[]} coordinates
     * @returns {Promise<number[]>}
     */
    coordinatesToViewProj(coordinates) {
      const transform = this.getCoordinatesTransformFunction();
      return transform(coordinates, this.resolvedDataProjection, this.resolvedViewProjection);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]}
     */
    getCoordinates() {
      var _this$$geometry;

      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const coordinates = coalesce((_this$$geometry = this.$geometry) === null || _this$$geometry === void 0 ? void 0 : _this$$geometry.getCoordinates(), this.currentCoordinatesViewProj);
      return viewProj ? roundCoords(this.getType(), coordinates) : this.coordinatesToDataProj(coordinates);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates(coordinates) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isArray(coordinates), 'Invalid coordinates');
      coordinates = viewProj ? roundCoords(this.getType(), coordinates) : this.coordinatesToViewProj(coordinates);
      const extent = boundingExtent(coordinates);

      if (!isEqualCoord({
        coordinates,
        extent
      }, {
        coordinates: this.currentCoordinatesViewProj,
        extent: this.extentViewProj
      })) {
        this.currentCoordinatesViewProj = coordinates;
      }

      if (this.$geometry && !isEqualCoord({
        coordinates,
        extent
      }, {
        coordinates: this.$geometry.getCoordinates(),
        extent: this.$geometry.getExtent()
      })) {
        this.$geometry.setCoordinates(coordinates);
      }
    },

    /**
     * @param {boolean} [viewProj=false]
     * @returns {number[]>}
     */
    getFirstCoordinate() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let coordinate;

      if (this.$geometry) {
        coordinate = this.$geometry.getFirstCoordinate();
      } else {
        switch (this.getType()) {
          case GeometryType.POINT:
          case GeometryType.CIRCLE:
            coordinate = this.currentCoordinatesViewProj;
            break;

          case GeometryType.LINE_STRING:
          case GeometryType.MULTI_POINT:
            coordinate = this.currentCoordinatesViewProj[0];
            break;

          case GeometryType.POLYGON:
          case GeometryType.MULTI_LINE_STRING:
            coordinate = this.currentCoordinatesViewProj[0][0];
            break;

          case GeometryType.MULTI_POLYGON:
            coordinate = this.currentCoordinatesViewProj[0][0][0];
            break;
        }
      }

      return viewProj ? roundPointCoords(coordinate) : this.pointToDataProj(coordinate);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @returns {number[]}
     */
    getLastCoordinate() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let coordinate;

      if (this.$geometry) {
        coordinate = this.$geometry.getLastCoordinate();
      } else {
        let arr;

        switch (this.getType()) {
          case GeometryType.POINT:
          case GeometryType.CIRCLE:
            coordinate = this.currentCoordinatesViewProj;
            break;

          case GeometryType.LINE_STRING:
          case GeometryType.MULTI_POINT:
            coordinate = this.currentCoordinatesViewProj[this.currentCoordinatesViewProj.length - 1];
            break;

          case GeometryType.POLYGON:
          case GeometryType.MULTI_LINE_STRING:
            arr = this.currentCoordinatesViewProj[this.currentCoordinatesViewProj.length - 1];
            coordinate = arr[arr.length - 1];
            break;

          case GeometryType.MULTI_POLYGON:
            arr = this.currentCoordinatesViewProj[this.currentCoordinatesViewProj.length - 1];
            arr = arr[arr.length - 1];
            coordinate = arr[arr.length - 1];
            break;
        }
      }

      return viewProj ? roundPointCoords(coordinate) : this.pointToDataProj(coordinate);
    },

    /**
     * @returns {string}
     */
    getLayout() {
      var _this$$geometry2;

      return coalesce((_this$$geometry2 = this.$geometry) === null || _this$$geometry2 === void 0 ? void 0 : _this$$geometry2.getLayout(), GeometryLayout.XY);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]|undefined}
     */
    findPointOnSurface() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return findPointOnSurface({
        type: this.getType(),
        coordinates: this.getCoordinates(viewProj)
      });
    },

    /**
     * @param {number[]} value
     * @protected
     */
    coordinatesViewProjChanged(value) {
      this.setCoordinates(value, true);
    },

    /**
     * @param {number[]} value
     * @protected
     */
    currentCoordinatesDataProjChanged(value) {
      if (isEqual(value, this.coordinatesDataProj)) return;
      this.$emit('update:coordinates', clonePlainObject(value));
    },

    /**
     * @param {number[]} value
     * @param {number[]} prev
     * @protected
     */
    pointDataProjChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:point', value === null || value === void 0 ? void 0 : value.slice());
    }

  }
};

function boundingExtent(coordinates) {
  if (!coordinates) return;

  if (!isArray(coordinates[0])) {
    coordinates = [coordinates];
  }

  return boundingExtent$1(coordinates);
}

/**
 * @typedef {module:ol/style/Text~Text|Object|undefined} TextStyleLike
 */

/**
 * @typedef {Object} TextStyleTarget
 * @property {function(): module:ol/style/Text~Text|undefined} getText
 * @property {function(module:ol/style/Text~Text|undefined): void} setText
 */

/**
 * Text style container.
 */

var textStyleContainer = {
  created() {
    this._text = undefined;
    this._textVm = undefined;
    defineServices.call(this);
  },

  methods: {
    /**
     * @returns {{readonly textStyleContainer: Object}}
     */
    getServices() {
      const vm = this;
      return {
        get textStyleContainer() {
          return vm;
        }

      };
    },

    /**
     * @return {TextStyleTarget|undefined}
     */
    getTextStyleTarget() {
      throw new Error(`${this.vmName} not implemented method: getTextStyleTarget()`);
    },

    /**
     * @returns {module:ol/style/Text~Text|null}
     */
    getText() {
      var _this$getTextStyleTar;

      return coalesce((_this$getTextStyleTar = this.getTextStyleTarget()) === null || _this$getTextStyleTar === void 0 ? void 0 : _this$getTextStyleTar.getText(), this._text);
    },

    /**
     * @return {Object}
     */
    getTextVm() {
      return this._textVm;
    },

    /**
     * @param {module:ol/style/Text~Text|undefined} text
     */
    setText(text) {
      var _text;

      text = ((_text = text) === null || _text === void 0 ? void 0 : _text.$style) || text;
      text || (text = undefined);
      assert(!text || text instanceof Text, 'Invalid text style');
      const textTarget = this.getTextStyleTarget();

      if (textTarget && text !== textTarget.getText()) {
        textTarget.setText(text);
        this.scheduleRefresh();
      }

      if (text !== this._text) {
        var _text2;

        this._text = text;
        this._textVm = ((_text2 = text) === null || _text2 === void 0 ? void 0 : _text2.vm) && text.vm[0];
        this.scheduleRefresh();
      }
    }

  }
};

function defineServices() {
  Object.defineProperties(this, {
    $text: {
      enumerable: true,
      get: this.getText
    },
    $textVm: {
      enumerable: true,
      get: this.getTextVm
    }
  });
}

var tileSource = {
  mixins: [source],
  props: {
    // ol/source/Tile

    /**
     * @type {number|undefined}
     */
    cacheSize: Number,

    /**
     * @type {boolean|undefined}
     */
    opaque: Boolean,

    /**
     * @type {number}
     */
    tilePixelRatio: {
      type: Number,
      default: 1
    },

    /**
     * @type {function|undefined}
     */
    tileGridFactory: Function,

    /**
     * @type {number}
     */
    transition: Number,

    /**
     * @type {string|undefined}
     */
    tileKey: String,

    /**
     * @type {number}
     */
    zDirection: {
      type: Number,
      default: 0
    }
  },

  data() {
    return {
      tileGrid: undefined
    };
  },

  computed: {
    /**
     * @type {string|undefined}
     */
    tileGridIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'tile_grid');
    },

    /**
     * @returns {function|undefined}
     */
    derivedTileGridFactory() {
      return this.tileGridFactory;
    },

    /**
     * @returns {function|undefined}
     */
    inputTileGridFactory() {
      if (!isFunction(this.derivedTileGridFactory)) return;
      return sealFactory(this.derivedTileGridFactory.bind(this));
    },

    /**
     * @returns {string}
     */
    resolvedDataProjection() {
      return coalesce(this.projection, this.resolvedViewProjection);
    }

  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (this.tileGrid !== this.$source.getTileGrid()) {
        this.tileGrid = this.$source.getTileGrid();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['tileGridIdent', 'inputTileGridFactory', 'tileGrid', 'tileKey', 'opaque', 'tilePixelRatio', 'cacheSize', 'transition', 'zDirection'])
  },

  created() {
    if (isFunction(this.inputTileGridFactory)) {
      this.tileGrid = this.instanceFactoryCall(this.tileGridIdent, this.inputTileGridFactory.bind(this));
    }
  },

  methods: {
    /**
     * @protected
     */
    subscribeAll() {
      source.methods.subscribeAll.call(this);
    },

    /**
     * @returns {module:ol/tilegrid/TileGrid~TileGrid|undefined}
     */
    getTileGrid() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getTileGrid(), this.tileGrid);
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prevValue
     * @protected
     */
    tileGridIdentChanged(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.tileGrid) {
        this.setInstance(value, this.tileGrid);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    },

    /**
     * @param {function|undefined} value
     * @return {Promise<void>}
     * @protected
     */
    inputTileGridFactoryChanged(value) {
      while (this.hasInstance(this.tileGridIdent)) {
        this.unsetInstance(this.tileGridIdent);
      }

      if (isFunction(value)) {
        this.tileGrid = this.instanceFactoryCall(this.tileGridIdent, value.bind(this));
      } else {
        this.tileGrid = null;
      }
    }

  }
};

const isNotEmptyString$1 = /*#__PURE__*/and(isString, negate(isEmpty));
const isArrayOfNotEmptyStrings = /*#__PURE__*/and(isArray, value => value.every(isNotEmptyString$1));
var urlTileSource = {
  mixins: [tileSource],
  props: {
    // ol/source/UrlTile

    /**
     * @type {function|undefined}
     */
    tileLoadFunction: Function,

    /**
     * @type {function|undefined}
     * @deprecated
     * @todo remove in v0.13.x
     */
    tileUrlFunc: Function,

    /**
     * @type {function|undefined}
     */
    tileUrlFunction: Function,

    /**
     * @type {string|undefined}
     */
    url: {
      type: String,
      validator: isNotEmptyString$1
    },

    /**
     * @type {string[]|undefined}
     */
    urls: {
      type: Array,
      validator: isArrayOfNotEmptyStrings
    }
  },

  data() {
    return {
      currentTileLoadFunction: undefined,
      currentTileUrlFunction: undefined,
      currentUrls: []
    };
  },

  computed: {
    urlTokens() {
      return [];
    },

    inputUrl() {
      if (!this.url) return;
      return replaceTokens(this.url, pick(this, this.urlTokens));
    },

    parsedUrls() {
      const urls = [];

      if (this.urls && this.urls.length > 0) {
        urls.push(...this.urls);
      } else if (this.url) {
        urls.push(this.url);
      }

      const tokens = pick(this, this.urlTokens);
      return urls.map(url => replaceTokens(url, tokens));
    },

    inputUrls() {
      return this.parsedUrls.reduce((urls, url) => urls.concat(...expandUrl(url)), []);
    },

    inputTileUrlFunction() {
      return coalesce(this.tileUrlFunction, this.tileUrlFunc);
    },

    inputTileLoadFunction() {
      return this.tileLoadFunction;
    }

  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (this.currentTileLoadFunction !== this.$source.getTileLoadFunction()) {
        this.currentTileLoadFunction = this.$source.getTileLoadFunction();
      }

      if (this.currentTileUrlFunction !== this.$source.getTileUrlFunction()) {
        this.currentTileUrlFunction = this.$source.getTileUrlFunction();
      }

      if (!isEqual(this.currentUrls, this.$source.getUrls()) && !this.inputTileUrlFunction) {
        this.currentUrls = this.$source.getUrls();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['inputUrls', 'currentUrls', 'inputTileUrlFunction', 'currentTileUrlFunction', 'inputTileLoadFunction', 'currentTileLoadFunction'], ['inputUrls', 'currentUrls'])
  },

  created() {
    var _this$inputUrls;

    if (process.env.NODE_ENV !== 'production') {
      if (this.tileUrlFunc) {
        this.$logger.warn("'tileUrlFunc' prop is deprecated. Use 'tileUrlFunction' prop instead.");
      }
    }

    this.currentUrls = (_this$inputUrls = this.inputUrls) === null || _this$inputUrls === void 0 ? void 0 : _this$inputUrls.slice();
    this.currentTileUrlFunction = this.inputTileUrlFunction;
    this.currentTileLoadFunction = this.inputTileLoadFunction;
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.tileUrlFunc) {
        this.$logger.warn("'tileUrlFunc' prop is deprecated. Use 'tileUrlFunction' prop instead.");
      }
    }
  },

  methods: {
    /**
     * @returns {void}
     */
    subscribeAll() {
      tileSource.methods.subscribeAll.call(this);
      subscribeToSourceEvents$1.call(this);
    },

    /**
     * @returns {module:ol/Tile.LoadFunction}
     */
    getTileLoadFunction() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getTileLoadFunction(), this.currentTileLoadFunction);
    },

    /**
     * @param {module:ol/Tile.LoadFunction} tileLoadFunction
     */
    setTileLoadFunction(tileLoadFunction) {
      assert(isFunction(tileLoadFunction), 'Invalid tile load function');

      if (tileLoadFunction !== this.currentTileLoadFunction) {
        this.currentTileLoadFunction = tileLoadFunction;
      }

      if (this.$source && tileLoadFunction !== this.$source.getTileLoadFunction()) {
        this.$source.setTileLoadFunction(tileLoadFunction);
      }
    },

    /**
     * @returns {module:ol/Tile.UrlFunction}
     */
    getTileUrlFunction() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getTileUrlFunction(), this.currentTileUrlFunction);
    },

    /**
     * @param {module:ol/Tile.UrlFunction} tileUrlFunction
     * @param {number} [tileKey]
     */
    setTileUrlFunction(tileUrlFunction, tileKey) {
      var _this$inputUrls2;

      assert(isFunction(tileUrlFunction), 'Invalid tile url function');
      tileKey || (tileKey = coalesce((_this$inputUrls2 = this.inputUrls) === null || _this$inputUrls2 === void 0 ? void 0 : _this$inputUrls2.join('\n'), v4()));

      if (tileUrlFunction !== this.currentTileUrlFunction) {
        this.currentTileUrlFunction = tileUrlFunction;
      }

      if (this.$source && tileUrlFunction !== this.$source.getTileUrlFunction()) {
        this.$source.setTileUrlFunction(tileUrlFunction, tileKey);
      }
    },

    /**
     * @returns {string[]|undefined}
     */
    getUrls() {
      var _this$$source3;

      return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.getUrls(), this.currentUrls);
    },

    /**
     * @param {string[]} urls
     */
    setUrls(urls) {
      assert(isArrayOfNotEmptyStrings(urls), 'Invalid urls');
      urls = urls.slice();

      if (!isEqual(urls, this.currentUrls)) {
        this.currentUrls = urls;
      }

      if (this.$source) {
        if (this.inputTileUrlFunction) {
          this.$source.setTileUrlFunction(this.inputTileUrlFunction, urls.join('\n'));
        } else if (!isEqual(urls, this.$source.getUrls())) {
          this.$source.setUrls(urls);
        }
      }
    },

    /**
     * @param {string} url
     */
    setUrl(url) {
      assert(isNotEmptyString$1(url), 'Invalid url');
      this.setUrls(expandUrl(url));
    },

    /**
     * @param {string[]} value
     * @protected
     */
    inputUrlsChanged(value) {
      this.setUrls(value);
    },

    /**
     * @param {string[]} value
     * @protected
     */
    currentUrlsChanged(value) {
      if (isEqual(value, this.urls)) return;
      this.$emit('update:urls', value === null || value === void 0 ? void 0 : value.slice());
    },

    /**
     * @param {function|undefined} value
     * @protected
     */
    inputTileUrlFunctionChanged(value) {
      this.setTileUrlFunction(value);
    },

    /**
     * @param {function|undefined} value
     * @protected
     */
    currentTileUrlFunctionChanged(value) {
      if (value === this.inputTileUrlFunction) return;
      this.$emit('update:tileUrlFunction', value);
    },

    /**
     * @param {function|undefined} value
     * @protected
     */
    inputTileLoadFunctionChanged(value) {
      this.setTileLoadFunction(value);
    },

    /**
     * @param {function|undefined} value
     * @protected
     */
    currentTileLoadFunctionChanged(value) {
      if (value === this.inputTileLoadFunction) return;
      this.$emit('update:tileLoadFunction', value);
    }

  }
};

async function subscribeToSourceEvents$1() {
  const events = fromOlEvent(this.$source, [TileEventType.TILELOADSTART, TileEventType.TILELOADEND, TileEventType.TILELOADERROR]);
  this.subscribeTo(events, evt => this.$emit(evt.type, evt));
}

/**
 * Base tile image source mixin.
 */

var tileImageSource = {
  mixins: [urlTileSource],
  props: {
    // ol/source/TileImage

    /**
     * @type {string|undefined}
     */
    crossOrigin: String,

    /**
     * @type {number|undefined}
     */
    reprojectionErrorThreshold: Number,

    /**
     * @type {string|undefined}
     */
    tileClass: String,

    /**
     * @type {boolean}
     */
    imageSmoothing: {
      type: Boolean,
      default: true
    }
  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'reprojectionErrorThreshold', 'tileClass', 'imageSmoothing'])
  },
  methods: {
    async setRenderReprojectionEdges(render) {
      (await this.resolveSource()).setRenderReprojectionEdges(render);
    }

  }
};

/**
 * Base tile layer mixin.
 */

var tileLayer = {
  mixins: [layer],
  props: {
    // ol/layer/BaseTile

    /**
     * @type {number}
     */
    preload: {
      type: Number,
      default: 0
    },

    /**
     * @type {boolean}
     */
    useInterimTilesOnError: {
      type: Boolean,
      default: true
    }
  },

  data() {
    return {
      currentPreload: this.preload,
      currentUseInterimTilesOnError: this.useInterimTilesOnError
    };
  },

  watch: {
    rev() {
      if (!this.$layer) return;

      if (this.currentPreload !== this.$layer.getPreload()) {
        this.currentPreload = this.$layer.getPreload();
      }

      if (this.currentUseInterimTilesOnError !== this.$layer.getUseInterimTilesOnError()) {
        this.currentUseInterimTilesOnError = this.$layer.getUseInterimTilesOnError();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['preload', 'currentPreload', 'useInterimTilesOnError', 'currentUseInterimTilesOnError'])
  },
  methods: {
    /**
     * @protected
     */
    subscribeAll() {
      layer.methods.subscribeAll.call(this);
      subscribeToLayerEvents$1.call(this);
    },

    /**
     * @returns {number}
     */
    getPreload() {
      var _this$$layer;

      return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getPreload(), this.currentPreload);
    },

    /**
     * @param {number} preload
     */
    setPreload(preload) {
      preload = Number(preload);
      assert(isNumber(preload), 'Invalid preload');

      if (preload !== this.currentPreload) {
        this.currentPreload = preload;
      }

      if (this.$layer && preload !== this.$layer.getPreload()) {
        this.$layer.setPreload(preload);
      }
    },

    /**
     * @returns {boolean}
     */
    getUseInterimTilesOnError() {
      var _this$$layer2;

      return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getUseInterimTilesOnError(), this.currentUseInterimTilesOnError);
    },

    /**
     * @param {boolean} useInterimTilesOnError
     */
    setUseInterimTilesOnError(useInterimTilesOnError) {
      useInterimTilesOnError = !!useInterimTilesOnError;

      if (useInterimTilesOnError !== this.currentUseInterimTilesOnError) {
        this.currentUseInterimTilesOnError = useInterimTilesOnError;
      }

      if (this.$layer && useInterimTilesOnError !== this.$layer.getUseInterimTilesOnError()) {
        this.$layer.setUseInterimTilesOnError(useInterimTilesOnError);
      }
    },

    /**
     * @param {number} value
     * @protected
     */
    preloadChanged(value) {
      this.setPreload(value);
    },

    /**
     * @param {number} value
     * @protected
     */
    currentPreloadChanged(value) {
      if (value === this.preload) return;
      this.$emit('update:preload', value);
    },

    /**
     * @param {boolean} value
     * @protected
     */
    useInterimTilesOnErrorChanged(value) {
      this.setUseInterimTilesOnError(value);
    },

    /**
     * @param {boolean} value
     * @protected
     */
    currentUseInterimTilesOnErrorChanged(value) {
      if (value === this.useInterimTilesOnError) return;
      this.$emit('update:useInterimTilesOnError', value);
    }

  }
};

async function subscribeToLayerEvents$1() {
  const setterKey = addPrefix('current');
  const propChanges = fromOlChangeEvent(this.$layer, ['preload', 'useInterimTilesOnError'], true, evt => ({ ...evt,
    setter: this[setterKey(evt.prop)]
  }));
  this.subscribeTo(propChanges, _ref => {
    let {
      setter,
      value
    } = _ref;
    return setter(value);
  });
}

var vectorLayer = {
  mixins: [styleContainer, layer],
  props: {
    // ol/layer/BaseVector

    /**
     * @type {function|undefined}
     */
    renderOrder: Function,

    /**
     * @type {number}
     */
    renderBuffer: {
      type: Number,
      default: 100
    },

    /**
     * @type {boolean}
     */
    declutter: Boolean,

    /**
     * When set to `true`, feature batches will be recreated during animations.
     * @type {boolean}
     */
    updateWhileAnimating: Boolean,

    /**
     * When set to `true`, feature batches will be recreated during interactions.
     * @type {boolean}
     */
    updateWhileInteracting: Boolean
  },
  computed: {
    style() {
      if (!(this.rev && this.$style)) return;
      let style = this.$style;
      if (isFunction(style)) return style;
      if (!style) return;
      isArray(style) || (style = [style]);
      return style.map(style => dumpStyle(style, geom => this.writeGeometryInDataProj(geom)));
    }

  },
  watch: { ... /*#__PURE__*/makeChangeOrRecreateWatchers(['renderOrder', 'renderBuffer', 'declutter', 'updateWhileAnimating', 'updateWhileInteracting', 'style'], ['style'])
  },
  methods: {
    /**
     * @returns {Object}
     * @protected
     */
    getServices() {
      return mergeDescriptors(layer.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @protected
     */
    subscribeAll() {
      layer.methods.subscribeAll.call(this);
      subscribeToLayerEvents.call(this);
    },

    /**
     * @return {StyleTarget|undefined}
     */
    getStyleTarget() {
      return this.$layer;
    },

    /**
     * @param {number[]} pixel
     * @return {Promise<Array<module:ol/Feature~Feature>>}
     */
    async getFeatures(pixel) {
      return (await this.resolveLayer()).getFeatures(pixel);
    },

    /**
     * @param {Object|Function|Array|undefined} value
     * @param {Object|Function|Array|undefined} prev
     * @protected
     */
    styleChanged(value, prev) {
      if (isEqual(value, prev)) return;

      if (isPlainObject(value) || isArray(value)) {
        value = clonePlainObject(value);
      }

      this.$emit('update:style', value);
    }

  }
};

async function subscribeToLayerEvents() {}

const isNotEmptyString = /*#__PURE__*/and(isString, negate(isEmpty));
/**
 * Basic vector source mixin.
 */

var vectorSource = {
  mixins: [featureHelper, featuresContainer, source],
  stubVNode: {
    empty: false,

    attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }

  },
  props: {
    // ol/source/Vector

    /**
     * @type {Object[]}
     */
    features: {
      type: Array,
      default: stubArray,
      validator: value => every(value, isGeoJSONFeature)
    },

    /**
     * Source format factory
     * @type {function} formatFactory
     */
    formatFactory: {
      type: Function,
      default: getGeoJsonFmt
    },

    /**
     * Feature loader.
     * Feature loader should load features from some remote service, decode them and pass to `features` prop to render.
     * @type {module:ol/featureloader~FeatureLoader|undefined} loader
     */
    loader: Function,

    /**
     * @deprecated Use `loader` prop instead
     * @todo remove in v0.13.x
     */
    loaderFactory: Function,

    /**
     * Loading strategy.
     * Extent here in map view projection.
     * @type {function} loadingStrategy
     */
    loadingStrategy: {
      type: Function // default: loadAll,

    },

    /**
     * @deprecated Use `loadingStrategy` prop instead
     * @todo remove in v0.13.x
     */
    strategyFactory: Function,

    /**
     * String or url factory
     * @type {string|function} url
     */
    url: {
      type: [String, Function],
      validator: value => isFunction(value) || isNotEmptyString(value)
    },

    /**
     * @type {boolean}
     */
    overlaps: {
      type: Boolean,
      default: true
    },

    /**
     * @type {boolean}
     */
    useSpatialIndex: {
      type: Boolean,
      default: true
    }
  },

  data() {
    return {
      /**
       * @returns {module:ol/format/Feature~FeatureFormat|undefined}
       */
      format: undefined,
      currentUrl: undefined,
      currentLoader: undefined
    };
  },

  computed: {
    featuresDataProj() {
      return map$1(this.features, feature => initializeFeature(clonePlainObject(feature)));
    },

    featuresViewProj() {
      return map$1(this.features, feature => initializeFeature(this.writeFeatureInViewProj(this.readFeatureInDataProj(feature))));
    },

    featuresHash() {
      return reduce(this.features, (hash, feature) => {
        hash[getFeatureId(feature)] = true;
        return hash;
      }, {});
    },

    currentFeaturesDataProj() {
      if (!this.rev) return [];
      return map$1(this.getFeatures(), feature => this.writeFeatureInDataProj(feature));
    },

    currentFeaturesViewProj() {
      if (!this.rev) return [];
      return map$1(this.getFeatures(), feature => this.writeFeatureInViewProj(feature));
    },

    currentFeaturesHash() {
      if (!this.rev) return {};
      return reduce(this.getFeatures(), (hash, feature) => {
        hash[getFeatureId(feature)] = true;
        return hash;
      }, {});
    },

    extentDataProj() {
      return this.rev ? this.getExtent() : undefined;
    },

    extentViewProj() {
      return this.rev ? this.getExtent(true) : undefined;
    },

    inputUrl() {
      return this.createUrlFunc(this.url);
    },

    inputLoader() {
      let loader = this.loader;

      if (!loader && this.loaderFactory) {
        loader = this.loaderFactory();
      }

      return this.createLoaderFunc(loader);
    },

    inputLoadingStrategy() {
      let loadingStrategy = this.loadingStrategy;

      if (!loadingStrategy && this.strategyFactory) {
        loadingStrategy = this.strategyFactory();
      }

      return loadingStrategy || all;
    },

    formatIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'format');
    },

    inputFormatFactory() {
      return sealFactory(this.formatFactory.bind(this));
    }

  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (this.currentUrl !== this.$source.getUrl()) {
        this.currentUrl = this.$source.getUrl();
      }
    },

    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['featuresViewProj', 'currentFeaturesDataProj', 'extentDataProj', 'inputUrl', 'currentUrl', 'inputLoader', 'currentLoader', 'inputLoadingStrategy', 'inputFormatFactory', 'formatIdent', 'format', 'overlaps', 'useSpatialIndex'], ['featuresViewProj', 'currentFeaturesDataProj', 'extentDataProj'])
  },

  created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.loaderFactory) {
        this.$logger.warn("'loaderFactory' prop is deprecated. Use 'loader' prop instead.");
      }

      if (this.strategyFactory) {
        this.$logger.warn("'strategyFactory' prop is deprecated. Use 'loadingStrategy' prop instead.");
      }
    }

    if (isFunction(this.inputFormatFactory)) {
      this.format = this.instanceFactoryCall(this.formatIdent, this.inputFormatFactory.bind(this));
    }

    this.currentUrl = this.inputUrl;
    this.currentLoader = this.inputLoader;
  },

  updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.loaderFactory) {
        this.$logger.warn("'loaderFactory' prop is deprecated. Use 'loader' prop instead.");
      }

      if (this.strategyFactory) {
        this.$logger.warn("'strategyFactory' prop is deprecated. Use 'loadingStrategy' prop instead.");
      }
    }
  },

  methods: {
    /**
     * @return {module:ol/source/Vector~VectorSource}
     * @protected
     */
    createSource() {
      return new Vector({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        wrapX: this.wrapX,
        // ol/source/Vector
        format: this.format,
        loader: this.currentLoader,
        strategy: this.inputLoadingStrategy,
        url: this.currentUrl,
        overlaps: this.overlaps,
        useSpatialIndex: this.useSpatialIndex,
        features: this.$featuresCollection
      });
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices() {
      const vm = this;
      return mergeDescriptors(source.methods.getServices.call(this), {
        get featuresContainer() {
          return vm;
        }

      });
    },

    /**
     * @protected
     */
    subscribeAll() {
      source.methods.subscribeAll.call(this);
      featuresContainer.methods.subscribeAll.call(this);
      subscribeToSourceEvents.call(this);
    },

    /**
     * @param {FeatureLike[]|module:ol/Collection~Collection<FeatureLike>} features
     * @param {boolean} [viewProj=false]
     */
    addFeatures(features) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.$source) {
        return featuresContainer.methods.addFeatures.call(this, features, viewProj);
      }

      const newFeatures = [];
      forEach(features || [], feature => {
        feature = this.initializeFeature(feature, viewProj);
        instanceOf(feature, Feature);
        const foundFeature = this.$source.getFeatureById(getFeatureId(feature));

        if (foundFeature) {
          this.updateFeature(foundFeature, feature);
        } else {
          newFeatures.push(feature);
        }
      });
      if (!newFeatures.length) return;
      this.$source.addFeatures(newFeatures);
    },

    /**
     * @param {FeatureLike} feature
     * @param {boolean} [viewProj=false]
     */
    addFeature(feature) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.$source) {
        return featuresContainer.methods.addFeature.call(this, feature, viewProj);
      }

      feature = this.initializeFeature(feature, viewProj);
      const foundFeature = this.$source.getFeatureById(getFeatureId(feature));

      if (foundFeature == null) {
        this.$source.addFeature(feature);
      } else {
        this.updateFeature(foundFeature, feature);
      }
    },

    /**
     * @param {FeatureLike[]|module:ol/Collection~Collection<FeatureLike>} features
     */
    removeFeatures(features) {
      if (!this.$source) {
        return featuresContainer.methods.removeFeatures.call(this, features);
      }

      let changed = false;
      forEach(features, feature => {
        changed = this.removeFeatureInternal(feature);
      });
      if (!changed) return;
      this.$source.changed();
    },

    removeFeatureInternal(feature) {
      feature = this.getFeatureById(getFeatureId(feature));
      if (!feature) return false;
      const featureKey = getUid(feature);

      if (featureKey in this.$source.nullGeometryFeatures_) {
        delete this.$source.nullGeometryFeatures_[featureKey];
      } else {
        if (this.$source.featuresRtree_) {
          this.$source.featuresRtree_.remove(feature);
        }
      }

      this.$source.removeFeatureInternal(feature);
      return true;
    },

    /**
     * @param {FeatureLike} feature
     */
    removeFeature(feature) {
      var _feature;

      if (!this.$source) {
        return featuresContainer.methods.removeFeature.call(this, feature);
      }

      feature = this.$source.getFeatureById(getFeatureId(((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature));
      if (!feature) return;
      this.$source.removeFeature(feature);
    },

    /**
     * @param {string} featureId
     * @return {module:ol/Feature~Feature|undefined}
     */
    getFeatureById(featureId) {
      if (this.$source) {
        return this.$source.getFeatureById(featureId);
      }

      return featuresContainer.methods.getFeatureById.call(this, featureId);
    },

    /**
     * @return {Array<module:ol/Feature~Feature>}
     */
    getFeatures() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getFeatures(), featuresContainer.methods.getFeatures.call(this));
    },

    /**
     * @return {module:ol/Collection~Collection|undefined}
     */
    getFeaturesCollection() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getFeaturesCollection(), this._featuresCollection);
    },

    /**
     * @return {boolean}
     */
    isEmpty() {
      var _this$$source3;

      return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.isEmpty(), this.$featuresCollection.getLength() === 0);
    },

    /**
     * @param {boolean} [fast]
     * @return {Promise<void>}
     */
    async clear(fast) {
      if (!this.$source) return this.clearFeatures();
      const source = await this.resolveSource();
      return new Promise(resolve => {
        source.once('change', () => resolve());
        source.clear();
      });
    },

    /**
     * @param {function} callback
     * @returns {*}
     */
    forEachFeature(callback) {
      if (this.$source) {
        return this.$source.forEachFeature(callback);
      }

      return featuresContainer.methods.forEachFeature.call(this, callback);
    },

    /**
     * @param {number[]} extent
     * @param {function} callback
     * @param {boolean} [viewProj=false]
     * @returns {*}
     */
    forEachFeatureInExtent(extent, callback) {
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);

      if (this.$source) {
        return this.$source.forEachFeatureInExtent(extent, callback);
      }

      return featuresContainer.methods.forEachFeatureInExtent.call(this, extent, callback, true);
    },

    /**
     * @param {number[]} extent
     * @param {function} callback
     * @param {boolean} [viewProj=false]
     * @returns {*}
     */
    forEachFeatureIntersectingExtent(extent, callback) {
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);

      if (this.$source) {
        return this.$source.forEachFeatureIntersectingExtent(extent, callback);
      }

      return featuresContainer.methods.forEachFeatureIntersectingExtent.call(this, extent, callback, true);
    },

    /**
     * @param {number[]} coordinate
     * @param {boolean} [viewProj=false]
     * @returns {Array<module:ol/Feature~Feature>}
     */
    getFeaturesAtCoordinate(coordinate) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      coordinate = viewProj ? roundPointCoords(coordinate) : this.pointToViewProj(coordinate);

      if (this.$source) {
        return this.$source.getFeaturesAtCoordinate(coordinate);
      }

      return featuresContainer.methods.getFeaturesAtCoordinate.call(this, coordinate, true);
    },

    /**
     * @param {number[]} extent
     * @param {boolean} [viewProj=false]
     * @returns {Array<module:ol/Feature~Feature>}
     */
    getFeaturesInExtent(extent) {
      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);

      if (this.$source) {
        return this.$source.getFeaturesInExtent(extent);
      }

      return featuresContainer.methods.getFeaturesInExtent.call(this, extent, true);
    },

    /**
     * @param {number[]} coordinate
     * @param {function} [filter]
     * @param {boolean} [viewProj=false]
     * @returns {module:ol/Feature~Feature}
     */
    getClosestFeatureToCoordinate(coordinate) {
      let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
      let viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      coordinate = viewProj ? roundPointCoords(coordinate) : this.pointToViewProj(coordinate);

      if (this.$source) {
        return this.$source.getClosestFeatureToCoordinate(coordinate, filter);
      }

      return featuresContainer.methods.getClosestFeatureToCoordinate.call(this, coordinate, filter, true);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @returns {number[]}
     */
    getExtent() {
      let viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let extent;

      if (this.$source) {
        extent = this.$source.getExtent();
      } else {
        extent = featuresContainer.methods.getFeaturesExtent.call(this, true);
      }

      return viewProj ? extent : this.extentToDataProj(extent);
    },

    /**
     * @returns {module:ol/format/Feature~FeatureFormat|undefined}
     */
    getFormat() {
      var _this$$source4;

      return coalesce((_this$$source4 = this.$source) === null || _this$$source4 === void 0 ? void 0 : _this$$source4.getFormat(), this.format);
    },

    /**
     * @returns {Promise<string|function|undefined>}
     */
    getUrl() {
      var _this$$source5;

      return coalesce((_this$$source5 = this.$source) === null || _this$$source5 === void 0 ? void 0 : _this$$source5.getUrl(), this.currentUrl);
    },

    /**
     * @param {string|function} url
     */
    setUrl(url) {
      url = this.createUrlFunc(url);

      if (url !== this.currentUrl) {
        this.currentUrl = url;
      }

      if (this.$source && url !== this.$source.getUrl()) {
        this.$source.setUrl(url);
        this.refresh();
      }
    },

    /**
     * @param {function} loader
     */
    setLoader(loader) {
      loader = this.createLoaderFunc(loader);

      if (loader !== this.currentLoader) {
        var _this$$source6;

        this.currentLoader = loader;
        (_this$$source6 = this.$source) === null || _this$$source6 === void 0 ? void 0 : _this$$source6.setLoader(loader);
        this.refresh();
      }
    },

    /**
     * @param {number[]} extent
     * @param {boolean} [viewProj=false]
     */
    removeLoadedExtent(extent) {
      var _this$$source7;

      let viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);
      (_this$$source7 = this.$source) === null || _this$$source7 === void 0 ? void 0 : _this$$source7.removeLoadedExtent(extent);
    },

    /**
     * @param {string|function|undefined} url
     * @return {function|undefined}
     * @protected
     */
    createUrlFunc(url) {
      if (!url) return;

      if (!isFunction(url)) {
        url = constant(url);
      }

      return this.wrapUrlFunc(url);
    },

    /**
     * @param {function} urlFunc
     * @returns {function}
     * @protected
     */
    wrapUrlFunc(urlFunc) {
      let fn = urlFunc;

      if (!fn.wrapped) {
        fn = (extent, resolution, projection) => {
          extent = transformExtent(extent, projection, this.resolvedDataProjection);
          projection = this.resolvedDataProjection;
          return urlFunc(extent, resolution, projection);
        };

        fn.wrapped = true;
      }

      return fn;
    },

    /**
     * @param {function|undefined} loader
     * @return {function|undefined}
     * @protected
     */
    createLoaderFunc(loader) {
      if (!isFunction(loader)) return;
      return this.wrapLoaderFunc(loader);
    },

    /**
     * @param {function} loaderFunc
     * @returns {Function}
     * @protected
     */
    wrapLoaderFunc(loaderFunc) {
      let fn = loaderFunc;

      if (!fn.wrapped) {
        fn = async (extent, resolution, projection) => {
          let features = await loaderFunc(transformExtent(extent, projection, this.resolvedDataProjection), resolution, this.resolvedDataProjection);
          if (!features) return;

          if (!(isArray(features) && features[0] instanceof Feature)) {
            features = this.readSource(features);
          }

          if (isArray(features)) {
            this.addFeatures(features);
          }
        };

        fn.wrapped = true;
      }

      return fn;
    },

    /**
     * @param {*} data
     * @returns {Array<module:ol/Feature~Feature>}
     */
    readSource(data) {
      return this.getFormat().readFeatures(data, {
        featureProjection: this.resolvedViewProjection,
        dataProjection: this.resolvedDataProjection
      });
    },

    /**
     * @param {GeoJSONFeature[]} value
     * @param {GeoJSONFeature[]} prevValue
     * @protected
     */
    async featuresViewProjChanged(value, prevValue) {
      if (isEqual(value, prevValue)) return; // remove non-matched features

      forEach(this.getFeatures(), feature => {
        if (!this.featuresHash[getFeatureId(feature)]) {
          this.removeFeatureInternal(feature);
        }
      }); // add new features

      this.addFeatures(value, true);
      await this.debounceChanged();
    },

    /**
     * @param {GeoJSONFeature[]} value
     * @protected
     */
    currentFeaturesDataProjChanged(value) {
      if (isEqual(value, this.featuresDataProj)) return;
      this.$emit('update:features', clonePlainObject(value));
    },

    /**
     * @param {number[]|undefined} value
     * @param {number[]|undefined} prev
     * @protected
     */
    extentDataProjChanged(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:extent', value === null || value === void 0 ? void 0 : value.slice());
    },

    /**
     * @param {string|function|undefined} value
     * @protected
     */
    inputUrlChanged(value) {
      this.setUrl(value);
    },

    /**
     * @param {string|function|undefined} value
     * @protected
     */
    currentUrlChanged(value) {
      if (value === this.inputUrl) return;
      this.$emit('update:url', value);
    },

    /**
     * @param {function|undefined} value
     * @protected
     */
    inputLoaderChanged(value) {
      this.setLoader(value);
    },

    /**
     * @param {function|undefined} value
     * @protected
     */
    currentLoaderChanged(value) {
      if (value === this.inputLoader) return;
      this.$emit('update:loader', value);
    },

    /**
     * @param {string|undefined} value
     * @param {string|undefined} prevValue
     * @protected
     */
    formatIdentChanged(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.format) {
        this.setInstance(value, this.format);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    },

    /**
     * @param {function} value
     * @protected
     */
    inputFormatFactoryChanged(value) {
      while (this.hasInstance(this.formatIdent)) {
        this.unsetInstance(this.formatIdent);
      }

      if (isFunction(value)) {
        this.format = this.instanceFactoryCall(this.formatIdent, value.bind(this));
      } else {
        this.format = undefined;
      }
    },

    // skip not used watchers
    attributionsCollapsibleChanged: noop,
    stateChanged: noop
  }
};

function subscribeToSourceEvents() {}

function transformExtent(extent, sourceProj, destProj) {
  extent = extent.slice();

  if (isFinite(extent[0]) && isFinite(extent[1])) {
    [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj);
  }

  if (isFinite(extent[2]) && isFinite(extent[3])) {
    [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj);
  }

  return extent;
}

const cleanWmsSourceParams = params => cleanSourceParams(params, ['LAYERS', 'VERSION', 'STYLES', 'FORMAT', 'TRANSPARENT', 'BGCOLOR', 'TIME']);
/**
 * Basic WMS params and methods mixin.
 */


var wmsSource = {
  props: {
    /**
     * @type {boolean}
     */
    hidpi: {
      type: Boolean,
      default: true
    },

    /**
     * @type {string|undefined}
     */
    serverType: {
      type: String,
      validator: value => Object.values(WMSServerType).includes(value)
    },

    /**
     * @type {string|string[]}
     */
    layers: {
      type: String,
      required: true
    },

    /**
     * WMS Request styles
     * @type {string|string[]|undefined}
     */
    styles: String,

    /**
     * @type {string}
     */
    version: {
      type: String,
      default: '1.3.0'
    },

    /**
     * @type {boolean}
     */
    transparent: {
      type: Boolean,
      default: true
    },

    /**
     * @type {string}
     */
    format: {
      type: String,
      default: 'image/png'
    },

    /**
     * @type {string|undefined}
     */
    bgColor: String,

    /**
     * @type {string|undefined}
     */
    time: String,

    /**
     * Additional WMS request parameters
     * @type {Object|undefined}
     */
    params: Object
  },

  data() {
    return {
      currentParams: undefined
    };
  },

  computed: {
    /**
     * @returns {string}
     */
    inputLayers() {
      return isArray(this.layers) ? this.layers.join(',') : this.layers;
    },

    /**
     * @returns {string|undefined}
     */
    inputStyles() {
      return isArray(this.styles) ? this.styles.join(',') : this.styles;
    },

    /**
     * @returns {Object|null}
     */
    customParams() {
      return this.params ? cleanWmsSourceParams(this.params) : undefined;
    },

    /**
     * @returns {Object}
     */
    inputParams() {
      return { ...(this.customParams || {}),
        LAYERS: this.inputLayers,
        STYLES: this.inputStyles,
        VERSION: this.version,
        FORMAT: this.format,
        TRANSPARENT: this.transparent,
        BGCOLOR: this.bgColor,
        TIME: this.time
      };
    },

    ... /*#__PURE__*/reduce(['inputLayers', 'inputStyles', 'version', 'format', 'transparent', 'bgColor', 'time'], (props, inProp) => {
      const prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      const curProp = 'current' + upperFirst(prop);

      props[curProp] = function () {
        return coalesce((this.currentParams || {})[prop.toUpperCase()], (this.inputParams || {})[prop.toUpperCase()]);
      };

      return props;
    }, {})
  },
  watch: {
    rev() {
      if (!this.$source) return;

      if (!isEqual(this.currentParams, this.$source.getParams())) {
        this.currentParams = this.$source.getParams();
      }
    },

    ... /*#__PURE__*/makeWatchers(['currentLayers', 'currentStyles', 'currentVersion', 'currentFormat', 'currentTransparent', 'currentBgColor', 'currentTime'], curProp => function (value) {
      const prop = lowerFirst(curProp.slice(7));
      const inProp = hasProp(this, 'input' + upperFirst(prop)) ? 'input' + upperFirst(prop) : prop;
      if (isEqual(value, this[inProp])) return;
      this.$emit('update:' + prop, isObjectLike(value) ? clonePlainObject(value) : value);
    }),
    ... /*#__PURE__*/makeChangeOrRecreateWatchers(['hidpi', 'serverType', 'inputParams', 'currentParams'], ['inputParams', 'currentParams'])
  },

  created() {
    this.currentParams = this.inputParams && clonePlainObject(this.inputParams);
  },

  methods: {
    /**
     * @param {number[]} coordinate
     * @param {number} [resolution]
     * @param {string} [projection]
     * @param {Object|undefined} [params] GetFeatureInfo params. `info_format` at least should be provided.
     *                          If `query_layers` is not provided then the layers specified in the `layers` prop will be used.
     *                          `version` should not be specified here (value from `version` prop will be used).
     * @return {Promise<string|undefined>}
     */
    async getFeatureInfoUrl(coordinate, resolution, projection) {
      var _this$$viewVm;

      let params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      resolution || (resolution = (_this$$viewVm = this.$viewVm) === null || _this$$viewVm === void 0 ? void 0 : _this$$viewVm.getResolution());
      projection || (projection = this.resolvedDataProjection);
      return (await this.resolveSource()).getFeatureInfoUrl(coordinate, resolution, projection, params);
    },

    /**
     * @param {number} resolution
     * @param {Object|undefined} [params]
     * @return {Promise<string|undefined>}
     */
    async getLegendUrl(resolution) {
      let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return (await this.resolveSource()).getLegendUrl(resolution, params);
    },

    /**
     * @returns {Object}
     */
    getParams() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getParams(), this.currentParams);
    },

    /**
     * @param {Object} params
     */
    updateParams(params) {
      params = reduce({ ...this.currentParams,
        ...params
      }, (params, value, name) => ({ ...params,
        [name.toUpperCase()]: value
      }), {});

      if (!isEqual(params, this.currentParams)) {
        this.currentParams = params;
      }

      if (this.$source && !isEqual(params, this.$source.getParams())) {
        this.$source.updateParams(params);
      }
    },

    /**
     * @param {string} param
     * @param {*} value
     */
    updateParam(param, value) {
      this.updateParams({
        [param.toUpperCase()]: value
      });
    },

    /**
     * @param {Object|undefined} value
     * @protected
     */
    inputParamsChanged(value) {
      this.updateParams(value);
    },

    /**
     * @param {Object|undefined} value
     * @protected
     */
    currentParamsChanged(value) {
      value = value ? cleanWmsSourceParams(value) : undefined;
      if (isEqual(value, this.customParams)) return;
      this.$emit('update:params', value && clonePlainObject(value));
    }

  }
};

const validateMinZoom = value => value >= 0;

const validateTileSize = /*#__PURE__*/or(isNumber, and(isArray, value => value.length === 2 && value.every(isNumber)));
/**
 * Base XYZ source mixin.
 */

var xyzSource = {
  mixins: [tileImageSource],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Source
    projection: { ...source.props.projection,
      default: EPSG_3857
    },

    /* eslint-enable vue/require-prop-types */
    // ol/source/XYZ
    maxZoom: {
      type: Number,
      default: 42
    },
    minZoom: {
      type: Number,
      default: 0,
      validator: validateMinZoom
    },
    maxResolution: Number,
    tileSize: {
      type: [Number, Array],
      default: () => [256, 256],
      validator: validateTileSize
    }
  },
  computed: {
    inputTileSize() {
      return isArray(this.tileSize) ? this.tileSize.slice() : [this.tileSize, this.tileSize];
    },

    derivedTileGridFactory() {
      if (isFunction(this.tileGridFactory)) {
        return this.tileGridFactory;
      }

      const extent = extentFromProjection(this.resolvedDataProjection);
      const maxZoom = this.maxZoom;
      const minZoom = this.minZoom;
      const maxResolution = this.maxResolution;
      const tileSize = this.inputTileSize;
      return () => createXYZ({
        extent,
        maxZoom,
        minZoom,
        maxResolution,
        tileSize
      });
    },

    inputTileUrlFunction() {
      const urlFunc = coalesce(this.tileUrlFunction, this.tileUrlFunc);
      if (isFunction(urlFunc)) return urlFunc;
      if (this.currentUrls.length === 0) return;
      return createTileUrlFunctionFromTemplates(this.currentUrls, this.tileGrid);
    }

  },
  methods: {
    /**
     * @return {module:ol/source/XYZ~XYZSource}
     * @protected
     */
    createSource() {
      return new XYZ({
        // ol/source/Source
        attributions: this.currentAttributions,
        attributionsCollapsible: this.attributionsCollapsible,
        projection: this.resolvedDataProjection,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        opaque: this.opaque,
        tilePixelRatio: this.tilePixelRatio,
        transition: this.transition,
        zDirection: this.zDirection,
        tileGrid: this.tileGrid,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        tileUrlFunction: this.currentTileUrlFunction,
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        tileClass: this.tileClass,
        imageSmoothing: this.imageSmoothing
      });
    },

    tileKeyChanged: noop,
    // input tileKey is not allowed in XYZ constructor
    stateChanged: noop // input state is not allowed in XYZ constructor

  }
};

export { CanceledError, EVENT_BUS_PROP, FRAME_TIME, IDENTITY_MAP_PROP, INSTANCES_POOL, LifecycleError, OlObjectAction, OlObjectEvent, OlObjectState, SERVICES_PROP, VM_PROP, arcgisSource, baseLayer, controlsContainer, eventBus, feature, featureHelper, featuresContainer, fillStyleContainer, geometry, geometryContainer, identMap, imageLayer, imageSource, imageStyle, imageStyleContainer, interaction, interactionsContainer, isCreateError, isDestroyError, isMountError, isUnmountError, layer, layersContainer, makeChangeOrRecreateWatchers, olCmp, overlaysContainer, projTransforms, regShapeStyle, rxSubs, services, simpleGeometry, source, sourceContainer, strokeStyleContainer, stubVNode, style, styleContainer, textStyleContainer, tileImageSource, tileLayer, tileSource, urlTileSource, vectorLayer, vectorSource, waitForMap, wmsSource, xyzSource };
//# sourceMappingURL=mixins.js.map
